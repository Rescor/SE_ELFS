//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   10/Jun/2013  23:09:18 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\decoder2.cpp                                      /
//    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\decoder2.cpp -D NDEBUG -D RUS -D OLDFUNCTIONS     /
//                       -lC Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDi /
//                       splay\Release_RU\List\ -lA                          /
//                       Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\Release_RU\List\ -o Z:\home\perk11\www\perk11.inf /
//                       o\svn\SE\WalkmanDisplay\Release_RU\Obj\ -s9         /
//                       --cpu_mode arm --endian little --cpu ARM926EJ-S     /
//                       --stack_align 4 --interwork -e --enable_multibytes  /
//                       --fpu None --eec++ --dlib_config                    /
//                       Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8n.h -I        /
//                       Z:\home\perk11\IAR2\arm\INC\ --inline_threshold=2   /
//    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\Release_RU\List\decoder2.s79                      /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME decoder2

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ??div32_a

??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable10 EQU 0
??DataTable11 EQU 0
??DataTable12 EQU 0
??DataTable13 EQU 0
??DataTable14 EQU 0
??DataTable15 EQU 0
??DataTable16 EQU 0
??DataTable17 EQU 0
??DataTable18 EQU 0
??DataTable19 EQU 0
??DataTable2 EQU 0
??DataTable20 EQU 0
??DataTable21 EQU 0
??DataTable3 EQU 0
??DataTable4 EQU 0
??DataTable5 EQU 0
??DataTable6 EQU 0
??DataTable7 EQU 0
??DataTable8 EQU 0
??DataTable9 EQU 0
        PUBLIC ??IsValidHeader
        FUNCTION ??IsValidHeader,0203H
        MULTWEAK ??IsValidHeader??rT
        PUBLIC ??LoadMP3Header
        FUNCTION ??LoadMP3Header,0203H
        MULTWEAK ??LoadMP3Header??rT
        PUBLIC ??LoadVBRHeader
        FUNCTION ??LoadVBRHeader,0203H
        MULTWEAK ??LoadVBRHeader??rT
        PUBLIC ??ReadMP3Information
        FUNCTION ??ReadMP3Information,0203H
        LOCFRAME CSTACK, 196, STACK
        MULTWEAK ??ReadMP3Information??rT
        MULTWEAK ??__dDiv??rA
        MULTWEAK ??__dMul??rA
        MULTWEAK ??__doubleToLong??rA
        MULTWEAK ??__floatToDouble??rA
        MULTWEAK ??__longToDouble??rA
        MULTWEAK ??__longToFloat??rA
        PUBLIC ??getBitrate
        FUNCTION ??getBitrate,0203H
        LOCFRAME CSTACK, 408, STACK
        MULTWEAK ??getBitrate??rT
        PUBLIC ??getBitrateIndex
        FUNCTION ??getBitrateIndex,0203H
        MULTWEAK ??getBitrateIndex??rT
        PUBLIC ??getCoprightBit
        FUNCTION ??getCoprightBit,0203H
        MULTWEAK ??getCoprightBit??rT
        PUBLIC ??getEmphasisIndex
        FUNCTION ??getEmphasisIndex,0203H
        MULTWEAK ??getEmphasisIndex??rT
        PUBLIC ??getFrameSync
        FUNCTION ??getFrameSync,0203H
        MULTWEAK ??getFrameSync??rT
        PUBLIC ??getFrequency
        FUNCTION ??getFrequency,0203H
        LOCFRAME CSTACK, 100, STACK
        MULTWEAK ??getFrequency??rT
        PUBLIC ??getFrequencyIndex
        FUNCTION ??getFrequencyIndex,0203H
        MULTWEAK ??getFrequencyIndex??rT
        PUBLIC ??getLayer
        FUNCTION ??getLayer,0203H
        MULTWEAK ??getLayer??rT
        PUBLIC ??getLayerIndex
        FUNCTION ??getLayerIndex,0203H
        MULTWEAK ??getLayerIndex??rT
        PUBLIC ??getLengthInSeconds
        FUNCTION ??getLengthInSeconds,0203H
        LOCFRAME CSTACK, 8, STACK
        MULTWEAK ??getLengthInSeconds??rT
        PUBLIC ??getMode
        FUNCTION ??getMode,0203H
        MULTWEAK ??getMode??rT
        PUBLIC ??getModeExtIndex
        FUNCTION ??getModeExtIndex,0203H
        MULTWEAK ??getModeExtIndex??rT
        PUBLIC ??getModeIndex
        FUNCTION ??getModeIndex,0203H
        MULTWEAK ??getModeIndex??rT
        PUBLIC ??getNumberOfFrames
        FUNCTION ??getNumberOfFrames,0203H
        LOCFRAME CSTACK, 28, STACK
        MULTWEAK ??getNumberOfFrames??rT
        PUBLIC ??getOrginalBit
        FUNCTION ??getOrginalBit,0203H
        MULTWEAK ??getOrginalBit??rT
        PUBLIC ??getPaddingBit
        FUNCTION ??getPaddingBit,0203H
        MULTWEAK ??getPaddingBit??rT
        PUBLIC ??getPrivateBit
        FUNCTION ??getPrivateBit,0203H
        MULTWEAK ??getPrivateBit??rT
        PUBLIC ??getProtectionBit
        FUNCTION ??getProtectionBit,0203H
        MULTWEAK ??getProtectionBit??rT
        PUBLIC ??getVersion
        FUNCTION ??getVersion,0203H
        LOCFRAME CSTACK, 52, STACK
        MULTWEAK ??getVersion??rT
        PUBLIC ??getVersionIndex
        FUNCTION ??getVersionIndex,0203H
        MULTWEAK ??getVersionIndex??rT
        MULTWEAK `??operator delete??rA`
        MULTWEAK `??operator new[]??rA`
        MULTWEAK ??rA??div32_a
        PUBLIC ??synchsafeToNormal
        FUNCTION ??synchsafeToNormal,0203H
        LOCFRAME CSTACK, 8, STACK
        MULTWEAK ??synchsafeToNormal??rT
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC bithdr
        PUBLIC boolVBitRate
        PUBLIC intVFrames
        PUBLIC lngFileSize
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        


__dDiv              SYMBOL "__dDiv"
__dMul              SYMBOL "__dMul"
__doubleToLong      SYMBOL "__doubleToLong"
__floatToDouble     SYMBOL "__floatToDouble"
__longToDouble      SYMBOL "__longToDouble"
__longToFloat       SYMBOL "__longToFloat"

??IsValidHeader??rT SYMBOL "??rT", ??IsValidHeader

??LoadMP3Header??rT SYMBOL "??rT", ??LoadMP3Header

??LoadVBRHeader??rT SYMBOL "??rT", ??LoadVBRHeader

??ReadMP3Information??rT SYMBOL "??rT", ??ReadMP3Information
??__dDiv??rA        SYMBOL "??rA", __dDiv
??__dMul??rA        SYMBOL "??rA", __dMul
??__doubleToLong??rA SYMBOL "??rA", __doubleToLong
??__floatToDouble??rA SYMBOL "??rA", __floatToDouble
??__longToDouble??rA SYMBOL "??rA", __longToDouble
??__longToFloat??rA SYMBOL "??rA", __longToFloat

??getBitrate??rT    SYMBOL "??rT", ??getBitrate

??getBitrateIndex??rT SYMBOL "??rT", ??getBitrateIndex

??getCoprightBit??rT SYMBOL "??rT", ??getCoprightBit

??getEmphasisIndex??rT SYMBOL "??rT", ??getEmphasisIndex

??getFrameSync??rT  SYMBOL "??rT", ??getFrameSync

??getFrequency??rT  SYMBOL "??rT", ??getFrequency

??getFrequencyIndex??rT SYMBOL "??rT", ??getFrequencyIndex

??getLayer??rT      SYMBOL "??rT", ??getLayer

??getLayerIndex??rT SYMBOL "??rT", ??getLayerIndex

??getLengthInSeconds??rT SYMBOL "??rT", ??getLengthInSeconds

??getMode??rT       SYMBOL "??rT", ??getMode

??getModeExtIndex??rT SYMBOL "??rT", ??getModeExtIndex

??getModeIndex??rT  SYMBOL "??rT", ??getModeIndex

??getNumberOfFrames??rT SYMBOL "??rT", ??getNumberOfFrames

??getOrginalBit??rT SYMBOL "??rT", ??getOrginalBit

??getPaddingBit??rT SYMBOL "??rT", ??getPaddingBit

??getPrivateBit??rT SYMBOL "??rT", ??getPrivateBit

??getProtectionBit??rT SYMBOL "??rT", ??getProtectionBit

??getVersion??rT    SYMBOL "??rT", ??getVersion

??getVersionIndex??rT SYMBOL "??rT", ??getVersionIndex
`??operator delete??rA` SYMBOL "??rA", `??operator delete`
`??operator new[]??rA` SYMBOL "??rA", `??operator new[]`

??synchsafeToNormal??rT SYMBOL "??rT", ??synchsafeToNormal

        EXTERN `??operator delete`
        FUNCTION `??operator delete`,0202H
        EXTERN `??operator new[]`
        FUNCTION `??operator new[]`,0202H
        EXTERN __dDiv
        FUNCTION __dDiv,0202H
        EXTERN __dMul
        FUNCTION __dMul,0202H
        EXTERN __doubleToLong
        FUNCTION __doubleToLong,0202H
        EXTERN __floatToDouble
        FUNCTION __floatToDouble,0202H
        EXTERN __longToDouble
        FUNCTION __longToDouble,0202H
        EXTERN __longToFloat
        FUNCTION __longToFloat,0202H


        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??synchsafeToNormal??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE ??synchsafeToNormal
// Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay\decoder2.cpp
//    1 #include "..\deleaker\mem2.h"
//    2 #include "..\include\Lib_Clara.h" 
//    3 #include "..\include\Dir.h" 
//    4 #include "header\wdisplay.h"
//    5 
//    6 // Модуль получения инфы из мп3
//    7 // Оригинальный код Robert Wlodarczyk'а (http://www.devhood.com/tutorials/tutorial_details.aspx?tutorial_id=79)
//    8 // Адаптация под SE от UltraShot'а
//    9 
//   10 typedef unsigned long int ulong;
//   11 typedef char byte;
//   12 
//   13 #define INDEX(x) x/8
//   14 #define SHIFT(x) x%8
//   15 #define GETBIT(v,x) ((v[INDEX(x)] << SHIFT(x)) & 0x80)>>7
//   16 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function ??synchsafeToNormal
        ARM
//   17 int synchsafeToNormal(char tagSize[4])
//   18 {
??synchsafeToNormal:
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//   19   int synchsafe, sizeloc, size, power, x;
//   20   
//   21   size=sizeloc=0;
        MOV      R2,#+0
        MOV      R1,#+0
//   22   for(synchsafe=31;synchsafe>=0;synchsafe--)
        MOV      R3,#+31
//   23   {
//   24     if(GETBIT(tagSize, synchsafe))
??synchsafeToNormal_1:
        ASR      R4,R3,#+2
        ADD      R4,R3,R4, LSR #+29
        ASR      R12,R4,#+3
        LDRB     R5,[R12, +R0]
        SUB      R4,R3,R12, LSL #+3
        LSL      R5,R5,R4
        TST      R5,#0x80
        BEQ      ??synchsafeToNormal_2
//   25     {
//   26       power=1;
        MOV      R12,#+1
//   27       for(x=0;x<sizeloc;x++) power*=2;
        MOV      R5,#+0
        CMP      R2,#+1
        BGE      ??synchsafeToNormal_3
        B        ??synchsafeToNormal_4
??synchsafeToNormal_5:
        LSL      R12,R12,#+1
        ADD      R5,R5,#+1
??synchsafeToNormal_3:
        CMP      R5,R2
        BLT      ??synchsafeToNormal_5
//   28       size+=power;
??synchsafeToNormal_4:
        ADD      R1,R12,R1
//   29     }
//   30     if(synchsafe%8) sizeloc++;
??synchsafeToNormal_2:
        CMP      R4,#+0
        ADDNE    R2,R2,#+1
//   31   }
        SUBS     R3,R3,#+1
        BPL      ??synchsafeToNormal_1
//   32   return size;
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        MOV      R0,R1
        BX       LR               ;; return
        CFI EndBlock cfiBlock1
//   33 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??ReadMP3Information??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE ??ReadMP3Information
//   34 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   35 long lngFileSize;
lngFileSize:
        DS8 4
//   36 
//   37 ulong bithdr;
bithdr:
        DS8 4
//   38 bool boolVBitRate;
//   39 int intVFrames;
intVFrames:
        DS8 4
boolVBitRate:
        DS8 1
//   40 
//   41 int getFrequency();
//   42 int getMode();
//   43 void LoadMP3Header(byte *c);
//   44 bool LoadVBRHeader(byte *inputheader);
//   45 int getLengthInSeconds();
//   46 bool IsValidHeader();
//   47 int getVersionIndex();
//   48 int getBitrate();
//   49 int getModeIndex();
//   50     

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function ??ReadMP3Information
        ARM
//   51 HEADER_INFO ReadMP3Information(wchar_t *path, wchar_t *name)
//   52 {
??ReadMP3Information:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
//   53   HEADER_INFO hdr;
//   54   FSTAT stat;
//   55   fstat(path,name,&stat);
//   56   lngFileSize = stat.fsize;
        LDR      R5,??DataTable24  ;; lngFileSize
        SUB      SP,SP,#+164
        CFI CFA R13+192
        MOV      R4,R0
        MOV      R6,R1
        MOV      R7,R2
        ADD      R2,SP,#+32
        MOV      R1,R7
        MOV      R0,R6
        SWI      +284
        LDR      R0,[SP, #+40]
//   57   int file;
//   58   file=_fopen(path,name,FSX_O_RDONLY,FSX_S_IREAD|FSX_S_IWRITE,0);
        MOV      R3,#+384
        STR      R0,[R5, #+0]
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+196
        MOV      R2,#+1
        MOV      R1,R7
//   59   
//   60   char BUF[100+1];
//   61   fread(file,BUF,100);
//   62   int size=0;
        MOV      R9,#+0
        MOV      R0,R6
        SWI      +278
        MOV      R6,R0
        MOV      R2,#+100
        ADD      R1,SP,#+64
        SWI      +280
//   63   if (BUF[0]=='I' && BUF[1]=='D' && BUF[2]=='3') // проверяем, есть ли тэги v2.x
        LDRB     R0,[SP, #+64]
        ADD      SP,SP,#+4
        CFI CFA R13+192
        CMP      R0,#+73
        LDRBEQ   R0,[SP, #+61]
        CMPEQ    R0,#+68
        LDRBEQ   R0,[SP, #+62]
        CMPEQ    R0,#+51
        BNE      ??ReadMP3Information_1
//   64   {
//   65     // Есть, значит надо вычесть из размера файла размер тэгов
//   66     char tagSize[4];
//   67     tagSize[0]=BUF[6];
        LDRB     R1,[SP, #+66]
//   68     tagSize[1]=BUF[7];
//   69     tagSize[2]=BUF[8];
//   70     tagSize[3]=BUF[9];
//   71     size=synchsafeToNormal(tagSize);
        MOV      R0,SP
        STRB     R1,[SP, #+0]
        LDRB     R1,[SP, #+67]
        STRB     R1,[SP, #+1]
        LDRB     R1,[SP, #+68]
        STRB     R1,[SP, #+2]
        LDRB     R1,[SP, #+69]
        STRB     R1,[SP, #+3]
        BL       ??synchsafeToNormal
        MOV      R9,R0
//   72     lngFileSize=lngFileSize-size;
        LDR      R0,[R5, #+0]
        SUB      R0,R0,R9
        STR      R0,[R5, #+0]
//   73   }
//   74   int intPos = 0;
//   75   intPos=size;
//   76   hdr.lngFileSize=lngFileSize;
??ReadMP3Information_1:
        LDR      R1,[R5, #+0]
//   77   hdr.id3size=size;
//   78   byte *bytHeader = new byte[4];
        MOV      R0,#+4
        STR      R1,[SP, #+16]
        STR      R9,[SP, #+20]
        _BLF     `??operator new[]`,`??operator new[]??rA`
        MOV      R7,R0
//   79   byte *bytVBitRate = new byte[12];
        MOV      R0,#+12
        _BLF     `??operator new[]`,`??operator new[]??rA`
        MOV      R8,R0
//   80   // Keep reading 4 bytes from the header until we know for sure that in 
//   81   // fact it's an MP3
//   82   do
//   83   {
//   84     lseek(file,intPos,0);
??ReadMP3Information_2:
        MOV      R2,#+0
        MOV      R1,R9
        MOV      R0,R6
        SWI      +374
//   85     fread(file,bytHeader,4);
        MOV      R2,#+4
        MOV      R1,R7
        MOV      R0,R6
        SWI      +280
//   86     intPos++;
        ADD      R9,R9,#+1
//   87     LoadMP3Header(bytHeader);
        MOV      R0,R7
        BL       ??LoadMP3Header
//   88   }
//   89   while(!IsValidHeader() && (intPos!=stat.fsize));
        BL       ??IsValidHeader
        CMP      R0,#+0
        BNE      ??ReadMP3Information_3
        LDR      R0,[SP, #+40]
        CMP      R9,R0
        BNE      ??ReadMP3Information_2
//   90   
//   91   // If the current file stream position is equal to the length, 
//   92   // that means that we've read the entire file and it's not a valid MP3 file
//   93   if(intPos != stat.fsize)
??ReadMP3Information_3:
        LDR      R0,[SP, #+40]
        CMP      R9,R0
        BEQ      ??ReadMP3Information_4
//   94   {
//   95     intPos += 3;
//   96     
//   97     if(getVersionIndex() == 3)    // MPEG Version 1
        LDR      R1,[R5, #+4]
        ADD      R0,R9,#+3
        LSR      R2,R1,#+6
        AND      R2,R2,#0x3
        LSR      R1,R1,#+19
        AND      R1,R1,#0x3
        CMP      R1,#+3
        BNE      ??ReadMP3Information_5
//   98     {
//   99       if(getModeIndex() == 3)    // Single Channel
        CMP      R2,#+3
        BEQ      ??ReadMP3Information_6
//  100       {
//  101         intPos += 17;
//  102       }
//  103       else
//  104       {
//  105         intPos += 32;
        ADD      R9,R0,#+32
        B        ??ReadMP3Information_7
//  106       }
//  107     }
//  108     else                        // MPEG Version 2.0 or 2.5
//  109     {
//  110       if(getModeIndex() == 3)    // Single Channel
??ReadMP3Information_5:
        CMP      R2,#+3
//  111       {
//  112         intPos += 9;
        ADDEQ    R9,R0,#+9
        BEQ      ??ReadMP3Information_7
//  113       }
//  114       else
//  115       {
//  116         intPos += 17;
??ReadMP3Information_6:
        ADD      R9,R0,#+17
//  117       }
//  118     }
//  119     
//  120     // Check to see if the MP3 has a variable bitrate
//  121     lseek(file,intPos,0);
??ReadMP3Information_7:
        MOV      R2,#+0
        MOV      R1,R9
        MOV      R0,R6
        SWI      +374
//  122     fread(file,bytVBitRate,12);
        MOV      R2,#+12
        MOV      R1,R8
        MOV      R0,R6
        SWI      +280
//  123     boolVBitRate = LoadVBRHeader(bytVBitRate);
        MOV      R0,R8
        BL       ??LoadVBRHeader
        STRB     R0,[R5, #+12]
//  124     hdr.VBR=boolVBitRate;
        MOV      R1,R0
        STRB     R1,[SP, #+8]
//  125     // Once the file's read in, then assign the properties of the file to the public variables
//  126     hdr.bitrate = getBitrate();
        BL       ??getBitrate
        STR      R0,[SP, #+4]
//  127     hdr.frequency = getFrequency();
        BL       ??getFrequency
        STR      R0,[SP, #+24]
//  128     hdr.mode=getMode();
        BL       ??getMode
        STR      R0,[SP, #+28]
//  129     hdr.LengthInSeconds = getLengthInSeconds();
        BL       ??getLengthInSeconds
        STR      R0,[SP, #+12]
//  130     delete(bytVBitRate);
//  131     delete(bytHeader);
//  132     fclose(file);
//  133     return hdr;
//  134   }
//  135   delete(bytVBitRate);
??ReadMP3Information_4:
        MOV      R0,R8
        _BLF     `??operator delete`,`??operator delete??rA`
//  136   delete(bytHeader);
        MOV      R0,R7
        _BLF     `??operator delete`,`??operator delete??rA`
//  137   fclose(file);
        MOV      R0,R6
        SWI      +279
//  138   return hdr;
        ADD      R0,SP,#+4
        LDM      R0,{R1-R3,R5-R8}
        MOV      R0,R4
        STM      R4,{R1-R3,R5-R8}
        ADD      SP,SP,#+164
        CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock3
//  139 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??LoadMP3Header??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE ??LoadMP3Header
//  140 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function ??LoadMP3Header
        ARM
//  141 void LoadMP3Header(byte *c)
//  142 {
//  143   // this thing is quite interesting, it works like the following
//  144   // c[0] = 00000011
//  145   // c[1] = 00001100
//  146   // c[2] = 00110000
//  147   // c[3] = 11000000
//  148   // the operator << means that we'll move the bits in that direction
//  149   // 00000011 << 24 = 00000011000000000000000000000000
//  150   // 00001100 << 16 =         000011000000000000000000
//  151   // 00110000 << 24 =                 0011000000000000
//  152   // 11000000       =                         11000000
//  153   //                +_________________________________
//  154   //                  00000011000011000011000011000000
//  155   bithdr = (ulong)(((c[0] & 255) << 24) | ((c[1] & 255) << 16) | ((c[2] & 255) <<  8) | ((c[3] & 255))); 
??LoadMP3Header:
        LDRB     R2,[R0, #+0]
        LDRB     R3,[R0, #+1]
        LDR      R1,??DataTable23  ;; lngFileSize + 4
        LSL      R3,R3,#+16
        ORR      R2,R3,R2, LSL #+24
        LDRB     R3,[R0, #+2]
        LDRB     R0,[R0, #+3]
        ORR      R2,R2,R3, LSL #+8
        ORR      R0,R0,R2
        STR      R0,[R1, #+0]
//  156 };
        BX       LR               ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??LoadVBRHeader??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE ??LoadVBRHeader
//  157 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function ??LoadVBRHeader
        ARM
//  158 bool LoadVBRHeader(byte *inputheader)
//  159 {
//  160   // If it's a variable bitrate MP3, the first 4 bytes will read 'Xing'
//  161   // since they're the ones who added variable bitrate-edness to MP3s
//  162   if(inputheader[0] == 88 && inputheader[1] == 105 && 
//  163      inputheader[2] == 110 && inputheader[3] == 103)
??LoadVBRHeader:
        LDRB     R1,[R0, #+0]
        CMP      R1,#+88
        LDRBEQ   R1,[R0, #+1]
        CMPEQ    R1,#+105
        LDRBEQ   R1,[R0, #+2]
        CMPEQ    R1,#+110
        LDRBEQ   R1,[R0, #+3]
        CMPEQ    R1,#+103
        BNE      ??LoadVBRHeader_1
//  164   {
//  165     int flags = (int)(((inputheader[4] & 255) << 24) | ((inputheader[5] & 255) << 16) | ((inputheader[6] & 255) <<  8) | ((inputheader[7] & 255)));
//  166     if((flags & 0x0001) == 1)
        LDRB     R2,[R0, #+7]
        LDR      R1,??LoadVBRHeader_2  ;; lngFileSize
        TST      R2,#0x1
        BEQ      ??LoadVBRHeader_3
//  167     {
//  168       intVFrames = (int)(((inputheader[8] & 255) << 24) | ((inputheader[9] & 255) << 16) | ((inputheader[10] & 255) <<  8) | ((inputheader[11] & 255)));
        LDRB     R2,[R0, #+8]
        LDRB     R3,[R0, #+9]
        LSL      R3,R3,#+16
        ORR      R2,R3,R2, LSL #+24
        LDRB     R3,[R0, #+10]
        LDRB     R0,[R0, #+11]
        ORR      R2,R2,R3, LSL #+8
        ORR      R0,R0,R2
        B        ??LoadVBRHeader_4
//  169       return true;
//  170     }
//  171     else
//  172     {
//  173       intVFrames = -1;
??LoadVBRHeader_3:
        MVN      R0,#+0
??LoadVBRHeader_4:
        STR      R0,[R1, #+8]
//  174       return true;
        MOV      R0,#+1
        BX       LR
//  175     }
//  176   }
//  177   return false;
??LoadVBRHeader_1:
        MOV      R0,#+0
        BX       LR               ;; return
        DATA
??LoadVBRHeader_2:
        DC32     lngFileSize
        CFI EndBlock cfiBlock7
//  178 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??getFrameSync??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE ??getFrameSync
//  179 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function ??getFrameSync
        ARM
//  180 int getFrameSync()     
//  181 {
//  182   return (int)((bithdr>>21) & 2047); 
??getFrameSync:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        LDR      R0,[R0, #+0]
        LSR      R0,R0,#+21
        BX       LR               ;; return
        CFI EndBlock cfiBlock9
//  183 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??getVersionIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE ??getVersionIndex
//  184 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function ??getVersionIndex
        ARM
//  185 int getVersionIndex()  
//  186 { 
//  187   return (int)((bithdr>>19) & 3);  
??getVersionIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+19
        BX       LR               ;; return
        CFI EndBlock cfiBlock11
//  188 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??getLayerIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE ??getLayerIndex
//  189 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function ??getLayerIndex
        ARM
//  190 int getLayerIndex()    
//  191 { 
//  192   return (int)((bithdr>>17) & 3);  
??getLayerIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+17
        BX       LR               ;; return
        CFI EndBlock cfiBlock13
//  193 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??getProtectionBit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE ??getProtectionBit
//  194 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function ??getProtectionBit
        ARM
//  195 int getProtectionBit() 
//  196 { 
//  197   return (int)((bithdr>>16) & 1);  
??getProtectionBit:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+1
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+16
        BX       LR               ;; return
        CFI EndBlock cfiBlock15
//  198 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??getBitrateIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE ??getBitrateIndex
//  199 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function ??getBitrateIndex
        ARM
//  200 int getBitrateIndex()  
//  201 { 
//  202   return (int)((bithdr>>12) & 15); 
??getBitrateIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+15
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+12
        BX       LR               ;; return
        CFI EndBlock cfiBlock17
//  203 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??getFrequencyIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE ??getFrequencyIndex
//  204 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function ??getFrequencyIndex
        ARM
//  205 int getFrequencyIndex()
//  206 { 
//  207   return (int)((bithdr>>10) & 3);  
??getFrequencyIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+10
        BX       LR               ;; return
        CFI EndBlock cfiBlock19
//  208 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??getPaddingBit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE ??getPaddingBit
//  209 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function ??getPaddingBit
        ARM
//  210 int getPaddingBit()    
//  211 { 
//  212   return (int)((bithdr>>9) & 1);  
??getPaddingBit:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+1
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+9
        BX       LR               ;; return
        CFI EndBlock cfiBlock21
//  213 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??getPrivateBit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE ??getPrivateBit
//  214 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function ??getPrivateBit
        ARM
//  215 int getPrivateBit()    
//  216 { 
//  217   return (int)((bithdr>>8) & 1);  
??getPrivateBit:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+1
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+8
        BX       LR               ;; return
        CFI EndBlock cfiBlock23
//  218 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??getModeIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE ??getModeIndex
//  219 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function ??getModeIndex
        ARM
//  220 int getModeIndex()     
//  221 { 
//  222   return (int)((bithdr>>6) & 3);  
??getModeIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+6
        BX       LR               ;; return
        CFI EndBlock cfiBlock25
//  223 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??getModeExtIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE ??getModeExtIndex
//  224 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function ??getModeExtIndex
        ARM
//  225 int getModeExtIndex()  
//  226 { 
//  227   return (int)((bithdr>>4) & 3);  
??getModeExtIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+4
        BX       LR               ;; return
        CFI EndBlock cfiBlock27
//  228 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??getCoprightBit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE ??getCoprightBit
//  229 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function ??getCoprightBit
        ARM
//  230 int getCoprightBit()   
//  231 { 
//  232   return (int)((bithdr>>3) & 1);  
??getCoprightBit:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+1
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+3
        BX       LR               ;; return
        CFI EndBlock cfiBlock29
//  233 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??getOrginalBit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE ??getOrginalBit
//  234 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function ??getOrginalBit
        ARM
//  235 int getOrginalBit()    
//  236 { 
//  237   return (int)((bithdr>>2) & 1);  
??getOrginalBit:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+1
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+2
        BX       LR               ;; return
        CFI EndBlock cfiBlock31
//  238 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??getEmphasisIndex??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE ??getEmphasisIndex
//  239 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function ??getEmphasisIndex
        ARM
//  240 int getEmphasisIndex() 
//  241 { 
//  242   return (int)(bithdr & 3);  
??getEmphasisIndex:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        LDR      R0,[R0, #+0]
        AND      R0,R0,#0x3
        BX       LR               ;; return
        CFI EndBlock cfiBlock33
//  243 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon0
        CFI NoFunction
        THUMB
??getVersion??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock34
        REQUIRE ??getVersion
//  244 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI Function ??getVersion
        ARM
//  245 double getVersion() 
//  246 {
//  247   double table[4] = {2.5, 0.0, 2.0, 1.0};
??getVersion:
        LDR      R1,??getVersion_1  ;; `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`
        PUSH     {R4-R8}
        CFI R8 Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        SUB      SP,SP,#+32
        CFI CFA R13+52
        LDM      R1,{R2-R8,R12}
        MOV      R0,SP
        STM      R0,{R2-R8,R12}
//  248   return table[getVersionIndex()];
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+19
        MOV      R1,SP
        ADD      R0,R1,R0, LSL #+3
        LDM      R0,{R0,R1}
        ADD      SP,SP,#+32
        CFI CFA R13+20
        POP      {R4-R8}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??getVersion_1:
        DC32     `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`
        CFI EndBlock cfiBlock35
//  249 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon0
        CFI NoFunction
        THUMB
??getLayer??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock36
        REQUIRE ??getLayer
//  250 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock37 Using cfiCommon1
        CFI Function ??getLayer
        ARM
//  251 int getLayer() 
//  252 {
//  253   return (int)(4 - getLayerIndex());
??getLayer:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+17
        RSB      R0,R0,#+4
        BX       LR               ;; return
        CFI EndBlock cfiBlock37
//  254 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock38 Using cfiCommon0
        CFI NoFunction
        THUMB
??IsValidHeader??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock38
        REQUIRE ??IsValidHeader
//  255 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock39 Using cfiCommon1
        CFI Function ??IsValidHeader
        ARM
//  256 bool IsValidHeader() 
//  257 {
??IsValidHeader:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R2,#+255
        LDR      R0,[R0, #+0]
        ORR      R2,R2,#0x700
        LSR      R1,R0,#+21
        CMP      R1,R2
        BNE      ??IsValidHeader_1
//  258   return (((getFrameSync()      & 2047)==2047) &&
//  259           ((getVersionIndex()   &    3)!=   1) &&
//  260             ((getLayerIndex()     &    3)!=   0) && 
//  261               ((getBitrateIndex()   &   15)!=   0) &&
//  262                 ((getBitrateIndex()   &   15)!=  15) &&
//  263                   ((getFrequencyIndex() &    3)!=   3) &&
//  264                     ((getEmphasisIndex()  &    3)!=   2)    );
        MOV      R1,#+3
        AND      R1,R1,R0, LSR #+19
        CMP      R1,#+1
        LSRNE    R1,R0,#+17
        TSTNE    R1,#0x3
        LSRNE    R1,R0,#+12
        TSTNE    R1,#0xF
        ANDNE    R1,R1,#0xF
        CMPNE    R1,#+15
        BEQ      ??IsValidHeader_1
        MOV      R1,#+3
        AND      R1,R1,R0, LSR #+10
        CMP      R1,#+3
        ANDNE    R0,R0,#0x3
        CMPNE    R0,#+2
        MOVNE    R0,#+1
        BXNE     LR
??IsValidHeader_1:
        MOV      R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock39
//  265 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock40 Using cfiCommon0
        CFI NoFunction
        THUMB
??getFrequency??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock40
        REQUIRE ??getFrequency
//  266 
//  267 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock41 Using cfiCommon1
        CFI Function ??getFrequency
        ARM
//  268 int getFrequency() 
//  269 {
//  270   int table[5][5] =    {    
//  271     {32000, 16000,  8000}, // MPEG 2.5
//  272     {    0,     0,     0}, // reserved
//  273     {22050, 24000, 16000}, // MPEG 2
//  274     {44100, 48000, 32000}  // MPEG 1
//  275   };
??getFrequency:
        LDR      R1,??getFrequency_1  ;; `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`
        SUB      SP,SP,#+100
        CFI CFA R13+100
        MOV      R0,SP
        MOV      R3,#+100
??getFrequency_2:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??getFrequency_2
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        MOV      R2,#+3
        AND      R1,R1,R0, LSR #+10
        AND      R0,R2,R0, LSR #+19
        MOV      R2,#+20
        MOV      R3,SP
        MLA      R0,R2,R0,R3
        LDR      R0,[R0, +R1, LSL #+2]
        ADD      SP,SP,#+100
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??getFrequency_1:
        DC32     `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`
        CFI EndBlock cfiBlock41
//  276   
//  277   return table[getVersionIndex()][getFrequencyIndex()];
//  278 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock42 Using cfiCommon0
        CFI NoFunction
        THUMB
??getNumberOfFrames??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock42
        REQUIRE ??getNumberOfFrames
//  279 
//  280 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock43 Using cfiCommon1
        CFI Function ??getNumberOfFrames
        ARM
//  281 int getNumberOfFrames() 
//  282 {
??getNumberOfFrames:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
//  283   // Again, the number of MPEG frames is dependant on whether it's a variable bitrate MP3 or not
//  284   if (!boolVBitRate) 
        LDR      R6,??DataTable24  ;; lngFileSize
        LDRB     R0,[R6, #+12]
        CMP      R0,#+0
        BNE      ??getNumberOfFrames_1
//  285   {
//  286     double medFrameSize = (double)(((getLayerIndex()==3) ? 12 : 144) *((1000.0 * (float)getBitrate())/(float)getFrequency()));
        LDR      R0,[R6, #+4]
        LSR      R0,R0,#+17
        AND      R0,R0,#0x3
        CMP      R0,#+3
        MOVEQ    R7,#+12
        MOVNE    R7,#+144
        BL       ??getBitrate
        MOV      R4,R0
        BL       ??getFrequency
        _BLF     __longToFloat,??__longToFloat??rA
        _BLF     __floatToDouble,??__floatToDouble??rA
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R4
        _BLF     __longToFloat,??__longToFloat??rA
        _BLF     __floatToDouble,??__floatToDouble??rA
        LDR      R3,??DataTable22  ;; 0x408f4000
        MOV      R2,#+0
        _BLF     __dMul,??__dMul??rA
        MOV      R2,R8
        MOV      R3,R9
        _BLF     __dDiv,??__dDiv??rA
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
        _BLF     __longToDouble,??__longToDouble??rA
        MOV      R2,R4
        MOV      R3,R5
        _BLF     __dMul,??__dMul??rA
        MOV      R4,R0
//  287     return (int)(lngFileSize/medFrameSize);
        LDR      R0,[R6, #+0]
        MOV      R5,R1
        _BLF     __longToDouble,??__longToDouble??rA
        MOV      R2,R4
        MOV      R3,R5
        _BLF     __dDiv,??__dDiv??rA
        _BLF     __doubleToLong,??__doubleToLong??rA
        POP      {R4-R9,PC}
//  288   }
//  289   else 
//  290     return intVFrames;
??getNumberOfFrames_1:
        LDR      R0,[R6, #+8]
        POP      {R4-R9,PC}       ;; return
        CFI EndBlock cfiBlock43
//  291 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock44 Using cfiCommon0
        CFI NoFunction
        THUMB
??getBitrate??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock44
        REQUIRE ??getBitrate
//  292 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock45 Using cfiCommon1
        CFI Function ??getBitrate
        ARM
//  293 int getBitrate() 
//  294 {
??getBitrate:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  295   // If the file has a variable bitrate, then we return an integer average bitrate,
//  296   // otherwise, we use a lookup table to return the bitrate
//  297   if(boolVBitRate)
        LDR      R6,??DataTable24  ;; lngFileSize
        SUB      SP,SP,#+384
        CFI CFA R13+408
        LDRB     R0,[R6, #+12]
        CMP      R0,#+0
        BEQ      ??getBitrate_1
//  298   {
//  299     double medFrameSize = (double)lngFileSize / (double)getNumberOfFrames();
        BL       ??getNumberOfFrames
        MOV      R8,R0
        LDR      R0,[R6, #+0]
        _BLF     __longToDouble,??__longToDouble??rA
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R8
        _BLF     __longToDouble,??__longToDouble??rA
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
        _BLF     __dDiv,??__dDiv??rA
        MOV      R4,R0
        MOV      R5,R1
//  300     return (int)((medFrameSize * (double)getFrequency()) / (1000.0 * ((getLayerIndex()==3) ? 12.0 : 144.0)));
        BL       ??getFrequency
        LDR      R1,??DataTable22  ;; 0x408f4000
        MOV      R8,R0
        LDR      R0,[R6, #+4]
        MOV      R2,#+0
        LSR      R0,R0,#+17
        AND      R0,R0,#0x3
        CMP      R0,#+3
        MOV      R3,#+1073741824
        ORREQ    R3,R3,#0x280000
        ORRNE    R3,R3,#0x620000
        MOV      R0,#+0
        _BLF     __dMul,??__dMul??rA
        MOV      R6,R0
        MOV      R7,R1
        MOV      R0,R8
        _BLF     __longToDouble,??__longToDouble??rA
        MOV      R2,R4
        MOV      R3,R5
        _BLF     __dMul,??__dMul??rA
        MOV      R2,R6
        MOV      R3,R7
        _BLF     __dDiv,??__dDiv??rA
        _BLF     __doubleToLong,??__doubleToLong??rA
        ADD      SP,SP,#+384
        CFI CFA R13+24
        POP      {R4-R8,PC}
        CFI CFA R13+408
//  301   }
//  302   else
//  303   {
//  304     int table[2][3][16] =        {
//  305       { // MPEG 2 & 2.5
//  306         {0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96,112,128,144,160,0}, // Layer III
//  307         {0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96,112,128,144,160,0}, // Layer II
//  308         {0, 32, 48, 56, 64, 80, 96,112,128,144,160,176,192,224,256,0}  // Layer I
//  309       },
//  310       { // MPEG 1
//  311         {0, 32, 40, 48, 56, 64, 80, 96,112,128,160,192,224,256,320,0}, // Layer III
//  312         {0, 32, 48, 56, 64, 80, 96,112,128,160,192,224,256,320,384,0}, // Layer II
//  313         {0, 32, 64, 96,128,160,192,224,256,288,320,352,384,416,448,0}  // Layer I
//  314       }
//  315     };
??getBitrate_1:
        LDR      R1,??getBitrate_2  ;; `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`
        MOV      R0,SP
        MOV      R3,#+384
??getBitrate_3:
        SUBS     R3,R3,#+4
        LDR      R2,[R1, R3]
        STR      R2,[R0, R3]
        BNE      ??getBitrate_3
//  316     
//  317     return table[getVersionIndex() & 1][getLayerIndex()-1][getBitrateIndex()];
        LDR      R0,[R6, #+4]
        MOV      R1,#+15
        AND      R1,R1,R0, LSR #+12
        MOV      R2,#+3
        AND      R2,R2,R0, LSR #+17
        MOV      R3,#+1
        AND      R0,R3,R0, LSR #+19
        MOV      R3,#+192
        MOV      R6,SP
        MLA      R0,R3,R0,R6
        ADD      R0,R0,R2, LSL #+6
        ADD      R0,R0,R1, LSL #+2
        LDR      R0,[R0, #-64]
        ADD      SP,SP,#+384
        CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
        DATA
??getBitrate_2:
        DC32     `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`
        CFI EndBlock cfiBlock45
//  318   }
//  319 };

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable22:
        DC32     0x408f4000

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock46 Using cfiCommon0
        CFI NoFunction
        THUMB
??getMode??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock46
        REQUIRE ??getMode
//  320 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock47 Using cfiCommon1
        CFI Function ??getMode
        ARM
//  321 int getMode() 
//  322 {
//  323   switch(getModeIndex()) 
??getMode:
        LDR      R0,??DataTable23  ;; lngFileSize + 4
        MOV      R1,#+3
        LDR      R0,[R0, #+0]
        AND      R0,R1,R0, LSR #+6
        SUBS     R0,R0,#+1
        BEQ      ??getMode_1
        SUBS     R0,R0,#+1
        BEQ      ??getMode_2
        SUBS     R0,R0,#+1
        BEQ      ??getMode_3
//  324   {
//  325   default:
//  326     return 0;//"Stereo"
        MOV      R0,#+0
        BX       LR
//  327   case 1:
//  328     return 1;//"Joint Stereo"
??getMode_1:
        MOV      R0,#+1
        BX       LR
//  329   case 2:
//  330     return 2;//"Dual Channel"
??getMode_2:
        MOV      R0,#+2
        BX       LR
//  331   case 3:
//  332     return 3;//"Single Channel"
??getMode_3:
        MOV      R0,#+3
        BX       LR               ;; return
        CFI EndBlock cfiBlock47
//  333   }
//  334 };

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable23:
        DC32     lngFileSize + 4

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock48 Using cfiCommon0
        CFI NoFunction
        THUMB
??getLengthInSeconds??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock48
        REQUIRE ??getLengthInSeconds
//  335 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock49 Using cfiCommon1
        CFI Function ??getLengthInSeconds
        ARM
//  336 int getLengthInSeconds() 
//  337 {
//  338   int intKiloBitFileSize = (int)((8 * lngFileSize) / 1000);
??getLengthInSeconds:
        LDR      R0,??DataTable24  ;; lngFileSize
        LDR      R1,??getLengthInSeconds_1  ;; 0x10624dd3
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        LDR      R0,[R0, #+0]
        LSL      R0,R0,#+3
        SMULL    R2,R3,R1,R0
        ASR      R3,R3,#+6
        ADD      R4,R3,R0, LSR #+31
//  339   return (int)(intKiloBitFileSize/getBitrate());
        BL       ??getBitrate
        MOV      R1,R0
        MOV      R0,R4
        _BLF     ??div32_a,??rA??div32_a
        MOV      R0,R1
        POP      {R4,PC}          ;; return
        DATA
??getLengthInSeconds_1:
        DC32     0x10624dd3
        CFI EndBlock cfiBlock49
//  340 };

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable24:
        DC32     lngFileSize

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock50 Using cfiCommon1
        CFI NoFunction
        ARM
`??operator new[]??rA`:
        LDR      R12,??Subroutine25_0  ;; `??operator new[]`
        BX       R12
        DATA
??Subroutine25_0:
        DC32     `??operator new[]`
        CFI EndBlock cfiBlock50

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock51 Using cfiCommon1
        CFI NoFunction
        ARM
`??operator delete??rA`:
        LDR      R12,??Subroutine26_0  ;; `??operator delete`
        BX       R12
        DATA
??Subroutine26_0:
        DC32     `??operator delete`
        CFI EndBlock cfiBlock51

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock52 Using cfiCommon1
        CFI NoFunction
        ARM
??__longToFloat??rA:
        LDR      R3,??Subroutine27_0  ;; __longToFloat
        BX       R3
        DATA
??Subroutine27_0:
        DC32     __longToFloat
        CFI EndBlock cfiBlock52

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock53 Using cfiCommon1
        CFI NoFunction
        ARM
??__floatToDouble??rA:
        LDR      R3,??Subroutine28_0  ;; __floatToDouble
        BX       R3
        DATA
??Subroutine28_0:
        DC32     __floatToDouble
        CFI EndBlock cfiBlock53

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock54 Using cfiCommon1
        CFI NoFunction
        ARM
??__dMul??rA:
        LDR      R12,??Subroutine29_0  ;; __dMul
        BX       R12
        DATA
??Subroutine29_0:
        DC32     __dMul
        CFI EndBlock cfiBlock54

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock55 Using cfiCommon1
        CFI NoFunction
        ARM
??__dDiv??rA:
        LDR      R12,??Subroutine30_0  ;; __dDiv
        BX       R12
        DATA
??Subroutine30_0:
        DC32     __dDiv
        CFI EndBlock cfiBlock55

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock56 Using cfiCommon1
        CFI NoFunction
        ARM
??__longToDouble??rA:
        LDR      R3,??Subroutine31_0  ;; __longToDouble
        BX       R3
        DATA
??Subroutine31_0:
        DC32     __longToDouble
        CFI EndBlock cfiBlock56

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock57 Using cfiCommon1
        CFI NoFunction
        ARM
??__doubleToLong??rA:
        LDR      R3,??Subroutine32_0  ;; __doubleToLong
        BX       R3
        DATA
??Subroutine32_0:
        DC32     __doubleToLong
        CFI EndBlock cfiBlock57

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock58 Using cfiCommon1
        CFI NoFunction
        ARM
??rA??div32_a:
        LDR      R12,??Subroutine33_0  ;; ??div32_a
        MOV      PC,R12
        DATA
??Subroutine33_0:
        DC32     ??div32_a
        CFI EndBlock cfiBlock58

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant {(2.5), (0.0), (2.0), (1.0)}>`:
        DATA
        DC32 0H, 40040000H, 0H, 0H, 0H, 40000000H, 0H, 3FF00000H

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`:
        DATA
        DC32 32000, 16000, 8000
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC32 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC32 22050, 24000, 16000
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC32 44100, 48000, 32000
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`:
        DATA
        DC32 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0, 0
        DC32 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0, 0
        DC32 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 0
        DC32 0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
        DC32 0, 0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
        DC32 384, 0, 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384
        DC32 416, 448, 0

        END
//  341 
// 
// 2 116 bytes in segment CODE
//   516 bytes in segment DATA_C
//    13 bytes in segment DATA_Z
//    12 bytes in segment INITTAB
// 
// 1 908 bytes of CODE  memory (+ 220 bytes shared)
//   516 bytes of CONST memory
//    13 bytes of DATA  memory
//
//Errors: none
//Warnings: none
