//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   10/Jun/2013  23:11:06 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\DecoderInit.cpp                                   /
//    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\DecoderInit.cpp -D NDEBUG -D ENG -D OLDFUNCTIONS  /
//                       -lC Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDi /
//                       splay\Release_ENG\List\ -lA                         /
//                       Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\Release_ENG\List\ -o Z:\home\perk11\www\perk11.in /
//                       fo\svn\SE\WalkmanDisplay\Release_ENG\Obj\ -s9       /
//                       --cpu_mode arm --endian little --cpu ARM926EJ-S     /
//                       --stack_align 4 --interwork -e --enable_multibytes  /
//                       --fpu None --eec++ --dlib_config                    /
//                       Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8n.h -I        /
//                       Z:\home\perk11\IAR2\arm\INC\ --inline_threshold=2   /
//    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDispla /
//                       y\Release_ENG\List\DecoderInit.s79                  /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME DecoderInit

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        PUBWEAK `?*?DATA_ID`
        PUBLIC ??Cover_Free
        FUNCTION ??Cover_Free,0203H
        LOCFRAME CSTACK, 12, STACK
        MULTWEAK ??Cover_Free??rT
        PUBLIC ??GetCover
        FUNCTION ??GetCover,0203H
        LOCFRAME CSTACK, 68, STACK
        MULTWEAK ??GetCover??rT
        PUBLIC ??GetType_str
        FUNCTION ??GetType_str,0203H
        MULTWEAK ??GetType_str??rT
        MULTWEAK ??ReadMP3Information??rA
        PUBLIC ??decoder_Init
        FUNCTION ??decoder_Init,0203H
        LOCFRAME CSTACK, 48, STACK
        MULTWEAK ??decoder_Init??rT
        PUBLIC ??freemeta
        FUNCTION ??freemeta,0203H
        LOCFRAME CSTACK, 8, STACK
        MULTWEAK ??freemeta??rT
        PUBLIC ??getFormat
        FUNCTION ??getFormat,0203H
        LOCFRAME CSTACK, 12, STACK
        MULTWEAK ??getFormat??rT
        PUBLIC ??metadata_Get
        FUNCTION ??metadata_Get,0203H
        LOCFRAME CSTACK, 52, STACK
        MULTWEAK ??metadata_Get??rT
        MULTWEAK ??metadata_Read??rA
        MULTWEAK ??metadata_reset??rA
        MULTWEAK `??operator new[]??rA`
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC nowmusic
        PUBLIC types
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        





??Cover_Free??rT    SYMBOL "??rT", ??Cover_Free

??GetCover??rT      SYMBOL "??rT", ??GetCover

??GetType_str??rT   SYMBOL "??rT", ??GetType_str
??ReadMP3Information??rA SYMBOL "??rA", ??ReadMP3Information

??decoder_Init??rT  SYMBOL "??rT", ??decoder_Init

??freemeta??rT      SYMBOL "??rT", ??freemeta

??getFormat??rT     SYMBOL "??rT", ??getFormat

??metadata_Get??rT  SYMBOL "??rT", ??metadata_Get
??metadata_Read??rA SYMBOL "??rA", ??metadata_Read
??metadata_reset??rA SYMBOL "??rA", ??metadata_reset
`??operator new[]??rA` SYMBOL "??rA", `??operator new[]`

        EXTERN ??ReadMP3Information
        FUNCTION ??ReadMP3Information,0202H
        EXTERN ??metadata_Read
        FUNCTION ??metadata_Read,0202H
        EXTERN ??metadata_reset
        FUNCTION ??metadata_reset,0202H
        EXTERN `??operator new[]`
        FUNCTION `??operator new[]`,0202H
        EXTERN use_albumpng

// Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay\DecoderInit.cpp
//    1 #include "..\deleaker\mem2.h"
//    2 #include "..\include\Lib_Clara.h"
//    3 #include "..\include\dir.h"
//    4 #include "header\wdisplay.h"
//    5 #include "header\decoder.h"
//    6 #include "header\config_data.h"
//    7 
//    8 #define TAG_TITLE 1
//    9 #define TAG_ALBUM 2
//   10 #define TAG_ARTIST 0
//   11 #define TAG_YEAR 3
//   12 #define TAG_GENRE 4
//   13 
//   14 wchar_t GetBitmap(wchar_t *path, wchar_t *name);

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   15 MUSIC nowmusic;
nowmusic:
        DS8 10280
//   16 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   17 wchar_t *types[4]={
types:
        DS8 16
        REQUIRE `?<Initializer for types>`

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??GetType_str??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE ??GetType_str
//   18   L"jpg",
//   19   L"gif",
//   20   L"png",
//   21   L"bmp"
//   22 };
//   23 
//   24 #pragma optimize = z 9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function ??GetType_str
        ARM
//   25 wchar_t * GetType_str(int cover_type)
//   26 {
//   27   if (cover_type<=3)
??GetType_str:
        CMP      R0,#+4
//   28   {
//   29     return types[cover_type];
        LDRLT    R1,??GetType_str_1  ;; types
        LDRLT    R0,[R1, +R0, LSL #+2]
        BXLT     LR
//   30   }
//   31   return 0;
        MOV      R0,#+0
        BX       LR               ;; return
        DATA
??GetType_str_1:
        DC32     types
        CFI EndBlock cfiBlock1
//   32 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??GetCover??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE ??GetCover
//   33 
//   34 #pragma optimize = z 9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function ??GetCover
        ARM
//   35 wchar_t GetCover(void *TagStructure, wchar_t *path, wchar_t *name, METADATA *meta)
//   36 {
??GetCover:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        SUB      SP,SP,#+40
        CFI CFA R13+64
        MOV      R4,R1
        MOV      R7,R2
        MOV      R1,#+4
        ORR      R1,R1,#0x2800
        ADD      R5,R1,R3
        MOV      R6,#+255
        ORR      R6,R6,#0xFF00
        STRH     R6,[R5, #+0]
//   37   char cover_type;
//   38   int size;
//   39   int cover_offset;
//   40   meta->ImageID=NOIMAGE;
//   41   if (MetaData_Desc_GetCoverInfo(TagStructure,&cover_type,&size,&cover_offset)!=0)
        ADD      R3,SP,#+4
        MOV      R2,SP
        ADD      R1,SP,#+8
        SWI      +769
        CMP      R0,#+0
        BEQ      ??GetCover_1
//   42   {
//   43     if (cover_offset>0 && size>0)
        LDR      R0,[SP, #+4]
        CMP      R0,#+1
        LDRGE    R0,[SP, #+0]
        CMPGE    R0,#+1
        BLT      ??GetCover_1
//   44     {
//   45       int f;
//   46       if (f=_fopen(path,name,FSX_O_RDONLY,FSX_S_IREAD|FSX_S_IWRITE,0x0)>=0)
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+68
        MOV      R3,#+384
        MOV      R2,#+1
        MOV      R1,R7
        MOV      R0,R4
        SWI      +278
        CMP      R0,#+0
        ADD      SP,SP,#+4
        CFI CFA R13+64
        BMI      ??GetCover_2
//   47       {
//   48         if (lseek(f,cover_offset,0)>=0)
        LDR      R1,[SP, #+4]
        MOV      R7,#+1
        MOV      R2,#+0
        MOV      R0,#+1
        SWI      +374
        CMP      R0,#+0
        BMI      ??GetCover_3
//   49         {
//   50           char * my_buf=new char[size+1];
        LDR      R0,[SP, #+0]
        ADD      R0,R0,#+1
        _BLF     `??operator new[]`,`??operator new[]??rA`
//   51           fread(f,my_buf,size);
        LDR      R2,[SP, #+0]
        MOV      R8,R0
        MOV      R1,R8
        MOV      R0,#+1
        SWI      +280
//   52           
//   53           ImageID_GetIndirect(my_buf,size,0,GetType_str(cover_type),&meta->ImageID);
        LDRB     R0,[SP, #+8]
        BL       ??GetType_str
        MOV      R1,R5
        PUSH     {R1}
        CFI CFA R13+68
        MOV      R3,R0
        MOV      R2,#+0
        LDR      R1,[SP, #+4]
        MOV      R0,R8
        SWI      +770
        ADD      SP,SP,#+4
        CFI CFA R13+64
//   54         }
//   55       }
//   56       fclose(f);
??GetCover_3:
        MOV      R0,R7
        SWI      +279
//   57     }
//   58   }
//   59 
//   60   if (meta->ImageID==NOIMAGE && use_albumpng==true)
??GetCover_1:
        LDRH     R0,[R5, #+0]
        CMP      R0,R6
        LDREQ    R0,??GetCover_4  ;; use_albumpng
        LDREQ    R0,[R0, #+0]
        CMPEQ    R0,#+1
        BNE      ??GetCover_5
//   61   {
//   62     FSTAT fst;
//   63     if (fstat(path,L"album.png",&fst)==0)
        LDR      R6,??GetCover_4+0x4  ;; `?<Constant L"\\x61\\x6c\\x62\\x75\\x6d\\x2e\\x70\\x6e\\`
        ADD      R2,SP,#+12
        MOV      R1,R6
        MOV      R0,R4
        SWI      +284
        CMP      R0,#+0
        BNE      ??GetCover_6
//   64     {
//   65       ImageID_Get(path,L"album.png",&meta->ImageID);
        MOV      R2,R5
        MOV      R1,R6
        B        ??GetCover_7
//   66     }
??GetCover_2:
        MOV      R7,#+0
        B        ??GetCover_3
//   67     else if (fstat(path,L"cover.png",&fst)==0)
??GetCover_6:
        ADD      R2,SP,#+12
        ADD      R1,R6,#+20
        MOV      R0,R4
        SWI      +284
        CMP      R0,#+0
        BNE      ??GetCover_5
//   68     {
//   69       ImageID_Get(path,L"cover.png",&meta->ImageID);
        MOV      R2,R5
        ADD      R1,R6,#+20
??GetCover_7:
        MOV      R0,R4
        SWI      +716
//   70     }
//   71   }
//   72   return meta->ImageID;
??GetCover_5:
        LDRH     R0,[R5, #+0]
        ADD      SP,SP,#+40
        CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
        DATA
??GetCover_4:
        DC32     use_albumpng
        DC32     `?<Constant L"\\x61\\x6c\\x62\\x75\\x6d\\x2e\\x70\\x6e\\`
        CFI EndBlock cfiBlock3
//   73 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??metadata_Get??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE ??metadata_Get
//   74 
//   75 void metadata_Read(wchar_t *path, wchar_t *name, METADATA *mt, TAG_REQUEST tr);
//   76 
//   77 #pragma optimize = z 9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function ??metadata_Get
        ARM
//   78 void metadata_Get(wchar_t *path, wchar_t *name, METADATA *meta, int format)
//   79 {
??metadata_Get:
        PUSH     {R0,R1,R4-R8,R10,R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+40
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//   80   metadata_reset(meta);
        MOV      R0,R6
        _BLF     ??metadata_reset,??metadata_reset??rA
//   81   if (wstrlen(name)>5)
        MOV      R0,R5
        SWI      +343
        CMP      R0,#+6
        BLT      ??metadata_Get_1
//   82   {
//   83     wstrncpy(meta->Title,name, wstrlen(name)-4);
        MOV      R0,R5
        SWI      +343
        SUB      R2,R0,#+4
        MOV      R1,R5
        MOV      R0,R6
        SWI      +339
        B        ??metadata_Get_2
//   84   }
//   85   else
//   86   {
//   87     wstrcpy(meta->Title,name);
??metadata_Get_1:
        MOV      R1,R5
        MOV      R0,R6
        SWI      +338
//   88   }
//   89   TAG_REQUEST tr;
//   90   tr.album=1;
??metadata_Get_2:
        MOV      R0,#+1
        STRB     R0,[SP, #+2]
//   91   tr.title=1;
        STRB     R0,[SP, #+0]
//   92   tr.artist=1;
        STRB     R0,[SP, #+1]
//   93   tr.genre=1;
        STRB     R0,[SP, #+4]
//   94   tr.year=1;
        STRB     R0,[SP, #+3]
//   95   void *TagStructure=0;
//   96   if (TagStructure=MetaData_Desc_Create(path,name))
        MOV      R1,R5
        MOV      R0,R4
        SWI      +751
        MOVS     R10,R0
        BEQ      ??metadata_Get_3
        ADD      R8,R6,#+10240
        MOV      R3,R6
        MOV      R2,R5
        MOV      R1,R4
//   97   {
//   98     meta->ImageID=GetCover(TagStructure, path, name, meta);
        BL       ??GetCover
        STRH     R0,[R8, #+4]
//   99     
//  100     wchar_t *tag=0;
//  101 
//  102     if (tag=MetaData_Desc_GetTags(TagStructure, TAG_TITLE))
        MOV      R1,#+1
        MOV      R0,R10
        SWI      +753
        MOVS     R1,R0
//  103     {
//  104       if (tag[0]!=0)
        LDRHNE   R0,[R1, #+0]
        CMPNE    R0,#+0
        BEQ      ??metadata_Get_4
//  105       {
//  106         wstrcpy(meta->Title,tag);
        MOV      R0,R6
        SWI      +338
//  107         tr.title=0;
        MOV      R1,#+0
        STRB     R1,[SP, #+0]
//  108       }
//  109     }
//  110     
//  111     tag=0;
//  112     if (tag=MetaData_Desc_GetTags(TagStructure, TAG_ALBUM))
??metadata_Get_4:
        MOV      R1,#+2
        MOV      R0,R10
        SWI      +753
        CMP      R0,#+0
        BEQ      ??metadata_Get_5
//  113     {
//  114       if (tag[0]!=0)
        LDRH     R1,[R0, #+0]
        CMP      R1,#+0
        BEQ      ??metadata_Get_6
//  115       {
//  116         wstrcpy(meta->Album,tag);
        MOV      R1,R0
        ADD      R0,R6,#+2048
        SWI      +338
//  117         tr.album=0;
        MOV      R1,#+0
        STRB     R1,[SP, #+2]
//  118       }
//  119     }
//  120     
//  121     tag=0;
//  122     if (tag=MetaData_Desc_GetTags(TagStructure, TAG_ARTIST))
??metadata_Get_5:
        MOV      R1,#+0
??metadata_Get_6:
        MOV      R0,R10
        SWI      +753
        CMP      R0,#+0
//  123     {
//  124       if (tag[0]!=0)
        LDRHNE   R1,[R0, #+0]
        CMPNE    R1,#+0
        BEQ      ??metadata_Get_7
//  125       {
//  126         wstrcpy(meta->Artist,tag);
        MOV      R1,R0
        ADD      R0,R6,#+4096
        SWI      +338
//  127         tr.artist=0;
        MOV      R1,#+0
        STRB     R1,[SP, #+1]
//  128       }
//  129     }
//  130     
//  131     tag=0;
//  132     if (tag=MetaData_Desc_GetTags(TagStructure, TAG_YEAR))
??metadata_Get_7:
        MOV      R1,#+3
        MOV      R0,R10
        SWI      +753
        MOVS     R11,R0
//  133     {
//  134       if (tag[0]!=0)
        LDRHNE   R0,[R11, #+0]
        CMPNE    R0,#+0
        BEQ      ??metadata_Get_8
//  135       {
//  136         wstrcpy(meta->Year,tag);
        MOV      R1,R11
        ADD      R0,R6,#+6144
        SWI      +338
//  137         if (wstrlen(tag)>1)
        MOV      R0,R11
        SWI      +343
        CMP      R0,#+2
//  138         {
//  139           tr.year=0;
        MOVGE    R1,#+0
        STRBGE   R1,[SP, #+3]
//  140         }
//  141       }
//  142     }
//  143     
//  144     tag=0;
//  145     if (tag=MetaData_Desc_GetTags(TagStructure, TAG_GENRE))
??metadata_Get_8:
        MOV      R1,#+4
        MOV      R0,R10
        SWI      +753
        CMP      R0,#+0
        BEQ      ??metadata_Get_9
//  146     {
//  147       if (tag[0]!=0)
        LDRH     R1,[R0, #+0]
        CMP      R1,#+0
        BEQ      ??metadata_Get_10
//  148       {
//  149         wstrcpy(meta->Genre,tag);
        MOV      R1,R0
        ADD      R0,R6,#+8192
        SWI      +338
//  150         tr.genre=0;
        MOV      R1,#+0
        STRB     R1,[SP, #+4]
//  151       }
//  152     }
//  153     
//  154     if (MetaData_Desc_GetTrackNum(TagStructure, 0)!=-1)
??metadata_Get_9:
        MOV      R1,#+0
??metadata_Get_10:
        MOV      R0,R10
        SWI      +754
        CMN      R0,#+1
        BEQ      ??metadata_Get_11
//  155     {
//  156       meta->TrackNum=MetaData_Desc_GetTrackNum(TagStructure, 0);
        MOV      R1,#+0
        MOV      R0,R10
        SWI      +754
        B        ??metadata_Get_12
//  157     }
//  158     else
//  159     {
//  160       meta->TrackNum=0;
??metadata_Get_11:
        MOV      R0,#+0
??metadata_Get_12:
        STR      R0,[R8, #+0]
//  161     }
//  162     MetaData_Desc_Destroy(TagStructure);
        MOV      R0,R10
        SWI      +752
//  163   }
//  164   if ((tr.title || tr.album || tr.artist || tr.year || tr.genre) && format==FORMAT_MP3)
??metadata_Get_3:
        LDRB     R0,[SP, #+0]
        LDRB     R1,[SP, #+2]
        ORR      R0,R1,R0
        LDRB     R1,[SP, #+1]
        ORR      R0,R1,R0
        LDRB     R1,[SP, #+3]
        ORR      R0,R1,R0
        LDRB     R1,[SP, #+4]
        ORRS     R0,R1,R0
        POPEQ    {R0,R1,R4-R8,R10,R11,PC}
        CMP      R7,#+1
        POPNE    {R0,R1,R4-R8,R10,R11,PC}
//  165   {
//  166     metadata_Read(path, name, meta, tr);
        MOV      R0,SP
        SUB      SP,SP,#+8
        CFI CFA R13+48
        LDR      R1,[R0, #0]
        MOV      R2,SP
        STR      R1,[R2, #+0]
        LDR      R1,[R0, #+4]
        MOV      R0,R4
        STR      R1,[R2, #+4]
        POP      {R3}
        CFI CFA R13+44
        MOV      R2,R6
        MOV      R1,R5
        _BLF     ??metadata_Read,??metadata_Read??rA
        ADD      SP,SP,#+4
        CFI CFA R13+40
//  167   }
//  168 };
        POP      {R0,R1,R4-R8,R10,R11,PC}
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??Cover_Free??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE ??Cover_Free
//  169 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function ??Cover_Free
        ARM
//  170 void Cover_Free()
//  171 {
??Cover_Free:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  172   if(nowmusic.meta.ImageID!=NOIMAGE)
        LDR      R4,??Cover_Free_1  ;; nowmusic + 10272
        MOV      R5,#+255
        LDRH     R0,[R4, #+0]
        ORR      R5,R5,#0xFF00
        CMP      R0,R5
        BEQ      ??Cover_Free_2
//  173   {
//  174     ImageID_Free(nowmusic.meta.ImageID);
        SWI      +717
//  175   }
//  176   nowmusic.meta.ImageID=NOIMAGE;
??Cover_Free_2:
        STRH     R5,[R4, #+0]
//  177 };
        POP      {R4,R5,PC}       ;; return
        DATA
??Cover_Free_1:
        DC32     nowmusic + 10272
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??getFormat??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE ??getFormat
//  178 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function ??getFormat
        ARM
//  179 int getFormat(wchar_t *name)
//  180 {
??getFormat:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  181   if (name)
        LDR      R4,??getFormat_1  ;; `?<Constant "\\nWalkmanDisplay: getF...">`
        CMP      R0,#+0
        BEQ      ??getFormat_2
//  182   {
//  183     wchar_t *ext=wstrrchr(name,L'.');
        MOV      R1,#+46
        SWI      +430
        MOVS     R5,R0
//  184     if (ext)
        BEQ      ??getFormat_2
//  185     {
//  186       ext++;
//  187       if (wstrlen(ext)>1)
        ADD      R5,R0,#+2
        MOV      R0,R5
        SWI      +343
        CMP      R0,#+2
        BLT      ??getFormat_2
//  188       {
//  189         debug_printf("\nWalkmanDisplay: getFormat: %ls extension\n", ext);
        MOV      R1,R5
        MOV      R0,R4
        SWI      +433
//  190         if (wstrcmpi(ext,L"mp3")==0)
        ADD      R1,R4,#+60
        MOV      R0,R5
        SWI      +671
        CMP      R0,#+0
//  191         {
//  192           return FORMAT_MP3;
        MOVEQ    R0,#+1
        POPEQ    {R4,R5,PC}
//  193         }
//  194         else if (wstrcmpi(ext,L"m4a")==0)
        ADD      R1,R4,#+52
        MOV      R0,R5
        SWI      +671
        CMP      R0,#+0
//  195         {
//  196           return FORMAT_M4A;
        MOVEQ    R0,#+2
        POPEQ    {R4,R5,PC}
//  197         }
//  198         else if (wstrcmpi(ext,L"wma")==0)
        ADD      R1,R4,#+44
        MOV      R0,R5
        SWI      +671
        CMP      R0,#+0
//  199         {
//  200           return FORMAT_WMA;
        MOVEQ    R0,#+3
        POPEQ    {R4,R5,PC}
//  201         }
//  202       }
//  203     }
//  204   }
//  205   debug_printf("\nWalkmanDisplay: getFormat: unknown extension or name is empty\n");
??getFormat_2:
        ADD      R0,R4,#+68
        SWI      +433
//  206   return FORMAT_OTHER;
        MOV      R0,#+4
        POP      {R4,R5,PC}       ;; return
        DATA
??getFormat_1:
        DC32     `?<Constant "\\nWalkmanDisplay: getF...">`
        CFI EndBlock cfiBlock9
//  207 };

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??freemeta??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE ??freemeta
//  208 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function ??freemeta
        ARM
//  209 void freemeta(MUSIC *music)
//  210 {
??freemeta:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  211   memset(&music->meta,0,sizeof(METADATA));
        MOV      R2,#+8
        ORR      R2,R2,#0x2800
        MOV      R4,R0
        MOV      R1,#+0
        ADD      R0,R4,#+28
        SWI      +274
//  212   music->meta.ImageID=NOIMAGE;
        MOV      R0,#+32
        ORR      R0,R0,#0x2800
        MOV      R1,#+255
        ORR      R1,R1,#0xFF00
        STRH     R1,[R0, +R4]
//  213   memset(&music->hdr,0,sizeof(HEADER_INFO));
        MOV      R2,#+28
        MOV      R1,#+0
        MOV      R0,R4
        SWI      +274
//  214 };
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??decoder_Init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE ??decoder_Init
//  215 
//  216 #pragma optimize = s 9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function ??decoder_Init
        ARM
//  217 void decoder_Init(wchar_t *path, wchar_t *name)
//  218 {
??decoder_Init:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  219   Cover_Free();
//  220   freemeta(&nowmusic);
        LDR      R4,??decoder_Init_1  ;; nowmusic
        SUB      SP,SP,#+28
        CFI CFA R13+48
        MOV      R5,R0
        MOV      R6,R1
        BL       ??Cover_Free
        MOV      R0,R4
        BL       ??freemeta
//  221   int format=getFormat(name);
        MOV      R0,R6
        BL       ??getFormat
        MOV      R7,R0
//  222   nowmusic.format=format;
        MOV      R0,#+36
        ORR      R0,R0,#0x2800
        STR      R7,[R0, +R4]
//  223   metadata_Get(path, name, &nowmusic.meta, format);
        MOV      R3,R7
        ADD      R2,R4,#+28
        MOV      R1,R6
        MOV      R0,R5
        BL       ??metadata_Get
//  224   if (format==FORMAT_MP3 || format==FORMAT_OTHER)
        CMP      R7,#+1
        CMPNE    R7,#+4
        BNE      ??decoder_Init_2
//  225   {
//  226     nowmusic.hdr=ReadMP3Information(path, name);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,SP
        _BLF     ??ReadMP3Information,??ReadMP3Information??rA
        MOV      R0,SP
        LDM      R0,{R1-R3,R5-R7,R12}
        STM      R4,{R1-R3,R5-R7,R12}
//  227   }
//  228 };
??decoder_Init_2:
        ADD      SP,SP,#+28       ;; stack cleaning
        CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        DATA
??decoder_Init_1:
        DC32     nowmusic
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon1
        CFI NoFunction
        ARM
`??operator new[]??rA`:
        LDR      R12,??Subroutine7_0  ;; `??operator new[]`
        BX       R12
        DATA
??Subroutine7_0:
        DC32     `??operator new[]`
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI NoFunction
        ARM
??metadata_reset??rA:
        LDR      R12,??Subroutine8_0  ;; ??metadata_reset
        BX       R12
        DATA
??Subroutine8_0:
        DC32     ??metadata_reset
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon1
        CFI NoFunction
        ARM
??metadata_Read??rA:
        LDR      R12,??Subroutine9_0  ;; ??metadata_Read
        BX       R12
        DATA
??Subroutine9_0:
        DC32     ??metadata_Read
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI NoFunction
        ARM
??ReadMP3Information??rA:
        LDR      R12,??Subroutine10_0  ;; ??ReadMP3Information
        BX       R12
        DATA
??Subroutine10_0:
        DC32     ??ReadMP3Information
        CFI EndBlock cfiBlock17

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for types>`:
        DATA
        DC32 `?<Constant L"\\x6a\\x70\\x67">`, `?<Constant L"\\x67\\x69\\x66">`
        DC32 `?<Constant L"\\x70\\x6e\\x67">`, `?<Constant L"\\x62\\x6d\\x70">`

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant L"\\x6a\\x70\\x67">`:
        DATA
        DC8 6AH, 0, 70H, 0, 67H, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant L"\\x67\\x69\\x66">`:
        DATA
        DC8 67H, 0, 69H, 0, 66H, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant L"\\x70\\x6e\\x67">`:
        DATA
        DC8 70H, 0, 6EH, 0, 67H, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant L"\\x62\\x6d\\x70">`:
        DATA
        DC8 62H, 0, 6DH, 0, 70H, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant L"\\x61\\x6c\\x62\\x75\\x6d\\x2e\\x70\\x6e\\`:
        DATA
        DC8 61H, 0, 6CH, 0, 62H, 0, 75H, 0
        DC8 6DH, 0, 2EH, 0, 70H, 0, 6EH, 0
        DC8 67H, 0, 0, 0
        DC8 63H, 0, 6FH, 0, 76H, 0, 65H, 0
        DC8 72H, 0, 2EH, 0, 70H, 0, 6EH, 0
        DC8 67H, 0, 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "\\nWalkmanDisplay: getF...">`:
        DATA
        DC8 "\012WalkmanDisplay: getFormat: %ls extension\012"
        DC8 0
        DC8 77H, 0, 6DH, 0, 61H, 0, 0, 0
        DC8 6DH, 0, 34H, 0, 61H, 0, 0, 0
        DC8 6DH, 0, 70H, 0, 33H, 0, 0, 0
        DC8 0AH, 57H, 61H, 6CH, 6BH, 6DH, 61H, 6EH
        DC8 44H, 69H, 73H, 70H, 6CH, 61H, 79H, 3AH
        DC8 20H, 67H, 65H, 74H, 46H, 6FH, 72H, 6DH
        DC8 61H, 74H, 3AH, 20H, 75H, 6EH, 6BH, 6EH
        DC8 6FH, 77H, 6EH, 20H, 65H, 78H, 74H, 65H
        DC8 6EH, 73H, 69H, 6FH, 6EH, 20H, 6FH, 72H
        DC8 20H, 6EH, 61H, 6DH, 65H, 20H, 69H, 73H
        DC8 20H, 65H, 6DH, 70H, 74H, 79H, 0AH, 0

        END
//  229 
// 
//  1 428 bytes in segment CODE
//    204 bytes in segment DATA_C
//     16 bytes in segment DATA_I
//     16 bytes in segment DATA_ID
// 10 280 bytes in segment DATA_Z
//     24 bytes in segment INITTAB
// 
//  1 352 bytes of CODE  memory (+ 100 bytes shared)
//    220 bytes of CONST memory
// 10 296 bytes of DATA  memory
//
//Errors: none
//Warnings: none
