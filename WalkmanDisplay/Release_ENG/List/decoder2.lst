##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Jun/2013  23:11:19 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay #
#                       \decoder2.cpp                                        #
#    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay #
#                       \decoder2.cpp -D NDEBUG -D ENG -D OLDFUNCTIONS -lC   #
#                       Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay #
#                       \Release_ENG\List\ -lA Z:\home\perk11\www\perk11.inf #
#                       o\svn\SE\WalkmanDisplay\Release_ENG\List\ -o         #
#                       Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay #
#                       \Release_ENG\Obj\ -s9 --cpu_mode arm --endian        #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --enable_multibytes --fpu None --eec++            #
#                       --dlib_config Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8 #
#                       n.h -I Z:\home\perk11\IAR2\arm\INC\                  #
#                       --inline_threshold=2                                 #
#    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay #
#                       \Release_ENG\List\decoder2.lst                       #
#    Object file     =  Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay #
#                       \Release_ENG\Obj\decoder2.r79                        #
#                                                                            #
#                                                                            #
##############################################################################

Z:\home\perk11\www\perk11.info\svn\SE\WalkmanDisplay\decoder2.cpp
      1          #include "..\deleaker\mem2.h"
      2          #include "..\include\Lib_Clara.h" 
      3          #include "..\include\Dir.h" 
      4          #include "header\wdisplay.h"
      5          
      6          // Модуль получения инфы из мп3
      7          // Оригинальный код Robert Wlodarczyk'а (http://www.devhood.com/tutorials/tutorial_details.aspx?tutorial_id=79)
      8          // Адаптация под SE от UltraShot'а
      9          
     10          typedef unsigned long int ulong;
     11          typedef char byte;
     12          
     13          #define INDEX(x) x/8
     14          #define SHIFT(x) x%8
     15          #define GETBIT(v,x) ((v[INDEX(x)] << SHIFT(x)) & 0x80)>>7
     16          

   \                                 In segment CODE, align 4, keep-with-next
     17          int synchsafeToNormal(char tagSize[4])
     18          {
   \                     ??synchsafeToNormal:
   \   00000000   30002DE9           PUSH     {R4,R5}
     19            int synchsafe, sizeloc, size, power, x;
     20            
     21            size=sizeloc=0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0010A0E3           MOV      R1,#+0
     22            for(synchsafe=31;synchsafe>=0;synchsafe--)
   \   0000000C   1F30A0E3           MOV      R3,#+31
     23            {
     24              if(GETBIT(tagSize, synchsafe))
   \                     ??synchsafeToNormal_1:
   \   00000010   4341A0E1           ASR      R4,R3,#+2
   \   00000014   A44E83E0           ADD      R4,R3,R4, LSR #+29
   \   00000018   C4C1A0E1           ASR      R12,R4,#+3
   \   0000001C   0050DCE7           LDRB     R5,[R12, +R0]
   \   00000020   8C4143E0           SUB      R4,R3,R12, LSL #+3
   \   00000024   1554A0E1           LSL      R5,R5,R4
   \   00000028   800015E3           TST      R5,#0x80
   \   0000002C   0900000A           BEQ      ??synchsafeToNormal_2
     25              {
     26                power=1;
   \   00000030   01C0A0E3           MOV      R12,#+1
     27                for(x=0;x<sizeloc;x++) power*=2;
   \   00000034   0050A0E3           MOV      R5,#+0
   \   00000038   010052E3           CMP      R2,#+1
   \   0000003C   020000AA           BGE      ??synchsafeToNormal_3
   \   00000040   030000EA           B        ??synchsafeToNormal_4
   \                     ??synchsafeToNormal_5:
   \   00000044   8CC0A0E1           LSL      R12,R12,#+1
   \   00000048   015085E2           ADD      R5,R5,#+1
   \                     ??synchsafeToNormal_3:
   \   0000004C   020055E1           CMP      R5,R2
   \   00000050   FBFFFFBA           BLT      ??synchsafeToNormal_5
     28                size+=power;
   \                     ??synchsafeToNormal_4:
   \   00000054   01108CE0           ADD      R1,R12,R1
     29              }
     30              if(synchsafe%8) sizeloc++;
   \                     ??synchsafeToNormal_2:
   \   00000058   000054E3           CMP      R4,#+0
   \   0000005C   01208212           ADDNE    R2,R2,#+1
     31            }
   \   00000060   013053E2           SUBS     R3,R3,#+1
   \   00000064   E9FFFF5A           BPL      ??synchsafeToNormal_1
     32            return size;
   \   00000068   3000BDE8           POP      {R4,R5}
   \   0000006C   0100A0E1           MOV      R0,R1
   \   00000070   1EFF2FE1           BX       LR               ;; return
     33          };
     34          

   \                                 In segment DATA_Z, align 4, align-sorted
     35          long lngFileSize;
   \                     lngFileSize:
   \   00000000                      DS8 4
     36          
     37          ulong bithdr;
   \                     bithdr:
   \   00000004                      DS8 4
     38          bool boolVBitRate;
     39          int intVFrames;
   \                     intVFrames:
   \   00000008                      DS8 4
   \                     boolVBitRate:
   \   0000000C                      DS8 1
     40          
     41          int getFrequency();
     42          int getMode();
     43          void LoadMP3Header(byte *c);
     44          bool LoadVBRHeader(byte *inputheader);
     45          int getLengthInSeconds();
     46          bool IsValidHeader();
     47          int getVersionIndex();
     48          int getBitrate();
     49          int getModeIndex();
     50              

   \                                 In segment CODE, align 4, keep-with-next
     51          HEADER_INFO ReadMP3Information(wchar_t *path, wchar_t *name)
     52          {
   \                     ??ReadMP3Information:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
     53            HEADER_INFO hdr;
     54            FSTAT stat;
     55            fstat(path,name,&stat);
     56            lngFileSize = stat.fsize;
   \   00000004   ........           LDR      R5,??DataTable24  ;; lngFileSize
   \   00000008   A4D04DE2           SUB      SP,SP,#+164
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   20208DE2           ADD      R2,SP,#+32
   \   0000001C   0710A0E1           MOV      R1,R7
   \   00000020   0600A0E1           MOV      R0,R6
   \   00000024   1C0100EF           SWI      +284
   \   00000028   28009DE5           LDR      R0,[SP, #+40]
     57            int file;
     58            file=_fopen(path,name,FSX_O_RDONLY,FSX_S_IREAD|FSX_S_IWRITE,0);
   \   0000002C   603FA0E3           MOV      R3,#+384
   \   00000030   000085E5           STR      R0,[R5, #+0]
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   0120A0E3           MOV      R2,#+1
   \   00000040   0710A0E1           MOV      R1,R7
     59            
     60            char BUF[100+1];
     61            fread(file,BUF,100);
     62            int size=0;
   \   00000044   0090A0E3           MOV      R9,#+0
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   160100EF           SWI      +278
   \   00000050   0060A0E1           MOV      R6,R0
   \   00000054   6420A0E3           MOV      R2,#+100
   \   00000058   40108DE2           ADD      R1,SP,#+64
   \   0000005C   180100EF           SWI      +280
     63            if (BUF[0]=='I' && BUF[1]=='D' && BUF[2]=='3') // проверяем, есть ли тэги v2.x
   \   00000060   4000DDE5           LDRB     R0,[SP, #+64]
   \   00000064   04D08DE2           ADD      SP,SP,#+4
   \   00000068   490050E3           CMP      R0,#+73
   \   0000006C   3D00DD05           LDRBEQ   R0,[SP, #+61]
   \   00000070   44005003           CMPEQ    R0,#+68
   \   00000074   3E00DD05           LDRBEQ   R0,[SP, #+62]
   \   00000078   33005003           CMPEQ    R0,#+51
   \   0000007C   0D00001A           BNE      ??ReadMP3Information_1
     64            {
     65              // Есть, значит надо вычесть из размера файла размер тэгов
     66              char tagSize[4];
     67              tagSize[0]=BUF[6];
   \   00000080   4210DDE5           LDRB     R1,[SP, #+66]
     68              tagSize[1]=BUF[7];
     69              tagSize[2]=BUF[8];
     70              tagSize[3]=BUF[9];
     71              size=synchsafeToNormal(tagSize);
   \   00000084   0D00A0E1           MOV      R0,SP
   \   00000088   0010CDE5           STRB     R1,[SP, #+0]
   \   0000008C   4310DDE5           LDRB     R1,[SP, #+67]
   \   00000090   0110CDE5           STRB     R1,[SP, #+1]
   \   00000094   4410DDE5           LDRB     R1,[SP, #+68]
   \   00000098   0210CDE5           STRB     R1,[SP, #+2]
   \   0000009C   4510DDE5           LDRB     R1,[SP, #+69]
   \   000000A0   0310CDE5           STRB     R1,[SP, #+3]
   \   000000A4   ........           BL       ??synchsafeToNormal
   \   000000A8   0090A0E1           MOV      R9,R0
     72              lngFileSize=lngFileSize-size;
   \   000000AC   000095E5           LDR      R0,[R5, #+0]
   \   000000B0   090040E0           SUB      R0,R0,R9
   \   000000B4   000085E5           STR      R0,[R5, #+0]
     73            }
     74            int intPos = 0;
     75            intPos=size;
     76            hdr.lngFileSize=lngFileSize;
   \                     ??ReadMP3Information_1:
   \   000000B8   001095E5           LDR      R1,[R5, #+0]
     77            hdr.id3size=size;
     78            byte *bytHeader = new byte[4];
   \   000000BC   0400A0E3           MOV      R0,#+4
   \   000000C0   10108DE5           STR      R1,[SP, #+16]
   \   000000C4   14908DE5           STR      R9,[SP, #+20]
   \   000000C8   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   000000CC   0070A0E1           MOV      R7,R0
     79            byte *bytVBitRate = new byte[12];
   \   000000D0   0C00A0E3           MOV      R0,#+12
   \   000000D4   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   000000D8   0080A0E1           MOV      R8,R0
     80            // Keep reading 4 bytes from the header until we know for sure that in 
     81            // fact it's an MP3
     82            do
     83            {
     84              lseek(file,intPos,0);
   \                     ??ReadMP3Information_2:
   \   000000DC   0020A0E3           MOV      R2,#+0
   \   000000E0   0910A0E1           MOV      R1,R9
   \   000000E4   0600A0E1           MOV      R0,R6
   \   000000E8   760100EF           SWI      +374
     85              fread(file,bytHeader,4);
   \   000000EC   0420A0E3           MOV      R2,#+4
   \   000000F0   0710A0E1           MOV      R1,R7
   \   000000F4   0600A0E1           MOV      R0,R6
   \   000000F8   180100EF           SWI      +280
     86              intPos++;
   \   000000FC   019089E2           ADD      R9,R9,#+1
     87              LoadMP3Header(bytHeader);
   \   00000100   0700A0E1           MOV      R0,R7
   \   00000104   ........           BL       ??LoadMP3Header
     88            }
     89            while(!IsValidHeader() && (intPos!=stat.fsize));
   \   00000108   ........           BL       ??IsValidHeader
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0200001A           BNE      ??ReadMP3Information_3
   \   00000114   28009DE5           LDR      R0,[SP, #+40]
   \   00000118   000059E1           CMP      R9,R0
   \   0000011C   EEFFFF1A           BNE      ??ReadMP3Information_2
     90            
     91            // If the current file stream position is equal to the length, 
     92            // that means that we've read the entire file and it's not a valid MP3 file
     93            if(intPos != stat.fsize)
   \                     ??ReadMP3Information_3:
   \   00000120   28009DE5           LDR      R0,[SP, #+40]
   \   00000124   000059E1           CMP      R9,R0
   \   00000128   2400000A           BEQ      ??ReadMP3Information_4
     94            {
     95              intPos += 3;
     96              
     97              if(getVersionIndex() == 3)    // MPEG Version 1
   \   0000012C   041095E5           LDR      R1,[R5, #+4]
   \   00000130   030089E2           ADD      R0,R9,#+3
   \   00000134   2123A0E1           LSR      R2,R1,#+6
   \   00000138   032002E2           AND      R2,R2,#0x3
   \   0000013C   A119A0E1           LSR      R1,R1,#+19
   \   00000140   031001E2           AND      R1,R1,#0x3
   \   00000144   030051E3           CMP      R1,#+3
   \   00000148   0300001A           BNE      ??ReadMP3Information_5
     98              {
     99                if(getModeIndex() == 3)    // Single Channel
   \   0000014C   030052E3           CMP      R2,#+3
   \   00000150   0400000A           BEQ      ??ReadMP3Information_6
    100                {
    101                  intPos += 17;
    102                }
    103                else
    104                {
    105                  intPos += 32;
   \   00000154   209080E2           ADD      R9,R0,#+32
   \   00000158   030000EA           B        ??ReadMP3Information_7
    106                }
    107              }
    108              else                        // MPEG Version 2.0 or 2.5
    109              {
    110                if(getModeIndex() == 3)    // Single Channel
   \                     ??ReadMP3Information_5:
   \   0000015C   030052E3           CMP      R2,#+3
    111                {
    112                  intPos += 9;
   \   00000160   09908002           ADDEQ    R9,R0,#+9
   \   00000164   0000000A           BEQ      ??ReadMP3Information_7
    113                }
    114                else
    115                {
    116                  intPos += 17;
   \                     ??ReadMP3Information_6:
   \   00000168   119080E2           ADD      R9,R0,#+17
    117                }
    118              }
    119              
    120              // Check to see if the MP3 has a variable bitrate
    121              lseek(file,intPos,0);
   \                     ??ReadMP3Information_7:
   \   0000016C   0020A0E3           MOV      R2,#+0
   \   00000170   0910A0E1           MOV      R1,R9
   \   00000174   0600A0E1           MOV      R0,R6
   \   00000178   760100EF           SWI      +374
    122              fread(file,bytVBitRate,12);
   \   0000017C   0C20A0E3           MOV      R2,#+12
   \   00000180   0810A0E1           MOV      R1,R8
   \   00000184   0600A0E1           MOV      R0,R6
   \   00000188   180100EF           SWI      +280
    123              boolVBitRate = LoadVBRHeader(bytVBitRate);
   \   0000018C   0800A0E1           MOV      R0,R8
   \   00000190   ........           BL       ??LoadVBRHeader
   \   00000194   0C00C5E5           STRB     R0,[R5, #+12]
    124              hdr.VBR=boolVBitRate;
   \   00000198   0010A0E1           MOV      R1,R0
   \   0000019C   0810CDE5           STRB     R1,[SP, #+8]
    125              // Once the file's read in, then assign the properties of the file to the public variables
    126              hdr.bitrate = getBitrate();
   \   000001A0   ........           BL       ??getBitrate
   \   000001A4   04008DE5           STR      R0,[SP, #+4]
    127              hdr.frequency = getFrequency();
   \   000001A8   ........           BL       ??getFrequency
   \   000001AC   18008DE5           STR      R0,[SP, #+24]
    128              hdr.mode=getMode();
   \   000001B0   ........           BL       ??getMode
   \   000001B4   1C008DE5           STR      R0,[SP, #+28]
    129              hdr.LengthInSeconds = getLengthInSeconds();
   \   000001B8   ........           BL       ??getLengthInSeconds
   \   000001BC   0C008DE5           STR      R0,[SP, #+12]
    130              delete(bytVBitRate);
    131              delete(bytHeader);
    132              fclose(file);
    133              return hdr;
    134            }
    135            delete(bytVBitRate);
   \                     ??ReadMP3Information_4:
   \   000001C0   0800A0E1           MOV      R0,R8
   \   000001C4   ........           _BLF     `??operator delete`,`??operator delete??rA`
    136            delete(bytHeader);
   \   000001C8   0700A0E1           MOV      R0,R7
   \   000001CC   ........           _BLF     `??operator delete`,`??operator delete??rA`
    137            fclose(file);
   \   000001D0   0600A0E1           MOV      R0,R6
   \   000001D4   170100EF           SWI      +279
    138            return hdr;
   \   000001D8   04008DE2           ADD      R0,SP,#+4
   \   000001DC   EE0190E8           LDM      R0,{R1-R3,R5-R8}
   \   000001E0   0400A0E1           MOV      R0,R4
   \   000001E4   EE0184E8           STM      R4,{R1-R3,R5-R8}
   \   000001E8   A4D08DE2           ADD      SP,SP,#+164
   \   000001EC   F083BDE8           POP      {R4-R9,PC}       ;; return
    139          };
    140          

   \                                 In segment CODE, align 4, keep-with-next
    141          void LoadMP3Header(byte *c)
    142          {
    143            // this thing is quite interesting, it works like the following
    144            // c[0] = 00000011
    145            // c[1] = 00001100
    146            // c[2] = 00110000
    147            // c[3] = 11000000
    148            // the operator << means that we'll move the bits in that direction
    149            // 00000011 << 24 = 00000011000000000000000000000000
    150            // 00001100 << 16 =         000011000000000000000000
    151            // 00110000 << 24 =                 0011000000000000
    152            // 11000000       =                         11000000
    153            //                +_________________________________
    154            //                  00000011000011000011000011000000
    155            bithdr = (ulong)(((c[0] & 255) << 24) | ((c[1] & 255) << 16) | ((c[2] & 255) <<  8) | ((c[3] & 255))); 
   \                     ??LoadMP3Header:
   \   00000000   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000004   0130D0E5           LDRB     R3,[R0, #+1]
   \   00000008   ........           LDR      R1,??DataTable23  ;; lngFileSize + 4
   \   0000000C   0338A0E1           LSL      R3,R3,#+16
   \   00000010   022C83E1           ORR      R2,R3,R2, LSL #+24
   \   00000014   0230D0E5           LDRB     R3,[R0, #+2]
   \   00000018   0300D0E5           LDRB     R0,[R0, #+3]
   \   0000001C   032482E1           ORR      R2,R2,R3, LSL #+8
   \   00000020   020080E1           ORR      R0,R0,R2
   \   00000024   000081E5           STR      R0,[R1, #+0]
    156          };
   \   00000028   1EFF2FE1           BX       LR               ;; return
    157          

   \                                 In segment CODE, align 4, keep-with-next
    158          bool LoadVBRHeader(byte *inputheader)
    159          {
    160            // If it's a variable bitrate MP3, the first 4 bytes will read 'Xing'
    161            // since they're the ones who added variable bitrate-edness to MP3s
    162            if(inputheader[0] == 88 && inputheader[1] == 105 && 
    163               inputheader[2] == 110 && inputheader[3] == 103)
   \                     ??LoadVBRHeader:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   580051E3           CMP      R1,#+88
   \   00000008   0110D005           LDRBEQ   R1,[R0, #+1]
   \   0000000C   69005103           CMPEQ    R1,#+105
   \   00000010   0210D005           LDRBEQ   R1,[R0, #+2]
   \   00000014   6E005103           CMPEQ    R1,#+110
   \   00000018   0310D005           LDRBEQ   R1,[R0, #+3]
   \   0000001C   67005103           CMPEQ    R1,#+103
   \   00000020   1000001A           BNE      ??LoadVBRHeader_1
    164            {
    165              int flags = (int)(((inputheader[4] & 255) << 24) | ((inputheader[5] & 255) << 16) | ((inputheader[6] & 255) <<  8) | ((inputheader[7] & 255)));
    166              if((flags & 0x0001) == 1)
   \   00000024   0720D0E5           LDRB     R2,[R0, #+7]
   \   00000028   40109FE5           LDR      R1,??LoadVBRHeader_2  ;; lngFileSize
   \   0000002C   010012E3           TST      R2,#0x1
   \   00000030   0800000A           BEQ      ??LoadVBRHeader_3
    167              {
    168                intVFrames = (int)(((inputheader[8] & 255) << 24) | ((inputheader[9] & 255) << 16) | ((inputheader[10] & 255) <<  8) | ((inputheader[11] & 255)));
   \   00000034   0820D0E5           LDRB     R2,[R0, #+8]
   \   00000038   0930D0E5           LDRB     R3,[R0, #+9]
   \   0000003C   0338A0E1           LSL      R3,R3,#+16
   \   00000040   022C83E1           ORR      R2,R3,R2, LSL #+24
   \   00000044   0A30D0E5           LDRB     R3,[R0, #+10]
   \   00000048   0B00D0E5           LDRB     R0,[R0, #+11]
   \   0000004C   032482E1           ORR      R2,R2,R3, LSL #+8
   \   00000050   020080E1           ORR      R0,R0,R2
   \   00000054   000000EA           B        ??LoadVBRHeader_4
    169                return true;
    170              }
    171              else
    172              {
    173                intVFrames = -1;
   \                     ??LoadVBRHeader_3:
   \   00000058   0000E0E3           MVN      R0,#+0
   \                     ??LoadVBRHeader_4:
   \   0000005C   080081E5           STR      R0,[R1, #+8]
    174                return true;
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   1EFF2FE1           BX       LR
    175              }
    176            }
    177            return false;
   \                     ??LoadVBRHeader_1:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   1EFF2FE1           BX       LR               ;; return
   \                     ??LoadVBRHeader_2:
   \   00000070   ........           DC32     lngFileSize
    178          };
    179          

   \                                 In segment CODE, align 4, keep-with-next
    180          int getFrameSync()     
    181          {
    182            return (int)((bithdr>>21) & 2047); 
   \                     ??getFrameSync:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   A00AA0E1           LSR      R0,R0,#+21
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    183          };
    184          

   \                                 In segment CODE, align 4, keep-with-next
    185          int getVersionIndex()  
    186          { 
    187            return (int)((bithdr>>19) & 3);  
   \                     ??getVersionIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00901E0           AND      R0,R1,R0, LSR #+19
   \   00000010   1EFF2FE1           BX       LR               ;; return
    188          };
    189          

   \                                 In segment CODE, align 4, keep-with-next
    190          int getLayerIndex()    
    191          { 
    192            return (int)((bithdr>>17) & 3);  
   \                     ??getLayerIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00801E0           AND      R0,R1,R0, LSR #+17
   \   00000010   1EFF2FE1           BX       LR               ;; return
    193          };
    194          

   \                                 In segment CODE, align 4, keep-with-next
    195          int getProtectionBit() 
    196          { 
    197            return (int)((bithdr>>16) & 1);  
   \                     ??getProtectionBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200801E0           AND      R0,R1,R0, LSR #+16
   \   00000010   1EFF2FE1           BX       LR               ;; return
    198          };
    199          

   \                                 In segment CODE, align 4, keep-with-next
    200          int getBitrateIndex()  
    201          { 
    202            return (int)((bithdr>>12) & 15); 
   \                     ??getBitrateIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0F10A0E3           MOV      R1,#+15
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200601E0           AND      R0,R1,R0, LSR #+12
   \   00000010   1EFF2FE1           BX       LR               ;; return
    203          };
    204          

   \                                 In segment CODE, align 4, keep-with-next
    205          int getFrequencyIndex()
    206          { 
    207            return (int)((bithdr>>10) & 3);  
   \                     ??getFrequencyIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200501E0           AND      R0,R1,R0, LSR #+10
   \   00000010   1EFF2FE1           BX       LR               ;; return
    208          };
    209          

   \                                 In segment CODE, align 4, keep-with-next
    210          int getPaddingBit()    
    211          { 
    212            return (int)((bithdr>>9) & 1);  
   \                     ??getPaddingBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00401E0           AND      R0,R1,R0, LSR #+9
   \   00000010   1EFF2FE1           BX       LR               ;; return
    213          };
    214          

   \                                 In segment CODE, align 4, keep-with-next
    215          int getPrivateBit()    
    216          { 
    217            return (int)((bithdr>>8) & 1);  
   \                     ??getPrivateBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200401E0           AND      R0,R1,R0, LSR #+8
   \   00000010   1EFF2FE1           BX       LR               ;; return
    218          };
    219          

   \                                 In segment CODE, align 4, keep-with-next
    220          int getModeIndex()     
    221          { 
    222            return (int)((bithdr>>6) & 3);  
   \                     ??getModeIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200301E0           AND      R0,R1,R0, LSR #+6
   \   00000010   1EFF2FE1           BX       LR               ;; return
    223          };
    224          

   \                                 In segment CODE, align 4, keep-with-next
    225          int getModeExtIndex()  
    226          { 
    227            return (int)((bithdr>>4) & 3);  
   \                     ??getModeExtIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200201E0           AND      R0,R1,R0, LSR #+4
   \   00000010   1EFF2FE1           BX       LR               ;; return
    228          };
    229          

   \                                 In segment CODE, align 4, keep-with-next
    230          int getCoprightBit()   
    231          { 
    232            return (int)((bithdr>>3) & 1);  
   \                     ??getCoprightBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00101E0           AND      R0,R1,R0, LSR #+3
   \   00000010   1EFF2FE1           BX       LR               ;; return
    233          };
    234          

   \                                 In segment CODE, align 4, keep-with-next
    235          int getOrginalBit()    
    236          { 
    237            return (int)((bithdr>>2) & 1);  
   \                     ??getOrginalBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200101E0           AND      R0,R1,R0, LSR #+2
   \   00000010   1EFF2FE1           BX       LR               ;; return
    238          };
    239          

   \                                 In segment CODE, align 4, keep-with-next
    240          int getEmphasisIndex() 
    241          { 
    242            return (int)(bithdr & 3);  
   \                     ??getEmphasisIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   030000E2           AND      R0,R0,#0x3
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    243          };
    244          

   \                                 In segment CODE, align 4, keep-with-next
    245          double getVersion() 
    246          {
    247            double table[4] = {2.5, 0.0, 2.0, 1.0};
   \                     ??getVersion:
   \   00000000   38109FE5           LDR      R1,??getVersion_1  ;; `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`
   \   00000004   F0012DE9           PUSH     {R4-R8}
   \   00000008   20D04DE2           SUB      SP,SP,#+32
   \   0000000C   FC1191E8           LDM      R1,{R2-R8,R12}
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   FC1180E8           STM      R0,{R2-R8,R12}
    248            return table[getVersionIndex()];
   \   00000018   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   0000001C   0310A0E3           MOV      R1,#+3
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   A00901E0           AND      R0,R1,R0, LSR #+19
   \   00000028   0D10A0E1           MOV      R1,SP
   \   0000002C   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000030   030090E8           LDM      R0,{R0,R1}
   \   00000034   20D08DE2           ADD      SP,SP,#+32
   \   00000038   F001BDE8           POP      {R4-R8}
   \   0000003C   1EFF2FE1           BX       LR               ;; return
   \                     ??getVersion_1:
   \   00000040   ........           DC32     `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`
    249          };
    250          

   \                                 In segment CODE, align 4, keep-with-next
    251          int getLayer() 
    252          {
    253            return (int)(4 - getLayerIndex());
   \                     ??getLayer:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00801E0           AND      R0,R1,R0, LSR #+17
   \   00000010   040060E2           RSB      R0,R0,#+4
   \   00000014   1EFF2FE1           BX       LR               ;; return
    254          };
    255          

   \                                 In segment CODE, align 4, keep-with-next
    256          bool IsValidHeader() 
    257          {
   \                     ??IsValidHeader:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   FF20A0E3           MOV      R2,#+255
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   702E82E3           ORR      R2,R2,#0x700
   \   00000010   A01AA0E1           LSR      R1,R0,#+21
   \   00000014   020051E1           CMP      R1,R2
   \   00000018   1000001A           BNE      ??IsValidHeader_1
    258            return (((getFrameSync()      & 2047)==2047) &&
    259                    ((getVersionIndex()   &    3)!=   1) &&
    260                      ((getLayerIndex()     &    3)!=   0) && 
    261                        ((getBitrateIndex()   &   15)!=   0) &&
    262                          ((getBitrateIndex()   &   15)!=  15) &&
    263                            ((getFrequencyIndex() &    3)!=   3) &&
    264                              ((getEmphasisIndex()  &    3)!=   2)    );
   \   0000001C   0310A0E3           MOV      R1,#+3
   \   00000020   A01901E0           AND      R1,R1,R0, LSR #+19
   \   00000024   010051E3           CMP      R1,#+1
   \   00000028   A018A011           LSRNE    R1,R0,#+17
   \   0000002C   03001113           TSTNE    R1,#0x3
   \   00000030   2016A011           LSRNE    R1,R0,#+12
   \   00000034   0F001113           TSTNE    R1,#0xF
   \   00000038   0F100112           ANDNE    R1,R1,#0xF
   \   0000003C   0F005113           CMPNE    R1,#+15
   \   00000040   0600000A           BEQ      ??IsValidHeader_1
   \   00000044   0310A0E3           MOV      R1,#+3
   \   00000048   201501E0           AND      R1,R1,R0, LSR #+10
   \   0000004C   030051E3           CMP      R1,#+3
   \   00000050   03000012           ANDNE    R0,R0,#0x3
   \   00000054   02005013           CMPNE    R0,#+2
   \   00000058   0100A013           MOVNE    R0,#+1
   \   0000005C   1EFF2F11           BXNE     LR
   \                     ??IsValidHeader_1:
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   1EFF2FE1           BX       LR               ;; return
    265          };
    266          
    267          

   \                                 In segment CODE, align 4, keep-with-next
    268          int getFrequency() 
    269          {
    270            int table[5][5] =    {    
    271              {32000, 16000,  8000}, // MPEG 2.5
    272              {    0,     0,     0}, // reserved
    273              {22050, 24000, 16000}, // MPEG 2
    274              {44100, 48000, 32000}  // MPEG 1
    275            };
   \                     ??getFrequency:
   \   00000000   48109FE5           LDR      R1,??getFrequency_1  ;; `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`
   \   00000004   64D04DE2           SUB      SP,SP,#+100
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   6430A0E3           MOV      R3,#+100
   \                     ??getFrequency_2:
   \   00000010   043053E2           SUBS     R3,R3,#+4
   \   00000014   032091E7           LDR      R2,[R1, R3]
   \   00000018   032080E7           STR      R2,[R0, R3]
   \   0000001C   FBFFFF1A           BNE      ??getFrequency_2
   \   00000020   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000024   0310A0E3           MOV      R1,#+3
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   0320A0E3           MOV      R2,#+3
   \   00000030   201501E0           AND      R1,R1,R0, LSR #+10
   \   00000034   A00902E0           AND      R0,R2,R0, LSR #+19
   \   00000038   1420A0E3           MOV      R2,#+20
   \   0000003C   0D30A0E1           MOV      R3,SP
   \   00000040   923020E0           MLA      R0,R2,R0,R3
   \   00000044   010190E7           LDR      R0,[R0, +R1, LSL #+2]
   \   00000048   64D08DE2           ADD      SP,SP,#+100
   \   0000004C   1EFF2FE1           BX       LR               ;; return
   \                     ??getFrequency_1:
   \   00000050   ........           DC32     `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`
    276            
    277            return table[getVersionIndex()][getFrequencyIndex()];
    278          };
    279          
    280          

   \                                 In segment CODE, align 4, keep-with-next
    281          int getNumberOfFrames() 
    282          {
   \                     ??getNumberOfFrames:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    283            // Again, the number of MPEG frames is dependant on whether it's a variable bitrate MP3 or not
    284            if (!boolVBitRate) 
   \   00000004   ........           LDR      R6,??DataTable24  ;; lngFileSize
   \   00000008   0C00D6E5           LDRB     R0,[R6, #+12]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   2500001A           BNE      ??getNumberOfFrames_1
    285            {
    286              double medFrameSize = (double)(((getLayerIndex()==3) ? 12 : 144) *((1000.0 * (float)getBitrate())/(float)getFrequency()));
   \   00000014   040096E5           LDR      R0,[R6, #+4]
   \   00000018   A008A0E1           LSR      R0,R0,#+17
   \   0000001C   030000E2           AND      R0,R0,#0x3
   \   00000020   030050E3           CMP      R0,#+3
   \   00000024   0C70A003           MOVEQ    R7,#+12
   \   00000028   9070A013           MOVNE    R7,#+144
   \   0000002C   ........           BL       ??getBitrate
   \   00000030   0040A0E1           MOV      R4,R0
   \   00000034   ........           BL       ??getFrequency
   \   00000038   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   0000003C   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000040   0080A0E1           MOV      R8,R0
   \   00000044   0190A0E1           MOV      R9,R1
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   00000050   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000054   ........           LDR      R3,??DataTable22  ;; 0x408f4000
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   ........           _BLF     __dMul,??__dMul??rA
   \   00000060   0820A0E1           MOV      R2,R8
   \   00000064   0930A0E1           MOV      R3,R9
   \   00000068   ........           _BLF     __dDiv,??__dDiv??rA
   \   0000006C   0040A0E1           MOV      R4,R0
   \   00000070   0150A0E1           MOV      R5,R1
   \   00000074   0700A0E1           MOV      R0,R7
   \   00000078   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   0000007C   0420A0E1           MOV      R2,R4
   \   00000080   0530A0E1           MOV      R3,R5
   \   00000084   ........           _BLF     __dMul,??__dMul??rA
   \   00000088   0040A0E1           MOV      R4,R0
    287              return (int)(lngFileSize/medFrameSize);
   \   0000008C   000096E5           LDR      R0,[R6, #+0]
   \   00000090   0150A0E1           MOV      R5,R1
   \   00000094   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000098   0420A0E1           MOV      R2,R4
   \   0000009C   0530A0E1           MOV      R3,R5
   \   000000A0   ........           _BLF     __dDiv,??__dDiv??rA
   \   000000A4   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \   000000A8   F083BDE8           POP      {R4-R9,PC}
    288            }
    289            else 
    290              return intVFrames;
   \                     ??getNumberOfFrames_1:
   \   000000AC   080096E5           LDR      R0,[R6, #+8]
   \   000000B0   F083BDE8           POP      {R4-R9,PC}       ;; return
    291          };
    292          

   \                                 In segment CODE, align 4, keep-with-next
    293          int getBitrate() 
    294          {
   \                     ??getBitrate:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    295            // If the file has a variable bitrate, then we return an integer average bitrate,
    296            // otherwise, we use a lookup table to return the bitrate
    297            if(boolVBitRate)
   \   00000004   ........           LDR      R6,??DataTable24  ;; lngFileSize
   \   00000008   60DF4DE2           SUB      SP,SP,#+384
   \   0000000C   0C00D6E5           LDRB     R0,[R6, #+12]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   2800000A           BEQ      ??getBitrate_1
    298            {
    299              double medFrameSize = (double)lngFileSize / (double)getNumberOfFrames();
   \   00000018   ........           BL       ??getNumberOfFrames
   \   0000001C   0080A0E1           MOV      R8,R0
   \   00000020   000096E5           LDR      R0,[R6, #+0]
   \   00000024   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000028   0040A0E1           MOV      R4,R0
   \   0000002C   0150A0E1           MOV      R5,R1
   \   00000030   0800A0E1           MOV      R0,R8
   \   00000034   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000038   0020A0E1           MOV      R2,R0
   \   0000003C   0130A0E1           MOV      R3,R1
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   ........           _BLF     __dDiv,??__dDiv??rA
   \   0000004C   0040A0E1           MOV      R4,R0
   \   00000050   0150A0E1           MOV      R5,R1
    300              return (int)((medFrameSize * (double)getFrequency()) / (1000.0 * ((getLayerIndex()==3) ? 12.0 : 144.0)));
   \   00000054   ........           BL       ??getFrequency
   \   00000058   ........           LDR      R1,??DataTable22  ;; 0x408f4000
   \   0000005C   0080A0E1           MOV      R8,R0
   \   00000060   040096E5           LDR      R0,[R6, #+4]
   \   00000064   0020A0E3           MOV      R2,#+0
   \   00000068   A008A0E1           LSR      R0,R0,#+17
   \   0000006C   030000E2           AND      R0,R0,#0x3
   \   00000070   030050E3           CMP      R0,#+3
   \   00000074   4034A0E3           MOV      R3,#+1073741824
   \   00000078   A0398303           ORREQ    R3,R3,#0x280000
   \   0000007C   62388313           ORRNE    R3,R3,#0x620000
   \   00000080   0000A0E3           MOV      R0,#+0
   \   00000084   ........           _BLF     __dMul,??__dMul??rA
   \   00000088   0060A0E1           MOV      R6,R0
   \   0000008C   0170A0E1           MOV      R7,R1
   \   00000090   0800A0E1           MOV      R0,R8
   \   00000094   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000098   0420A0E1           MOV      R2,R4
   \   0000009C   0530A0E1           MOV      R3,R5
   \   000000A0   ........           _BLF     __dMul,??__dMul??rA
   \   000000A4   0620A0E1           MOV      R2,R6
   \   000000A8   0730A0E1           MOV      R3,R7
   \   000000AC   ........           _BLF     __dDiv,??__dDiv??rA
   \   000000B0   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \   000000B4   60DF8DE2           ADD      SP,SP,#+384
   \   000000B8   F081BDE8           POP      {R4-R8,PC}
    301            }
    302            else
    303            {
    304              int table[2][3][16] =        {
    305                { // MPEG 2 & 2.5
    306                  {0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96,112,128,144,160,0}, // Layer III
    307                  {0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96,112,128,144,160,0}, // Layer II
    308                  {0, 32, 48, 56, 64, 80, 96,112,128,144,160,176,192,224,256,0}  // Layer I
    309                },
    310                { // MPEG 1
    311                  {0, 32, 40, 48, 56, 64, 80, 96,112,128,160,192,224,256,320,0}, // Layer III
    312                  {0, 32, 48, 56, 64, 80, 96,112,128,160,192,224,256,320,384,0}, // Layer II
    313                  {0, 32, 64, 96,128,160,192,224,256,288,320,352,384,416,448,0}  // Layer I
    314                }
    315              };
   \                     ??getBitrate_1:
   \   000000BC   50109FE5           LDR      R1,??getBitrate_2  ;; `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`
   \   000000C0   0D00A0E1           MOV      R0,SP
   \   000000C4   603FA0E3           MOV      R3,#+384
   \                     ??getBitrate_3:
   \   000000C8   043053E2           SUBS     R3,R3,#+4
   \   000000CC   032091E7           LDR      R2,[R1, R3]
   \   000000D0   032080E7           STR      R2,[R0, R3]
   \   000000D4   FBFFFF1A           BNE      ??getBitrate_3
    316              
    317              return table[getVersionIndex() & 1][getLayerIndex()-1][getBitrateIndex()];
   \   000000D8   040096E5           LDR      R0,[R6, #+4]
   \   000000DC   0F10A0E3           MOV      R1,#+15
   \   000000E0   201601E0           AND      R1,R1,R0, LSR #+12
   \   000000E4   0320A0E3           MOV      R2,#+3
   \   000000E8   A02802E0           AND      R2,R2,R0, LSR #+17
   \   000000EC   0130A0E3           MOV      R3,#+1
   \   000000F0   A00903E0           AND      R0,R3,R0, LSR #+19
   \   000000F4   C030A0E3           MOV      R3,#+192
   \   000000F8   0D60A0E1           MOV      R6,SP
   \   000000FC   936020E0           MLA      R0,R3,R0,R6
   \   00000100   020380E0           ADD      R0,R0,R2, LSL #+6
   \   00000104   010180E0           ADD      R0,R0,R1, LSL #+2
   \   00000108   400010E5           LDR      R0,[R0, #-64]
   \   0000010C   60DF8DE2           ADD      SP,SP,#+384
   \   00000110   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??getBitrate_2:
   \   00000114   ........           DC32     `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`
    318            }
    319          };
    320          

   \                                 In segment CODE, align 4, keep-with-next
    321          int getMode() 
    322          {
    323            switch(getModeIndex()) 
   \                     ??getMode:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200301E0           AND      R0,R1,R0, LSR #+6
   \   00000010   010050E2           SUBS     R0,R0,#+1
   \   00000014   0500000A           BEQ      ??getMode_1
   \   00000018   010050E2           SUBS     R0,R0,#+1
   \   0000001C   0500000A           BEQ      ??getMode_2
   \   00000020   010050E2           SUBS     R0,R0,#+1
   \   00000024   0500000A           BEQ      ??getMode_3
    324            {
    325            default:
    326              return 0;//"Stereo"
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR
    327            case 1:
    328              return 1;//"Joint Stereo"
   \                     ??getMode_1:
   \   00000030   0100A0E3           MOV      R0,#+1
   \   00000034   1EFF2FE1           BX       LR
    329            case 2:
    330              return 2;//"Dual Channel"
   \                     ??getMode_2:
   \   00000038   0200A0E3           MOV      R0,#+2
   \   0000003C   1EFF2FE1           BX       LR
    331            case 3:
    332              return 3;//"Single Channel"
   \                     ??getMode_3:
   \   00000040   0300A0E3           MOV      R0,#+3
   \   00000044   1EFF2FE1           BX       LR               ;; return
    333            }
    334          };
    335          

   \                                 In segment CODE, align 4, keep-with-next
    336          int getLengthInSeconds() 
    337          {
    338            int intKiloBitFileSize = (int)((8 * lngFileSize) / 1000);
   \                     ??getLengthInSeconds:
   \   00000000   ........           LDR      R0,??DataTable24  ;; lngFileSize
   \   00000004   2C109FE5           LDR      R1,??getLengthInSeconds_1  ;; 0x10624dd3
   \   00000008   10402DE9           PUSH     {R4,LR}
   \   0000000C   000090E5           LDR      R0,[R0, #+0]
   \   00000010   8001A0E1           LSL      R0,R0,#+3
   \   00000014   9120C3E0           SMULL    R2,R3,R1,R0
   \   00000018   4333A0E1           ASR      R3,R3,#+6
   \   0000001C   A04F83E0           ADD      R4,R3,R0, LSR #+31
    339            return (int)(intKiloBitFileSize/getBitrate());
   \   00000020   ........           BL       ??getBitrate
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000030   0100A0E1           MOV      R0,R1
   \   00000034   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??getLengthInSeconds_1:
   \   00000038   D34D6210           DC32     0x10624dd3
    340          };

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   00408F40           DC32     0x408f4000

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     lngFileSize + 4

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     lngFileSize

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`:
   \   00000000   000000000000       DC32 0H, 40040000H, 0H, 0H, 0H, 40000000H, 0H, 3FF00000H
   \              044000000000
   \              000000000000
   \              000000000040
   \              000000000000
   \              F03F        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`:
   \   00000000   007D0000803E       DC32 32000, 16000, 8000
   \              0000401F0000
   \   0000000C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \   00000014   000000000000       DC32 0, 0, 0
   \              000000000000
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \   00000028   22560000C05D       DC32 22050, 24000, 16000
   \              0000803E0000
   \   00000034   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \   0000003C   44AC000080BB       DC32 44100, 48000, 32000
   \              0000007D0000
   \   00000048   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000058   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`:
   \   00000000   000000000800       DC32 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0, 0
   \              000010000000
   \              180000002000
   \              000028000000
   \              300000003800
   \              000040000000
   \              500000006000
   \              000070000000
   \              800000009000
   \              0000A0000000
   \              000000000000
   \              0000        
   \   00000044   080000001000       DC32 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0, 0
   \              000018000000
   \              200000002800
   \              000030000000
   \              380000004000
   \              000050000000
   \              600000007000
   \              000080000000
   \              90000000A000
   \              000000000000
   \              00000000    
   \   00000084   200000003000       DC32 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 0
   \              000038000000
   \              400000005000
   \              000060000000
   \              700000008000
   \              000090000000
   \              A0000000B000
   \              0000C0000000
   \              E00000000001
   \              000000000000
   \   000000C0   000000002000       DC32 0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
   \              000028000000
   \              300000003800
   \              000040000000
   \              500000006000
   \              000070000000
   \              80000000A000
   \              0000C0000000
   \              E00000000001
   \              000040010000
   \   000000FC   000000000000       DC32 0, 0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
   \              000020000000
   \              300000003800
   \              000040000000
   \              500000006000
   \              000070000000
   \              80000000A000
   \              0000C0000000
   \              E00000000001
   \              000040010000
   \   00000138   800100000000       DC32 384, 0, 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384
   \              000000000000
   \              200000004000
   \              000060000000
   \              80000000A000
   \              0000C0000000
   \              E00000000001
   \              000020010000
   \              400100006001
   \              000080010000
   \   00000174   A0010000C001       DC32 416, 448, 0
   \              000000000000
    341          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     IsValidHeader()                    0
     LoadMP3Header(byte *)              0
     LoadVBRHeader(byte *)              0
     ReadMP3Information(wchar_t *, wchar_t *)
                                      196
     getBitrate()                     408
     getBitrateIndex()                  0
     getCoprightBit()                   0
     getEmphasisIndex()                 0
     getFrameSync()                     0
     getFrequency()                   100
     getFrequencyIndex()                0
     getLayer()                         0
     getLayerIndex()                    0
     getLengthInSeconds()               8
     getMode()                          0
     getModeExtIndex()                  0
     getModeIndex()                     0
     getNumberOfFrames()               28
     getOrginalBit()                    0
     getPaddingBit()                    0
     getPrivateBit()                    0
     getProtectionBit()                 0
     getVersion()                      52
     getVersionIndex()                  0
     synchsafeToNormal(char *)          8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     synchsafeToNormal(char *)       116
     lngFileSize                      13
     ReadMP3Information(wchar_t *, wchar_t *)
                                     496
     LoadMP3Header(byte *)            44
     LoadVBRHeader(byte *)           116
     getFrameSync()                   16
     getVersionIndex()                20
     getLayerIndex()                  20
     getProtectionBit()               20
     getBitrateIndex()                20
     getFrequencyIndex()              20
     getPaddingBit()                  20
     getPrivateBit()                  20
     getModeIndex()                   20
     getModeExtIndex()                20
     getCoprightBit()                 20
     getOrginalBit()                  20
     getEmphasisIndex()               16
     getVersion()                     68
     getLayer()                       24
     IsValidHeader()                 104
     getFrequency()                   84
     getNumberOfFrames()             180
     getBitrate()                    280
     getMode()                        72
     getLengthInSeconds()             60
     ??DataTable22                     4
     ??DataTable23                     4
     ??DataTable24                     4
     ?<Constant {(2.5), (0.0), (2.0), (1.0)}>
                                      32
     ?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {
                                     100
     ?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64
                                     384
      Others                         220

 
 2 116 bytes in segment CODE
   516 bytes in segment DATA_C
    13 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 1 908 bytes of CODE  memory (+ 220 bytes shared)
   516 bytes of CONST memory
    13 bytes of DATA  memory

Errors: none
Warnings: none
