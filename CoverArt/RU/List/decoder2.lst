##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Jun/2013  23:02:13 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\CoverArt\decod #
#                       er2.c                                                #
#    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\CoverArt\decod #
#                       er2.c -D NDEBUG -D OLDFUNCTIONS -lC                  #
#                       Z:\home\perk11\www\perk11.info\svn\SE\CoverArt\RU\Li #
#                       st\ -lA Z:\home\perk11\www\perk11.info\svn\SE\CoverA #
#                       rt\RU\List\ -o Z:\home\perk11\www\perk11.info\svn\SE #
#                       \CoverArt\RU\Obj\ -s9 --cpu_mode arm --endian        #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --enable_multibytes --fpu None --eec++            #
#                       --dlib_config Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8 #
#                       n.h --preinclude Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\CoverArt\LNG-RU.h -I Z:\home\perk11\IAR2\arm\INC\ #
#                        --inline_threshold=2                                #
#    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\CoverArt\RU\Li #
#                       st\decoder2.lst                                      #
#    Object file     =  Z:\home\perk11\www\perk11.info\svn\SE\CoverArt\RU\Ob #
#                       j\decoder2.r79                                       #
#                                                                            #
#                                                                            #
##############################################################################

Z:\home\perk11\www\perk11.info\svn\SE\CoverArt\decoder2.c
      1          #include "..\\include\Lib_Clara.h" 
      2          #include "..\\include\Dir.h" 
      3          #include "structs.h"
      4          
      5          // Модуль получения инфы из мп3
      6          // Оригинальный код Robert Wlodarczyk'а (http://www.devhood.com/tutorials/tutorial_details.aspx?tutorial_id=79)
      7          // Адаптация под SE от UltraShot'а
      8          
      9          typedef unsigned long int ulong;
     10          typedef char byte;
     11          
     12          #define INDEX(x) x/8
     13          #define SHIFT(x) x%8
     14          #define GETBIT(v,x) ((v[INDEX(x)] << SHIFT(x)) & 0x80)>>7
     15          

   \                                 In segment CODE, align 4, keep-with-next
     16          int synchsafeToNormal(char tagSize[4])
     17          {
   \                     ??synchsafeToNormal:
   \   00000000   30002DE9           PUSH     {R4,R5}
     18            int synchsafe, sizeloc, size, power, x;
     19            
     20            size=sizeloc=0;
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0010A0E3           MOV      R1,#+0
     21            for(synchsafe=31;synchsafe>=0;synchsafe--)
   \   0000000C   1F30A0E3           MOV      R3,#+31
     22            {
     23              if(GETBIT(tagSize, synchsafe))
   \                     ??synchsafeToNormal_1:
   \   00000010   4341A0E1           ASR      R4,R3,#+2
   \   00000014   A44E83E0           ADD      R4,R3,R4, LSR #+29
   \   00000018   C4C1A0E1           ASR      R12,R4,#+3
   \   0000001C   0050DCE7           LDRB     R5,[R12, +R0]
   \   00000020   8C4143E0           SUB      R4,R3,R12, LSL #+3
   \   00000024   1554A0E1           LSL      R5,R5,R4
   \   00000028   800015E3           TST      R5,#0x80
   \   0000002C   0900000A           BEQ      ??synchsafeToNormal_2
     24              {
     25                power=1;
   \   00000030   01C0A0E3           MOV      R12,#+1
     26                for(x=0;x<sizeloc;x++) power*=2;
   \   00000034   0050A0E3           MOV      R5,#+0
   \   00000038   010052E3           CMP      R2,#+1
   \   0000003C   020000AA           BGE      ??synchsafeToNormal_3
   \   00000040   030000EA           B        ??synchsafeToNormal_4
   \                     ??synchsafeToNormal_5:
   \   00000044   8CC0A0E1           LSL      R12,R12,#+1
   \   00000048   015085E2           ADD      R5,R5,#+1
   \                     ??synchsafeToNormal_3:
   \   0000004C   020055E1           CMP      R5,R2
   \   00000050   FBFFFFBA           BLT      ??synchsafeToNormal_5
     27                size+=power;
   \                     ??synchsafeToNormal_4:
   \   00000054   01108CE0           ADD      R1,R12,R1
     28              }
     29              if(synchsafe%8) sizeloc++;
   \                     ??synchsafeToNormal_2:
   \   00000058   000054E3           CMP      R4,#+0
   \   0000005C   01208212           ADDNE    R2,R2,#+1
     30            }
   \   00000060   013053E2           SUBS     R3,R3,#+1
   \   00000064   E9FFFF5A           BPL      ??synchsafeToNormal_1
     31            return size;
   \   00000068   3000BDE8           POP      {R4,R5}
   \   0000006C   0100A0E1           MOV      R0,R1
   \   00000070   1EFF2FE1           BX       LR               ;; return
     32          };
     33          

   \                                 In segment DATA_Z, align 4, align-sorted
     34          long lngFileSize;
   \                     lngFileSize:
   \   00000000                      DS8 4
     35          
     36          ulong bithdr;
   \                     bithdr:
   \   00000004                      DS8 4
     37          bool boolVBitRate;
     38          int intVFrames;
   \                     intVFrames:
   \   00000008                      DS8 4
   \                     boolVBitRate:
   \   0000000C                      DS8 1
     39          
     40          int getFrequency();
     41          int getMode();
     42          void LoadMP3Header(byte *c);
     43          bool LoadVBRHeader(byte *inputheader);
     44          int getLengthInSeconds();
     45          bool IsValidHeader();
     46          int getVersionIndex();
     47          int getBitrate();
     48          int getModeIndex();
     49              

   \                                 In segment CODE, align 4, keep-with-next
     50          HEADER_INFO ReadMP3Information(wchar_t *path, wchar_t *name)
     51          {
   \                     ??ReadMP3Information:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
     52            HEADER_INFO hdr;
     53            FSTAT stat;
     54            fstat(path,name,&stat);
     55            lngFileSize = stat.fsize;
   \   00000004   ........           LDR      R5,??DataTable24  ;; lngFileSize
   \   00000008   A4D04DE2           SUB      SP,SP,#+164
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   0160A0E1           MOV      R6,R1
   \   00000014   0270A0E1           MOV      R7,R2
   \   00000018   20208DE2           ADD      R2,SP,#+32
   \   0000001C   0710A0E1           MOV      R1,R7
   \   00000020   0600A0E1           MOV      R0,R6
   \   00000024   1C0100EF           SWI      +284
   \   00000028   28009DE5           LDR      R0,[SP, #+40]
     56            int file;
     57            file=_fopen(path,name,FSX_O_RDONLY,FSX_S_IREAD|FSX_S_IWRITE,0);
   \   0000002C   603FA0E3           MOV      R3,#+384
   \   00000030   000085E5           STR      R0,[R5, #+0]
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   0120A0E3           MOV      R2,#+1
   \   00000040   0710A0E1           MOV      R1,R7
     58            
     59            char BUF[100+1];
     60            fread(file,BUF,100);
     61            int size=0;
   \   00000044   0090A0E3           MOV      R9,#+0
   \   00000048   0600A0E1           MOV      R0,R6
   \   0000004C   160100EF           SWI      +278
   \   00000050   0060A0E1           MOV      R6,R0
   \   00000054   6420A0E3           MOV      R2,#+100
   \   00000058   40108DE2           ADD      R1,SP,#+64
   \   0000005C   180100EF           SWI      +280
     62            if (BUF[0]=='I' && BUF[1]=='D' && BUF[2]=='3') // проверяем, есть ли тэги v2.x
   \   00000060   4000DDE5           LDRB     R0,[SP, #+64]
   \   00000064   04D08DE2           ADD      SP,SP,#+4
   \   00000068   490050E3           CMP      R0,#+73
   \   0000006C   3D00DD05           LDRBEQ   R0,[SP, #+61]
   \   00000070   44005003           CMPEQ    R0,#+68
   \   00000074   3E00DD05           LDRBEQ   R0,[SP, #+62]
   \   00000078   33005003           CMPEQ    R0,#+51
   \   0000007C   0D00001A           BNE      ??ReadMP3Information_1
     63            {
     64              // Есть, значит надо вычесть из размера файла размер тэгов
     65              char tagSize[4];
     66              tagSize[0]=BUF[6];
   \   00000080   4210DDE5           LDRB     R1,[SP, #+66]
     67              tagSize[1]=BUF[7];
     68              tagSize[2]=BUF[8];
     69              tagSize[3]=BUF[9];
     70              size=synchsafeToNormal(tagSize);
   \   00000084   0D00A0E1           MOV      R0,SP
   \   00000088   0010CDE5           STRB     R1,[SP, #+0]
   \   0000008C   4310DDE5           LDRB     R1,[SP, #+67]
   \   00000090   0110CDE5           STRB     R1,[SP, #+1]
   \   00000094   4410DDE5           LDRB     R1,[SP, #+68]
   \   00000098   0210CDE5           STRB     R1,[SP, #+2]
   \   0000009C   4510DDE5           LDRB     R1,[SP, #+69]
   \   000000A0   0310CDE5           STRB     R1,[SP, #+3]
   \   000000A4   ........           BL       ??synchsafeToNormal
   \   000000A8   0090A0E1           MOV      R9,R0
     71              lngFileSize=lngFileSize-size;
   \   000000AC   000095E5           LDR      R0,[R5, #+0]
   \   000000B0   090040E0           SUB      R0,R0,R9
   \   000000B4   000085E5           STR      R0,[R5, #+0]
     72            }
     73            int intPos = 0;
     74            intPos=size;
     75            hdr.lngFileSize=lngFileSize;
   \                     ??ReadMP3Information_1:
   \   000000B8   001095E5           LDR      R1,[R5, #+0]
     76            hdr.id3size=size;
     77            byte *bytHeader = new byte[4];
   \   000000BC   0400A0E3           MOV      R0,#+4
   \   000000C0   10108DE5           STR      R1,[SP, #+16]
   \   000000C4   14908DE5           STR      R9,[SP, #+20]
   \   000000C8   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   000000CC   0070A0E1           MOV      R7,R0
     78            byte *bytVBitRate = new byte[12];
   \   000000D0   0C00A0E3           MOV      R0,#+12
   \   000000D4   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   000000D8   0080A0E1           MOV      R8,R0
     79            // Keep reading 4 bytes from the header until we know for sure that in 
     80            // fact it's an MP3
     81            do
     82            {
     83              lseek(file,intPos,0);
   \                     ??ReadMP3Information_2:
   \   000000DC   0020A0E3           MOV      R2,#+0
   \   000000E0   0910A0E1           MOV      R1,R9
   \   000000E4   0600A0E1           MOV      R0,R6
   \   000000E8   760100EF           SWI      +374
     84              fread(file,bytHeader,4);
   \   000000EC   0420A0E3           MOV      R2,#+4
   \   000000F0   0710A0E1           MOV      R1,R7
   \   000000F4   0600A0E1           MOV      R0,R6
   \   000000F8   180100EF           SWI      +280
     85              intPos++;
   \   000000FC   019089E2           ADD      R9,R9,#+1
     86              LoadMP3Header(bytHeader);
   \   00000100   0700A0E1           MOV      R0,R7
   \   00000104   ........           BL       ??LoadMP3Header
     87            }
     88            while(!IsValidHeader() && (intPos!=stat.fsize));
   \   00000108   ........           BL       ??IsValidHeader
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0200001A           BNE      ??ReadMP3Information_3
   \   00000114   28009DE5           LDR      R0,[SP, #+40]
   \   00000118   000059E1           CMP      R9,R0
   \   0000011C   EEFFFF1A           BNE      ??ReadMP3Information_2
     89            
     90            // If the current file stream position is equal to the length, 
     91            // that means that we've read the entire file and it's not a valid MP3 file
     92            if(intPos != stat.fsize)
   \                     ??ReadMP3Information_3:
   \   00000120   28009DE5           LDR      R0,[SP, #+40]
   \   00000124   000059E1           CMP      R9,R0
   \   00000128   2400000A           BEQ      ??ReadMP3Information_4
     93            {
     94              intPos += 3;
     95              
     96              if(getVersionIndex() == 3)    // MPEG Version 1
   \   0000012C   041095E5           LDR      R1,[R5, #+4]
   \   00000130   030089E2           ADD      R0,R9,#+3
   \   00000134   2123A0E1           LSR      R2,R1,#+6
   \   00000138   032002E2           AND      R2,R2,#0x3
   \   0000013C   A119A0E1           LSR      R1,R1,#+19
   \   00000140   031001E2           AND      R1,R1,#0x3
   \   00000144   030051E3           CMP      R1,#+3
   \   00000148   0300001A           BNE      ??ReadMP3Information_5
     97              {
     98                if(getModeIndex() == 3)    // Single Channel
   \   0000014C   030052E3           CMP      R2,#+3
   \   00000150   0400000A           BEQ      ??ReadMP3Information_6
     99                {
    100                  intPos += 17;
    101                }
    102                else
    103                {
    104                  intPos += 32;
   \   00000154   209080E2           ADD      R9,R0,#+32
   \   00000158   030000EA           B        ??ReadMP3Information_7
    105                }
    106              }
    107              else                        // MPEG Version 2.0 or 2.5
    108              {
    109                if(getModeIndex() == 3)    // Single Channel
   \                     ??ReadMP3Information_5:
   \   0000015C   030052E3           CMP      R2,#+3
    110                {
    111                  intPos += 9;
   \   00000160   09908002           ADDEQ    R9,R0,#+9
   \   00000164   0000000A           BEQ      ??ReadMP3Information_7
    112                }
    113                else
    114                {
    115                  intPos += 17;
   \                     ??ReadMP3Information_6:
   \   00000168   119080E2           ADD      R9,R0,#+17
    116                }
    117              }
    118              
    119              // Check to see if the MP3 has a variable bitrate
    120              lseek(file,intPos,0);
   \                     ??ReadMP3Information_7:
   \   0000016C   0020A0E3           MOV      R2,#+0
   \   00000170   0910A0E1           MOV      R1,R9
   \   00000174   0600A0E1           MOV      R0,R6
   \   00000178   760100EF           SWI      +374
    121              fread(file,bytVBitRate,12);
   \   0000017C   0C20A0E3           MOV      R2,#+12
   \   00000180   0810A0E1           MOV      R1,R8
   \   00000184   0600A0E1           MOV      R0,R6
   \   00000188   180100EF           SWI      +280
    122              boolVBitRate = LoadVBRHeader(bytVBitRate);
   \   0000018C   0800A0E1           MOV      R0,R8
   \   00000190   ........           BL       ??LoadVBRHeader
   \   00000194   0C00C5E5           STRB     R0,[R5, #+12]
    123              hdr.VBR=boolVBitRate;
   \   00000198   0010A0E1           MOV      R1,R0
   \   0000019C   0810CDE5           STRB     R1,[SP, #+8]
    124              // Once the file's read in, then assign the properties of the file to the public variables
    125              hdr.bitrate = getBitrate();
   \   000001A0   ........           BL       ??getBitrate
   \   000001A4   04008DE5           STR      R0,[SP, #+4]
    126              hdr.frequency = getFrequency();
   \   000001A8   ........           BL       ??getFrequency
   \   000001AC   18008DE5           STR      R0,[SP, #+24]
    127              hdr.mode=getMode();
   \   000001B0   ........           BL       ??getMode
   \   000001B4   1C008DE5           STR      R0,[SP, #+28]
    128              hdr.LengthInSeconds = getLengthInSeconds();
   \   000001B8   ........           BL       ??getLengthInSeconds
   \   000001BC   0C008DE5           STR      R0,[SP, #+12]
    129              delete(bytVBitRate);
    130              delete(bytHeader);
    131              fclose(file);
    132              return hdr;
    133            }
    134            delete(bytVBitRate);
   \                     ??ReadMP3Information_4:
   \   000001C0   0800A0E1           MOV      R0,R8
   \   000001C4   ........           _BLF     `??operator delete`,`??operator delete??rA`
    135            delete(bytHeader);
   \   000001C8   0700A0E1           MOV      R0,R7
   \   000001CC   ........           _BLF     `??operator delete`,`??operator delete??rA`
    136            fclose(file);
   \   000001D0   0600A0E1           MOV      R0,R6
   \   000001D4   170100EF           SWI      +279
    137            return hdr;
   \   000001D8   04008DE2           ADD      R0,SP,#+4
   \   000001DC   EE0190E8           LDM      R0,{R1-R3,R5-R8}
   \   000001E0   0400A0E1           MOV      R0,R4
   \   000001E4   EE0184E8           STM      R4,{R1-R3,R5-R8}
   \   000001E8   A4D08DE2           ADD      SP,SP,#+164
   \   000001EC   F083BDE8           POP      {R4-R9,PC}       ;; return
    138          };
    139          

   \                                 In segment CODE, align 4, keep-with-next
    140          void LoadMP3Header(byte *c)
    141          {
    142            // this thing is quite interesting, it works like the following
    143            // c[0] = 00000011
    144            // c[1] = 00001100
    145            // c[2] = 00110000
    146            // c[3] = 11000000
    147            // the operator << means that we'll move the bits in that direction
    148            // 00000011 << 24 = 00000011000000000000000000000000
    149            // 00001100 << 16 =         000011000000000000000000
    150            // 00110000 << 24 =                 0011000000000000
    151            // 11000000       =                         11000000
    152            //                +_________________________________
    153            //                  00000011000011000011000011000000
    154            bithdr = (ulong)(((c[0] & 255) << 24) | ((c[1] & 255) << 16) | ((c[2] & 255) <<  8) | ((c[3] & 255))); 
   \                     ??LoadMP3Header:
   \   00000000   0020D0E5           LDRB     R2,[R0, #+0]
   \   00000004   0130D0E5           LDRB     R3,[R0, #+1]
   \   00000008   ........           LDR      R1,??DataTable23  ;; lngFileSize + 4
   \   0000000C   0338A0E1           LSL      R3,R3,#+16
   \   00000010   022C83E1           ORR      R2,R3,R2, LSL #+24
   \   00000014   0230D0E5           LDRB     R3,[R0, #+2]
   \   00000018   0300D0E5           LDRB     R0,[R0, #+3]
   \   0000001C   032482E1           ORR      R2,R2,R3, LSL #+8
   \   00000020   020080E1           ORR      R0,R0,R2
   \   00000024   000081E5           STR      R0,[R1, #+0]
    155          };
   \   00000028   1EFF2FE1           BX       LR               ;; return
    156          

   \                                 In segment CODE, align 4, keep-with-next
    157          bool LoadVBRHeader(byte *inputheader)
    158          {
    159            // If it's a variable bitrate MP3, the first 4 bytes will read 'Xing'
    160            // since they're the ones who added variable bitrate-edness to MP3s
    161            if(inputheader[0] == 88 && inputheader[1] == 105 && 
    162               inputheader[2] == 110 && inputheader[3] == 103)
   \                     ??LoadVBRHeader:
   \   00000000   0010D0E5           LDRB     R1,[R0, #+0]
   \   00000004   580051E3           CMP      R1,#+88
   \   00000008   0110D005           LDRBEQ   R1,[R0, #+1]
   \   0000000C   69005103           CMPEQ    R1,#+105
   \   00000010   0210D005           LDRBEQ   R1,[R0, #+2]
   \   00000014   6E005103           CMPEQ    R1,#+110
   \   00000018   0310D005           LDRBEQ   R1,[R0, #+3]
   \   0000001C   67005103           CMPEQ    R1,#+103
   \   00000020   1000001A           BNE      ??LoadVBRHeader_1
    163            {
    164              int flags = (int)(((inputheader[4] & 255) << 24) | ((inputheader[5] & 255) << 16) | ((inputheader[6] & 255) <<  8) | ((inputheader[7] & 255)));
    165              if((flags & 0x0001) == 1)
   \   00000024   0720D0E5           LDRB     R2,[R0, #+7]
   \   00000028   40109FE5           LDR      R1,??LoadVBRHeader_2  ;; lngFileSize
   \   0000002C   010012E3           TST      R2,#0x1
   \   00000030   0800000A           BEQ      ??LoadVBRHeader_3
    166              {
    167                intVFrames = (int)(((inputheader[8] & 255) << 24) | ((inputheader[9] & 255) << 16) | ((inputheader[10] & 255) <<  8) | ((inputheader[11] & 255)));
   \   00000034   0820D0E5           LDRB     R2,[R0, #+8]
   \   00000038   0930D0E5           LDRB     R3,[R0, #+9]
   \   0000003C   0338A0E1           LSL      R3,R3,#+16
   \   00000040   022C83E1           ORR      R2,R3,R2, LSL #+24
   \   00000044   0A30D0E5           LDRB     R3,[R0, #+10]
   \   00000048   0B00D0E5           LDRB     R0,[R0, #+11]
   \   0000004C   032482E1           ORR      R2,R2,R3, LSL #+8
   \   00000050   020080E1           ORR      R0,R0,R2
   \   00000054   000000EA           B        ??LoadVBRHeader_4
    168                return true;
    169              }
    170              else
    171              {
    172                intVFrames = -1;
   \                     ??LoadVBRHeader_3:
   \   00000058   0000E0E3           MVN      R0,#+0
   \                     ??LoadVBRHeader_4:
   \   0000005C   080081E5           STR      R0,[R1, #+8]
    173                return true;
   \   00000060   0100A0E3           MOV      R0,#+1
   \   00000064   1EFF2FE1           BX       LR
    174              }
    175            }
    176            return false;
   \                     ??LoadVBRHeader_1:
   \   00000068   0000A0E3           MOV      R0,#+0
   \   0000006C   1EFF2FE1           BX       LR               ;; return
   \                     ??LoadVBRHeader_2:
   \   00000070   ........           DC32     lngFileSize
    177          };
    178          

   \                                 In segment CODE, align 4, keep-with-next
    179          int getFrameSync()     
    180          {
    181            return (int)((bithdr>>21) & 2047); 
   \                     ??getFrameSync:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   A00AA0E1           LSR      R0,R0,#+21
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    182          };
    183          

   \                                 In segment CODE, align 4, keep-with-next
    184          int getVersionIndex()  
    185          { 
    186            return (int)((bithdr>>19) & 3);  
   \                     ??getVersionIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00901E0           AND      R0,R1,R0, LSR #+19
   \   00000010   1EFF2FE1           BX       LR               ;; return
    187          };
    188          

   \                                 In segment CODE, align 4, keep-with-next
    189          int getLayerIndex()    
    190          { 
    191            return (int)((bithdr>>17) & 3);  
   \                     ??getLayerIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00801E0           AND      R0,R1,R0, LSR #+17
   \   00000010   1EFF2FE1           BX       LR               ;; return
    192          };
    193          

   \                                 In segment CODE, align 4, keep-with-next
    194          int getProtectionBit() 
    195          { 
    196            return (int)((bithdr>>16) & 1);  
   \                     ??getProtectionBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200801E0           AND      R0,R1,R0, LSR #+16
   \   00000010   1EFF2FE1           BX       LR               ;; return
    197          };
    198          

   \                                 In segment CODE, align 4, keep-with-next
    199          int getBitrateIndex()  
    200          { 
    201            return (int)((bithdr>>12) & 15); 
   \                     ??getBitrateIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0F10A0E3           MOV      R1,#+15
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200601E0           AND      R0,R1,R0, LSR #+12
   \   00000010   1EFF2FE1           BX       LR               ;; return
    202          };
    203          

   \                                 In segment CODE, align 4, keep-with-next
    204          int getFrequencyIndex()
    205          { 
    206            return (int)((bithdr>>10) & 3);  
   \                     ??getFrequencyIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200501E0           AND      R0,R1,R0, LSR #+10
   \   00000010   1EFF2FE1           BX       LR               ;; return
    207          };
    208          

   \                                 In segment CODE, align 4, keep-with-next
    209          int getPaddingBit()    
    210          { 
    211            return (int)((bithdr>>9) & 1);  
   \                     ??getPaddingBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00401E0           AND      R0,R1,R0, LSR #+9
   \   00000010   1EFF2FE1           BX       LR               ;; return
    212          };
    213          

   \                                 In segment CODE, align 4, keep-with-next
    214          int getPrivateBit()    
    215          { 
    216            return (int)((bithdr>>8) & 1);  
   \                     ??getPrivateBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200401E0           AND      R0,R1,R0, LSR #+8
   \   00000010   1EFF2FE1           BX       LR               ;; return
    217          };
    218          

   \                                 In segment CODE, align 4, keep-with-next
    219          int getModeIndex()     
    220          { 
    221            return (int)((bithdr>>6) & 3);  
   \                     ??getModeIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200301E0           AND      R0,R1,R0, LSR #+6
   \   00000010   1EFF2FE1           BX       LR               ;; return
    222          };
    223          

   \                                 In segment CODE, align 4, keep-with-next
    224          int getModeExtIndex()  
    225          { 
    226            return (int)((bithdr>>4) & 3);  
   \                     ??getModeExtIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200201E0           AND      R0,R1,R0, LSR #+4
   \   00000010   1EFF2FE1           BX       LR               ;; return
    227          };
    228          

   \                                 In segment CODE, align 4, keep-with-next
    229          int getCoprightBit()   
    230          { 
    231            return (int)((bithdr>>3) & 1);  
   \                     ??getCoprightBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00101E0           AND      R0,R1,R0, LSR #+3
   \   00000010   1EFF2FE1           BX       LR               ;; return
    232          };
    233          

   \                                 In segment CODE, align 4, keep-with-next
    234          int getOrginalBit()    
    235          { 
    236            return (int)((bithdr>>2) & 1);  
   \                     ??getOrginalBit:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0110A0E3           MOV      R1,#+1
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200101E0           AND      R0,R1,R0, LSR #+2
   \   00000010   1EFF2FE1           BX       LR               ;; return
    237          };
    238          

   \                                 In segment CODE, align 4, keep-with-next
    239          int getEmphasisIndex() 
    240          { 
    241            return (int)(bithdr & 3);  
   \                     ??getEmphasisIndex:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   030000E2           AND      R0,R0,#0x3
   \   0000000C   1EFF2FE1           BX       LR               ;; return
    242          };
    243          

   \                                 In segment CODE, align 4, keep-with-next
    244          double getVersion() 
    245          {
    246            double table[4] = {2.5, 0.0, 2.0, 1.0};
   \                     ??getVersion:
   \   00000000   38109FE5           LDR      R1,??getVersion_1  ;; `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`
   \   00000004   F0012DE9           PUSH     {R4-R8}
   \   00000008   20D04DE2           SUB      SP,SP,#+32
   \   0000000C   FC1191E8           LDM      R1,{R2-R8,R12}
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   FC1180E8           STM      R0,{R2-R8,R12}
    247            return table[getVersionIndex()];
   \   00000018   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   0000001C   0310A0E3           MOV      R1,#+3
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   A00901E0           AND      R0,R1,R0, LSR #+19
   \   00000028   0D10A0E1           MOV      R1,SP
   \   0000002C   800181E0           ADD      R0,R1,R0, LSL #+3
   \   00000030   030090E8           LDM      R0,{R0,R1}
   \   00000034   20D08DE2           ADD      SP,SP,#+32
   \   00000038   F001BDE8           POP      {R4-R8}
   \   0000003C   1EFF2FE1           BX       LR               ;; return
   \                     ??getVersion_1:
   \   00000040   ........           DC32     `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`
    248          };
    249          

   \                                 In segment CODE, align 4, keep-with-next
    250          int getLayer() 
    251          {
    252            return (int)(4 - getLayerIndex());
   \                     ??getLayer:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   A00801E0           AND      R0,R1,R0, LSR #+17
   \   00000010   040060E2           RSB      R0,R0,#+4
   \   00000014   1EFF2FE1           BX       LR               ;; return
    253          };
    254          

   \                                 In segment CODE, align 4, keep-with-next
    255          bool IsValidHeader() 
    256          {
   \                     ??IsValidHeader:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   FF20A0E3           MOV      R2,#+255
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   702E82E3           ORR      R2,R2,#0x700
   \   00000010   A01AA0E1           LSR      R1,R0,#+21
   \   00000014   020051E1           CMP      R1,R2
   \   00000018   1000001A           BNE      ??IsValidHeader_1
    257            return (((getFrameSync()      & 2047)==2047) &&
    258                    ((getVersionIndex()   &    3)!=   1) &&
    259                      ((getLayerIndex()     &    3)!=   0) && 
    260                        ((getBitrateIndex()   &   15)!=   0) &&
    261                          ((getBitrateIndex()   &   15)!=  15) &&
    262                            ((getFrequencyIndex() &    3)!=   3) &&
    263                              ((getEmphasisIndex()  &    3)!=   2)    );
   \   0000001C   0310A0E3           MOV      R1,#+3
   \   00000020   A01901E0           AND      R1,R1,R0, LSR #+19
   \   00000024   010051E3           CMP      R1,#+1
   \   00000028   A018A011           LSRNE    R1,R0,#+17
   \   0000002C   03001113           TSTNE    R1,#0x3
   \   00000030   2016A011           LSRNE    R1,R0,#+12
   \   00000034   0F001113           TSTNE    R1,#0xF
   \   00000038   0F100112           ANDNE    R1,R1,#0xF
   \   0000003C   0F005113           CMPNE    R1,#+15
   \   00000040   0600000A           BEQ      ??IsValidHeader_1
   \   00000044   0310A0E3           MOV      R1,#+3
   \   00000048   201501E0           AND      R1,R1,R0, LSR #+10
   \   0000004C   030051E3           CMP      R1,#+3
   \   00000050   03000012           ANDNE    R0,R0,#0x3
   \   00000054   02005013           CMPNE    R0,#+2
   \   00000058   0100A013           MOVNE    R0,#+1
   \   0000005C   1EFF2F11           BXNE     LR
   \                     ??IsValidHeader_1:
   \   00000060   0000A0E3           MOV      R0,#+0
   \   00000064   1EFF2FE1           BX       LR               ;; return
    264          };
    265          
    266          

   \                                 In segment CODE, align 4, keep-with-next
    267          int getFrequency() 
    268          {
    269            int table[5][5] =    {    
    270              {32000, 16000,  8000}, // MPEG 2.5
    271              {    0,     0,     0}, // reserved
    272              {22050, 24000, 16000}, // MPEG 2
    273              {44100, 48000, 32000}  // MPEG 1
    274            };
   \                     ??getFrequency:
   \   00000000   48109FE5           LDR      R1,??getFrequency_1  ;; `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`
   \   00000004   64D04DE2           SUB      SP,SP,#+100
   \   00000008   0D00A0E1           MOV      R0,SP
   \   0000000C   6430A0E3           MOV      R3,#+100
   \                     ??getFrequency_2:
   \   00000010   043053E2           SUBS     R3,R3,#+4
   \   00000014   032091E7           LDR      R2,[R1, R3]
   \   00000018   032080E7           STR      R2,[R0, R3]
   \   0000001C   FBFFFF1A           BNE      ??getFrequency_2
   \   00000020   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000024   0310A0E3           MOV      R1,#+3
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   0320A0E3           MOV      R2,#+3
   \   00000030   201501E0           AND      R1,R1,R0, LSR #+10
   \   00000034   A00902E0           AND      R0,R2,R0, LSR #+19
   \   00000038   1420A0E3           MOV      R2,#+20
   \   0000003C   0D30A0E1           MOV      R3,SP
   \   00000040   923020E0           MLA      R0,R2,R0,R3
   \   00000044   010190E7           LDR      R0,[R0, +R1, LSL #+2]
   \   00000048   64D08DE2           ADD      SP,SP,#+100
   \   0000004C   1EFF2FE1           BX       LR               ;; return
   \                     ??getFrequency_1:
   \   00000050   ........           DC32     `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`
    275            
    276            return table[getVersionIndex()][getFrequencyIndex()];
    277          };
    278          
    279          

   \                                 In segment CODE, align 4, keep-with-next
    280          int getNumberOfFrames() 
    281          {
   \                     ??getNumberOfFrames:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
    282            // Again, the number of MPEG frames is dependant on whether it's a variable bitrate MP3 or not
    283            if (!boolVBitRate) 
   \   00000004   ........           LDR      R6,??DataTable24  ;; lngFileSize
   \   00000008   0C00D6E5           LDRB     R0,[R6, #+12]
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   2500001A           BNE      ??getNumberOfFrames_1
    284            {
    285              double medFrameSize = (double)(((getLayerIndex()==3) ? 12 : 144) *((1000.0 * (float)getBitrate())/(float)getFrequency()));
   \   00000014   040096E5           LDR      R0,[R6, #+4]
   \   00000018   A008A0E1           LSR      R0,R0,#+17
   \   0000001C   030000E2           AND      R0,R0,#0x3
   \   00000020   030050E3           CMP      R0,#+3
   \   00000024   0C70A003           MOVEQ    R7,#+12
   \   00000028   9070A013           MOVNE    R7,#+144
   \   0000002C   ........           BL       ??getBitrate
   \   00000030   0040A0E1           MOV      R4,R0
   \   00000034   ........           BL       ??getFrequency
   \   00000038   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   0000003C   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000040   0080A0E1           MOV      R8,R0
   \   00000044   0190A0E1           MOV      R9,R1
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   ........           _BLF     __longToFloat,??__longToFloat??rA
   \   00000050   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   00000054   ........           LDR      R3,??DataTable22  ;; 0x408f4000
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   ........           _BLF     __dMul,??__dMul??rA
   \   00000060   0820A0E1           MOV      R2,R8
   \   00000064   0930A0E1           MOV      R3,R9
   \   00000068   ........           _BLF     __dDiv,??__dDiv??rA
   \   0000006C   0040A0E1           MOV      R4,R0
   \   00000070   0150A0E1           MOV      R5,R1
   \   00000074   0700A0E1           MOV      R0,R7
   \   00000078   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   0000007C   0420A0E1           MOV      R2,R4
   \   00000080   0530A0E1           MOV      R3,R5
   \   00000084   ........           _BLF     __dMul,??__dMul??rA
   \   00000088   0040A0E1           MOV      R4,R0
    286              return (int)(lngFileSize/medFrameSize);
   \   0000008C   000096E5           LDR      R0,[R6, #+0]
   \   00000090   0150A0E1           MOV      R5,R1
   \   00000094   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000098   0420A0E1           MOV      R2,R4
   \   0000009C   0530A0E1           MOV      R3,R5
   \   000000A0   ........           _BLF     __dDiv,??__dDiv??rA
   \   000000A4   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \   000000A8   F083BDE8           POP      {R4-R9,PC}
    287            }
    288            else 
    289              return intVFrames;
   \                     ??getNumberOfFrames_1:
   \   000000AC   080096E5           LDR      R0,[R6, #+8]
   \   000000B0   F083BDE8           POP      {R4-R9,PC}       ;; return
    290          };
    291          

   \                                 In segment CODE, align 4, keep-with-next
    292          int getBitrate() 
    293          {
   \                     ??getBitrate:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
    294            // If the file has a variable bitrate, then we return an integer average bitrate,
    295            // otherwise, we use a lookup table to return the bitrate
    296            if(boolVBitRate)
   \   00000004   ........           LDR      R6,??DataTable24  ;; lngFileSize
   \   00000008   60DF4DE2           SUB      SP,SP,#+384
   \   0000000C   0C00D6E5           LDRB     R0,[R6, #+12]
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   2800000A           BEQ      ??getBitrate_1
    297            {
    298              double medFrameSize = (double)lngFileSize / (double)getNumberOfFrames();
   \   00000018   ........           BL       ??getNumberOfFrames
   \   0000001C   0080A0E1           MOV      R8,R0
   \   00000020   000096E5           LDR      R0,[R6, #+0]
   \   00000024   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000028   0040A0E1           MOV      R4,R0
   \   0000002C   0150A0E1           MOV      R5,R1
   \   00000030   0800A0E1           MOV      R0,R8
   \   00000034   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000038   0020A0E1           MOV      R2,R0
   \   0000003C   0130A0E1           MOV      R3,R1
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   0510A0E1           MOV      R1,R5
   \   00000048   ........           _BLF     __dDiv,??__dDiv??rA
   \   0000004C   0040A0E1           MOV      R4,R0
   \   00000050   0150A0E1           MOV      R5,R1
    299              return (int)((medFrameSize * (double)getFrequency()) / (1000.0 * ((getLayerIndex()==3) ? 12.0 : 144.0)));
   \   00000054   ........           BL       ??getFrequency
   \   00000058   ........           LDR      R1,??DataTable22  ;; 0x408f4000
   \   0000005C   0080A0E1           MOV      R8,R0
   \   00000060   040096E5           LDR      R0,[R6, #+4]
   \   00000064   0020A0E3           MOV      R2,#+0
   \   00000068   A008A0E1           LSR      R0,R0,#+17
   \   0000006C   030000E2           AND      R0,R0,#0x3
   \   00000070   030050E3           CMP      R0,#+3
   \   00000074   4034A0E3           MOV      R3,#+1073741824
   \   00000078   A0398303           ORREQ    R3,R3,#0x280000
   \   0000007C   62388313           ORRNE    R3,R3,#0x620000
   \   00000080   0000A0E3           MOV      R0,#+0
   \   00000084   ........           _BLF     __dMul,??__dMul??rA
   \   00000088   0060A0E1           MOV      R6,R0
   \   0000008C   0170A0E1           MOV      R7,R1
   \   00000090   0800A0E1           MOV      R0,R8
   \   00000094   ........           _BLF     __longToDouble,??__longToDouble??rA
   \   00000098   0420A0E1           MOV      R2,R4
   \   0000009C   0530A0E1           MOV      R3,R5
   \   000000A0   ........           _BLF     __dMul,??__dMul??rA
   \   000000A4   0620A0E1           MOV      R2,R6
   \   000000A8   0730A0E1           MOV      R3,R7
   \   000000AC   ........           _BLF     __dDiv,??__dDiv??rA
   \   000000B0   ........           _BLF     __doubleToLong,??__doubleToLong??rA
   \   000000B4   60DF8DE2           ADD      SP,SP,#+384
   \   000000B8   F081BDE8           POP      {R4-R8,PC}
    300            }
    301            else
    302            {
    303              int table[2][3][16] =        {
    304                { // MPEG 2 & 2.5
    305                  {0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96,112,128,144,160,0}, // Layer III
    306                  {0,  8, 16, 24, 32, 40, 48, 56, 64, 80, 96,112,128,144,160,0}, // Layer II
    307                  {0, 32, 48, 56, 64, 80, 96,112,128,144,160,176,192,224,256,0}  // Layer I
    308                },
    309                { // MPEG 1
    310                  {0, 32, 40, 48, 56, 64, 80, 96,112,128,160,192,224,256,320,0}, // Layer III
    311                  {0, 32, 48, 56, 64, 80, 96,112,128,160,192,224,256,320,384,0}, // Layer II
    312                  {0, 32, 64, 96,128,160,192,224,256,288,320,352,384,416,448,0}  // Layer I
    313                }
    314              };
   \                     ??getBitrate_1:
   \   000000BC   50109FE5           LDR      R1,??getBitrate_2  ;; `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`
   \   000000C0   0D00A0E1           MOV      R0,SP
   \   000000C4   603FA0E3           MOV      R3,#+384
   \                     ??getBitrate_3:
   \   000000C8   043053E2           SUBS     R3,R3,#+4
   \   000000CC   032091E7           LDR      R2,[R1, R3]
   \   000000D0   032080E7           STR      R2,[R0, R3]
   \   000000D4   FBFFFF1A           BNE      ??getBitrate_3
    315              
    316              return table[getVersionIndex() & 1][getLayerIndex()-1][getBitrateIndex()];
   \   000000D8   040096E5           LDR      R0,[R6, #+4]
   \   000000DC   0F10A0E3           MOV      R1,#+15
   \   000000E0   201601E0           AND      R1,R1,R0, LSR #+12
   \   000000E4   0320A0E3           MOV      R2,#+3
   \   000000E8   A02802E0           AND      R2,R2,R0, LSR #+17
   \   000000EC   0130A0E3           MOV      R3,#+1
   \   000000F0   A00903E0           AND      R0,R3,R0, LSR #+19
   \   000000F4   C030A0E3           MOV      R3,#+192
   \   000000F8   0D60A0E1           MOV      R6,SP
   \   000000FC   936020E0           MLA      R0,R3,R0,R6
   \   00000100   020380E0           ADD      R0,R0,R2, LSL #+6
   \   00000104   010180E0           ADD      R0,R0,R1, LSL #+2
   \   00000108   400010E5           LDR      R0,[R0, #-64]
   \   0000010C   60DF8DE2           ADD      SP,SP,#+384
   \   00000110   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??getBitrate_2:
   \   00000114   ........           DC32     `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`
    317            }
    318          };
    319          

   \                                 In segment CODE, align 4, keep-with-next
    320          int getMode() 
    321          {
    322            switch(getModeIndex()) 
   \                     ??getMode:
   \   00000000   ........           LDR      R0,??DataTable23  ;; lngFileSize + 4
   \   00000004   0310A0E3           MOV      R1,#+3
   \   00000008   000090E5           LDR      R0,[R0, #+0]
   \   0000000C   200301E0           AND      R0,R1,R0, LSR #+6
   \   00000010   010050E2           SUBS     R0,R0,#+1
   \   00000014   0500000A           BEQ      ??getMode_1
   \   00000018   010050E2           SUBS     R0,R0,#+1
   \   0000001C   0500000A           BEQ      ??getMode_2
   \   00000020   010050E2           SUBS     R0,R0,#+1
   \   00000024   0500000A           BEQ      ??getMode_3
    323            {
    324            default:
    325              return 0;//"Stereo"
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   1EFF2FE1           BX       LR
    326            case 1:
    327              return 1;//"Joint Stereo"
   \                     ??getMode_1:
   \   00000030   0100A0E3           MOV      R0,#+1
   \   00000034   1EFF2FE1           BX       LR
    328            case 2:
    329              return 2;//"Dual Channel"
   \                     ??getMode_2:
   \   00000038   0200A0E3           MOV      R0,#+2
   \   0000003C   1EFF2FE1           BX       LR
    330            case 3:
    331              return 3;//"Single Channel"
   \                     ??getMode_3:
   \   00000040   0300A0E3           MOV      R0,#+3
   \   00000044   1EFF2FE1           BX       LR               ;; return
    332            }
    333          };
    334          

   \                                 In segment CODE, align 4, keep-with-next
    335          int getLengthInSeconds() 
    336          {
    337            int intKiloBitFileSize = (int)((8 * lngFileSize) / 1000);
   \                     ??getLengthInSeconds:
   \   00000000   ........           LDR      R0,??DataTable24  ;; lngFileSize
   \   00000004   2C109FE5           LDR      R1,??getLengthInSeconds_1  ;; 0x10624dd3
   \   00000008   10402DE9           PUSH     {R4,LR}
   \   0000000C   000090E5           LDR      R0,[R0, #+0]
   \   00000010   8001A0E1           LSL      R0,R0,#+3
   \   00000014   9120C3E0           SMULL    R2,R3,R1,R0
   \   00000018   4333A0E1           ASR      R3,R3,#+6
   \   0000001C   A04F83E0           ADD      R4,R3,R0, LSR #+31
    338            return (int)(intKiloBitFileSize/getBitrate());
   \   00000020   ........           BL       ??getBitrate
   \   00000024   0010A0E1           MOV      R1,R0
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     ??div32_a,??rA??div32_a
   \   00000030   0100A0E1           MOV      R0,R1
   \   00000034   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??getLengthInSeconds_1:
   \   00000038   D34D6210           DC32     0x10624dd3
    339          };

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   00408F40           DC32     0x408f4000

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     lngFileSize + 4

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     lngFileSize

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {(2.5), (0.0), (2.0), (1.0)}>`:
   \   00000000   000000000000       DC32 0H, 40040000H, 0H, 0H, 0H, 40000000H, 0H, 3FF00000H
   \              044000000000
   \              000000000000
   \              000000000040
   \              000000000000
   \              F03F        

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {`:
   \   00000000   007D0000803E       DC32 32000, 16000, 8000
   \              0000401F0000
   \   0000000C   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \   00000014   000000000000       DC32 0, 0, 0
   \              000000000000
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \   00000028   22560000C05D       DC32 22050, 24000, 16000
   \              0000803E0000
   \   00000034   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \   0000003C   44AC000080BB       DC32 44100, 48000, 32000
   \              0000007D0000
   \   00000048   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000058   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64`:
   \   00000000   000000000800       DC32 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0, 0
   \              000010000000
   \              180000002000
   \              000028000000
   \              300000003800
   \              000040000000
   \              500000006000
   \              000070000000
   \              800000009000
   \              0000A0000000
   \              000000000000
   \              0000        
   \   00000044   080000001000       DC32 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, 0, 0
   \              000018000000
   \              200000002800
   \              000030000000
   \              380000004000
   \              000050000000
   \              600000007000
   \              000080000000
   \              90000000A000
   \              000000000000
   \              00000000    
   \   00000084   200000003000       DC32 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 0
   \              000038000000
   \              400000005000
   \              000060000000
   \              700000008000
   \              000090000000
   \              A0000000B000
   \              0000C0000000
   \              E00000000001
   \              000000000000
   \   000000C0   000000002000       DC32 0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
   \              000028000000
   \              300000003800
   \              000040000000
   \              500000006000
   \              000070000000
   \              80000000A000
   \              0000C0000000
   \              E00000000001
   \              000040010000
   \   000000FC   000000000000       DC32 0, 0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320
   \              000020000000
   \              300000003800
   \              000040000000
   \              500000006000
   \              000070000000
   \              80000000A000
   \              0000C0000000
   \              E00000000001
   \              000040010000
   \   00000138   800100000000       DC32 384, 0, 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384
   \              000000000000
   \              200000004000
   \              000060000000
   \              80000000A000
   \              0000C0000000
   \              E00000000001
   \              000020010000
   \              400100006001
   \              000080010000
   \   00000174   A0010000C001       DC32 416, 448, 0
   \              000000000000
    340          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     IsValidHeader()                    0
     LoadMP3Header(byte *)              0
     LoadVBRHeader(byte *)              0
     ReadMP3Information(wchar_t *, wchar_t *)
                                      196
     getBitrate()                     408
     getBitrateIndex()                  0
     getCoprightBit()                   0
     getEmphasisIndex()                 0
     getFrameSync()                     0
     getFrequency()                   100
     getFrequencyIndex()                0
     getLayer()                         0
     getLayerIndex()                    0
     getLengthInSeconds()               8
     getMode()                          0
     getModeExtIndex()                  0
     getModeIndex()                     0
     getNumberOfFrames()               28
     getOrginalBit()                    0
     getPaddingBit()                    0
     getPrivateBit()                    0
     getProtectionBit()                 0
     getVersion()                      52
     getVersionIndex()                  0
     synchsafeToNormal(char *)          8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     synchsafeToNormal(char *)       116
     lngFileSize                      13
     ReadMP3Information(wchar_t *, wchar_t *)
                                     496
     LoadMP3Header(byte *)            44
     LoadVBRHeader(byte *)           116
     getFrameSync()                   16
     getVersionIndex()                20
     getLayerIndex()                  20
     getProtectionBit()               20
     getBitrateIndex()                20
     getFrequencyIndex()              20
     getPaddingBit()                  20
     getPrivateBit()                  20
     getModeIndex()                   20
     getModeExtIndex()                20
     getCoprightBit()                 20
     getOrginalBit()                  20
     getEmphasisIndex()               16
     getVersion()                     68
     getLayer()                       24
     IsValidHeader()                 104
     getFrequency()                   84
     getNumberOfFrames()             180
     getBitrate()                    280
     getMode()                        72
     getLengthInSeconds()             60
     ??DataTable22                     4
     ??DataTable23                     4
     ??DataTable24                     4
     ?<Constant {(2.5), (0.0), (2.0), (1.0)}>
                                      32
     ?<Constant {{32000, 16000, 8000}, {0, 0, 0}, {
                                     100
     ?<Constant {{{0, 8, 16, 24, 32, 40, 48, 56, 64
                                     384
      Others                         220

 
 2 116 bytes in segment CODE
   516 bytes in segment DATA_C
    13 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 1 908 bytes of CODE  memory (+ 220 bytes shared)
   516 bytes of CONST memory
    13 bytes of DATA  memory

Errors: none
Warnings: none
