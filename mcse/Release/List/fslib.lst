##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Jun/2013  22:47:03 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\fslib.cpp #
#    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\fslib.cpp #
#                        -D NDEBUG -D USEZLIB -D OLDFUNCTIONS -lCN           #
#                       Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\ -la Z:\home\perk11\www\perk11.info\svn\SE\mcse\ #
#                       Release\List\ -o Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\Release\Obj\ -s9 --no_unroll                 #
#                       --no_code_motion --cpu_mode arm --endian little      #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --enable_multibytes --fpu None --eec++               #
#                       --dlib_config Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8 #
#                       n.h --preinclude Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\..\deleaker\mem2.h -I                        #
#                       Z:\home\perk11\IAR2\arm\INC\ --inline_threshold=2    #
#    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\fslib.lst                                        #
#    Object file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\O #
#                       bj\fslib.r79                                         #
#                                                                            #
#                                                                            #
##############################################################################

Z:\home\perk11\www\perk11.info\svn\SE\mcse\fslib.cpp
      1          #include "inc\mc.h"
      2          #include "inc\mui.h"
      3          #include "inc\file_op.h"
      4          
      5          //File Name

   \                                 In segment CODE, align 4, keep-with-next
      6          wchar_t* GetFileExt(wchar_t* fname)
      7          {
   \                     ??GetFileExt:
   \   00000000   00402DE9           PUSH     {LR}
      8            wchar_t *s1, *s2;
      9            s1=wstrrchr(fname,'.');
   \   00000004   2E10A0E3           MOV      R1,#+46
   \   00000008   AE0100EF           SWI      +430
     10            if (s1)
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   0080BD08           POPEQ    {PC}
     11            {
     12              int i=0;
   \   00000014   0010A0E3           MOV      R1,#+0
     13              s2=++s1;       
   \   00000018   020080E2           ADD      R0,R0,#+2
   \   0000001C   0020A0E1           MOV      R2,R0
   \   00000020   000000EA           B        ??GetFileExt_1
     14              while(*s2++) i++;
   \                     ??GetFileExt_2:
   \   00000024   011081E2           ADD      R1,R1,#+1
   \                     ??GetFileExt_1:
   \   00000028   ........           LDRH     R3,[R2], #+2
   \   0000002C   000053E3           CMP      R3,#+0
   \   00000030   FBFFFF1A           BNE      ??GetFileExt_2
     15              if (i>MAX_EXT) s1=0;
   \   00000034   090051E3           CMP      R1,#+9
   \   00000038   0000A0A3           MOVGE    R0,#+0
     16            }
     17            return (s1);
   \   0000003C   0080BDE8           POP      {PC}             ;; return
     18          }
     19          

   \                                 In segment CODE, align 4, keep-with-next
     20          wchar_t* GetFileName(wchar_t* fname)
     21          {
   \                     ??GetFileName:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     22            int len = wstrlen(fname);
     23            int ii;
     24            for(ii = len-1; ii >= 0; ii--) {
   \   00000008   570100EF           SWI      +343
   \   0000000C   070000EA           B        ??GetFileName_1
     25              if (fname[ii] == '\\' || fname[ii] == '/') break;
   \                     ??GetFileName_2:
   \   00000010   801084E0           ADD      R1,R4,R0, LSL #+1
   \   00000014   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000018   5C0051E3           CMP      R1,#+92
   \   0000001C   0800000A           BEQ      ??GetFileName_3
   \   00000020   801084E0           ADD      R1,R4,R0, LSL #+1
   \   00000024   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000028   2F0051E3           CMP      R1,#+47
   \   0000002C   0400000A           BEQ      ??GetFileName_3
     26            }
   \                     ??GetFileName_1:
   \   00000030   010040E2           SUB      R0,R0,#+1
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   F4FFFF5A           BPL      ??GetFileName_2
     27            if (ii>=0) return fname+ii+1;
     28            return fname;
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   1080BDE8           POP      {R4,PC}
   \                     ??GetFileName_3:
   \   00000044   800084E0           ADD      R0,R4,R0, LSL #+1
   \   00000048   020080E2           ADD      R0,R0,#+2
   \   0000004C   1080BDE8           POP      {R4,PC}          ;; return
     29          }
     30          
     31          

   \                                 In segment CODE, align 4, keep-with-next
     32          wchar_t* GetFileDir(wchar_t* fname, wchar_t* buf, int is_arch)
     33          {
   \                     ??GetFileDir:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     34            int c;
     35            wchar_t *s=fname;
     36            int len=0;
     37            int i=0;
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0010A0E1           MOV      R1,R0
   \   00000010   0050A0E3           MOV      R5,#+0
   \   00000014   060000EA           B        ??GetFileDir_1
     38            while((c=*s++))
     39            {
     40              if ((c=='\\' || c=='/') && *s!=0)  len=i;
   \                     ??GetFileDir_2:
   \   00000018   5C005CE3           CMP      R12,#+92
   \   0000001C   2F005C13           CMPNE    R12,#+47
   \   00000020   0200001A           BNE      ??GetFileDir_3
   \   00000024   B0C0D1E1           LDRH     R12,[R1, #+0]
   \   00000028   00005CE3           CMP      R12,#+0
   \   0000002C   0350A011           MOVNE    R5,R3
     41              i++;
   \                     ??GetFileDir_3:
   \   00000030   013083E2           ADD      R3,R3,#+1
     42            }
   \                     ??GetFileDir_1:
   \   00000034   ........           LDRH     R12,[R1], #+2
   \   00000038   00005CE3           CMP      R12,#+0
   \   0000003C   F5FFFF1A           BNE      ??GetFileDir_2
     43            if (buf)
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   0B00000A           BEQ      ??GetFileDir_4
     44            {
     45              if (!len && !is_arch) len=1;
   \   00000048   000055E3           CMP      R5,#+0
   \   0000004C   0200001A           BNE      ??GetFileDir_5
   \   00000050   000052E3           CMP      R2,#+0
   \   00000054   0400001A           BNE      ??GetFileDir_6
   \   00000058   0150A0E3           MOV      R5,#+1
     46              if (len)
     47              {
     48                wstrncpy(buf,fname,len);
   \                     ??GetFileDir_5:
   \   0000005C   0520A0E1           MOV      R2,R5
   \   00000060   0010A0E1           MOV      R1,R0
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   530100EF           SWI      +339
     49              }
     50              buf[len]=0;    
   \                     ??GetFileDir_6:
   \   0000006C   850084E0           ADD      R0,R4,R5, LSL #+1
   \   00000070   0010A0E3           MOV      R1,#+0
   \   00000074   B010C0E1           STRH     R1,[R0, #+0]
     51            }
     52            return (buf);
   \                     ??GetFileDir_4:
   \   00000078   0400A0E1           MOV      R0,R4
   \   0000007C   3080BDE8           POP      {R4,R5,PC}       ;; return
     53          }
     54          

   \                                 In segment CODE, align 4, keep-with-next
     55          int fexists(wchar_t* fname)
     56          {
   \                     ??fexists:
   \   00000000   00402DE9           PUSH     {LR}
   \   00000004   28D04DE2           SUB      SP,SP,#+40
     57            W_FSTAT fs;
     58            return (w_fstat(fname,&fs)!=-1);
   \   00000008   0D10A0E1           MOV      R1,SP
   \   0000000C   F90200EF           SWI      +761
   \   00000010   010070E3           CMN      R0,#+1
   \   00000014   0100A013           MOVNE    R0,#+1
   \   00000018   0000A003           MOVEQ    R0,#+0
   \   0000001C   28D08DE2           ADD      SP,SP,#+40
   \   00000020   0080BDE8           POP      {PC}             ;; return
     59          }
     60          
     61          

   \                                 In segment CODE, align 4, keep-with-next
     62          int rmtree(wchar_t* path, int ip)
     63          {
   \                     ??rmtree:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0140A0E1           MOV      R4,R1
     64            FN_LIST fnlist;
     65            fn_zero(&fnlist);
   \   00000010   0D00A0E1           MOV      R0,SP
   \   00000014   ........           _BLF     ??fn_zero,??fn_zero??rA
     66            fn_fill(&fnlist, path);
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   ........           _BLF     ??fn_fill,??fn_fill??rA
     67            fn_rev(&fnlist);
   \   00000024   0D00A0E1           MOV      R0,SP
   \   00000028   ........           _BLF     ??fn_rev,??fn_rev??rA
     68            
     69            int res = 1;
     70            FN_ITM *itm = fnlist.items;
   \   0000002C   08609DE5           LDR      R6,[SP, #+8]
   \   00000030   0150A0E3           MOV      R5,#+1
   \   00000034   050000EA           B        ??rmtree_1
     71            while(itm && !progr_stop)
     72            {
     73              switch (itm->ftype)
   \                     ??rmtree_2:
   \   00000038   055000E0           AND      R5,R0,R5
     74              {
     75              case TYPE_COMMON_DIR:
     76                res &= (!w_remove(itm->full));
     77                break;
     78              case TYPE_COMMON_FILE:
     79                res &= (!w_remove(itm->full));
     80                break;
     81              case TYPE_ZIP_DIR:
     82              case TYPE_ZIP_FILE:
     83              default:
     84                break;
     85              }
     86              itm=(FN_ITM *)itm->next;
   \                     ??rmtree_3:
   \   0000003C   0C6096E5           LDR      R6,[R6, #+12]
     87              if (ip) incprogr(1);
   \   00000040   000054E3           CMP      R4,#+0
   \   00000044   0100000A           BEQ      ??rmtree_1
   \   00000048   0100A0E3           MOV      R0,#+1
   \   0000004C   ........           _BLF     ??incprogr,??incprogr??rA
   \                     ??rmtree_1:
   \   00000050   000056E3           CMP      R6,#+0
   \   00000054   0E00000A           BEQ      ??rmtree_4
   \   00000058   ........           LDR      R0,??DataTable5  ;; progr_stop
   \   0000005C   000090E5           LDR      R0,[R0, #+0]
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   0A00001A           BNE      ??rmtree_4
   \   00000068   000096E5           LDR      R0,[R6, #+0]
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0100000A           BEQ      ??rmtree_5
   \   00000074   010050E2           SUBS     R0,R0,#+1
   \   00000078   EFFFFF1A           BNE      ??rmtree_3
   \                     ??rmtree_5:
   \   0000007C   080096E5           LDR      R0,[R6, #+8]
   \   00000080   300300EF           SWI      +816
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0000A013           MOVNE    R0,#+0
   \   0000008C   0100A003           MOVEQ    R0,#+1
   \   00000090   E8FFFFEA           B        ??rmtree_2
     88            }
     89            fn_free(&fnlist);
   \                     ??rmtree_4:
   \   00000094   0D00A0E1           MOV      R0,SP
   \   00000098   ........           _BLF     ??fn_free,??fn_free??rA
     90            return res;
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   7E80BDE8           POP      {R1-R6,PC}       ;; return
     91          }

   \                                 In segment CODE, align 4, keep-with-next
     92          int fsrm(wchar_t* path, int ip)
     93          {
   \                     ??fsrm:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     94            int res;
     95            if (isdir(path))
   \   0000000C   ........           _BLF     ??isdir,??isdir??rA
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0500000A           BEQ      ??fsrm_1
     96              res= rmtree(path, ip);
   \   00000018   0510A0E1           MOV      R1,R5
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   ........           BL       ??rmtree
   \   00000024   0040A0E1           MOV      R4,R0
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   3080BDE8           POP      {R4,R5,PC}
     97            else
     98            {
     99              res=!w_remove(path);
   \                     ??fsrm_1:
   \   00000030   0400A0E1           MOV      R0,R4
   \   00000034   300300EF           SWI      +816
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0140A003           MOVEQ    R4,#+1
   \   00000040   0040A013           MOVNE    R4,#+0
    100              if (ip) incprogr(1);
   \   00000044   000055E3           CMP      R5,#+0
   \   00000048   0100000A           BEQ      ??fsrm_2
   \   0000004C   0100A0E3           MOV      R0,#+1
   \   00000050   ........           _BLF     ??incprogr,??incprogr??rA
    101            }
    102            return res;
   \                     ??fsrm_2:
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   3080BDE8           POP      {R4,R5,PC}       ;; return
    103          }
    104          
    105          #define BUF_SIZE 0x4000

   \                                 In segment CODE, align 4, keep-with-next
    106          int fcopy(wchar_t* src, wchar_t* dst)
    107          {
   \                     ??fcopy:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0140A0E1           MOV      R4,R1
    108            int fi=-1, fo=-1;
    109            char* buff=0;
   \   00000008   0050A0E3           MOV      R5,#+0
    110            int cb, left;
    111            int res = 0;
   \   0000000C   0060A0E3           MOV      R6,#+0
    112            //int attr=0;
    113            
    114           // if (CONFIG_CONFIRM_REPLACE && fexists(dst))
    115           // {
    116           //   if (MsgBoxYesNoWithParam(ind_pmt_exists, 0) != IDYES)
    117           //     return 1; // Все хорошо, если не стали перезаписывать
    118           // }
    119            fi = w_fopen(src, WA_Read, 0x1FF, 0);
   \   00000010   0530A0E1           MOV      R3,R5
   \   00000014   FF20A0E3           MOV      R2,#+255
   \   00000018   402F82E3           ORR      R2,R2,#0x100
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   F80200EF           SWI      +760
   \   00000024   0070B0E1           MOVS     R7,R0
    120            if (fi >=0) 
   \   00000028   3800004A           BMI      ??fcopy_1
    121            {
    122              fo = w_fopen(dst, WA_Read+WA_Write+WA_Create+WA_Truncate, 0x1FF, 0);
   \   0000002C   0030A0E3           MOV      R3,#+0
   \   00000030   FF20A0E3           MOV      R2,#+255
   \   00000034   402F82E3           ORR      R2,R2,#0x100
   \   00000038   4B10A0E3           MOV      R1,#+75
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   F80200EF           SWI      +760
   \   00000044   0040B0E1           MOVS     R4,R0
    123              if (fo >=0) 
   \   00000048   2E00004A           BMI      ??fcopy_2
    124              {
    125                left = w_lseek(fi, 0, WSEEK_END);
   \   0000004C   0120A0E3           MOV      R2,#+1
   \   00000050   0010A0E3           MOV      R1,#+0
   \   00000054   0700A0E1           MOV      R0,R7
   \   00000058   FC0200EF           SWI      +764
   \   0000005C   0080A0E1           MOV      R8,R0
    126                w_lseek(fi, 0, WSEEK_SET);
   \   00000060   0220A0E3           MOV      R2,#+2
   \   00000064   0510A0E1           MOV      R1,R5
   \   00000068   0700A0E1           MOV      R0,R7
   \   0000006C   FC0200EF           SWI      +764
    127                if (left)
   \   00000070   000058E3           CMP      R8,#+0
   \   00000074   1900000A           BEQ      ??fcopy_3
    128                {
    129                  buff = new char[BUF_SIZE];
   \   00000078   400CA0E3           MOV      R0,#+16384
   \   0000007C   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000080   0050B0E1           MOVS     R5,R0
    130                  if (!buff) goto L_EXIT;
   \   00000084   1900000A           BEQ      ??fcopy_4
    131                  progrsp_max = left;
   \   00000088   88009FE5           LDR      R0,??fcopy_5     ;; progrsp_max
   \   0000008C   008080E5           STR      R8,[R0, #+0]
    132                  incprogrsp(0);
   \   00000090   0000A0E3           MOV      R0,#+0
   \   00000094   ........           _BLF     ??incprogrsp,??incprogrsp??rA
    133                }
    134                while (left) 
    135                {
    136                  cb = left < BUF_SIZE ? left : BUF_SIZE;
   \                     ??fcopy_6:
   \   00000098   400C58E3           CMP      R8,#+16384
   \   0000009C   0890A0B1           MOVLT    R9,R8
   \   000000A0   409CA0A3           MOVGE    R9,#+16384
    137                  left -= cb;
   \   000000A4   098048E0           SUB      R8,R8,R9
    138                  incprogrsp(cb);
   \   000000A8   0900A0E1           MOV      R0,R9
   \   000000AC   ........           _BLF     ??incprogrsp,??incprogrsp??rA
    139                  if (w_fread(fi, buff, cb) != cb) goto L_EXIT;
   \   000000B0   0920A0E1           MOV      R2,R9
   \   000000B4   0510A0E1           MOV      R1,R5
   \   000000B8   0700A0E1           MOV      R0,R7
   \   000000BC   FB0200EF           SWI      +763
   \   000000C0   090050E1           CMP      R0,R9
   \   000000C4   0900001A           BNE      ??fcopy_4
    140                  if (w_fwrite(fo, buff, cb) != cb) goto L_EXIT;
   \   000000C8   0920A0E1           MOV      R2,R9
   \   000000CC   0510A0E1           MOV      R1,R5
   \   000000D0   0400A0E1           MOV      R0,R4
   \   000000D4   FA0200EF           SWI      +762
   \   000000D8   090050E1           CMP      R0,R9
   \   000000DC   0300001A           BNE      ??fcopy_4
    141                }
   \                     ??fcopy_3:
   \   000000E0   000058E3           CMP      R8,#+0
   \   000000E4   EBFFFF1A           BNE      ??fcopy_6
    142                endprogrsp();
   \   000000E8   ........           _BLF     ??endprogrsp,??endprogrsp??rA
    143                res = 1;
   \   000000EC   0160A0E3           MOV      R6,#+1
    144                WriteLog("fcopy. OK");
    145              }
    146            }
    147          L_EXIT:
    148            if (buff) delete(buff);
   \                     ??fcopy_4:
   \   000000F0   000055E3           CMP      R5,#+0
   \   000000F4   0100000A           BEQ      ??fcopy_7
   \   000000F8   0500A0E1           MOV      R0,R5
   \   000000FC   ........           _BLF     `??operator delete`,`??operator delete??rA`
    149            if (fo>=0) w_fclose(fo);
   \                     ??fcopy_7:
   \   00000100   0400A0E1           MOV      R0,R4
   \   00000104   FD0200EF           SWI      +765
    150            if (fi>=0) w_fclose(fi);
   \                     ??fcopy_2:
   \   00000108   0700A0E1           MOV      R0,R7
   \   0000010C   FD0200EF           SWI      +765
    151            return res;
   \                     ??fcopy_1:
   \   00000110   0600A0E1           MOV      R0,R6
   \   00000114   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??fcopy_5:
   \   00000118   ........           DC32     progrsp_max
    152          }
    153          

   \                                 In segment DATA_C, align 4, align-sorted
    154          const wchar_t badchars[] = {'?', '*', '"', ':', '<', '>', '/', '\\', '|', '\n', '\r'};
   \                     badchars:
   \   00000000   3F002A002200       DC16 63, 42, 34, 58, 60, 62, 47, 92, 124, 10, 13
   \              3A003C003E00
   \              2F005C007C00
   \              0A000D00    
   \   00000016   0000               DC8 0, 0
    155          

   \                                 In segment CODE, align 4, keep-with-next
    156          int _IsBadChar(wchar_t wch)
    157          {
    158            for(int cc = 0; cc < sizeof(badchars)/sizeof(wchar_t); cc++)
   \                     ??_IsBadChar:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   000000EA           B        ??_IsBadChar_1
   \                     ??_IsBadChar_2:
   \   00000008   011081E2           ADD      R1,R1,#+1
   \                     ??_IsBadChar_1:
   \   0000000C   0B0051E3           CMP      R1,#+11
   \   00000010   0600002A           BCS      ??_IsBadChar_3
    159              if (badchars[cc] == wch) return 1;
   \   00000014   1C209FE5           LDR      R2,??_IsBadChar_4  ;; badchars
   \   00000018   812082E0           ADD      R2,R2,R1, LSL #+1
   \   0000001C   B020D2E1           LDRH     R2,[R2, #+0]
   \   00000020   000052E1           CMP      R2,R0
   \   00000024   F7FFFF1A           BNE      ??_IsBadChar_2
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   1EFF2FE1           BX       LR
    160            return 0;  
   \                     ??_IsBadChar_3:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1EFF2FE1           BX       LR               ;; return
   \                     ??_IsBadChar_4:
   \   00000038   ........           DC32     badchars
    161          }
    162          

   \                                 In segment CODE, align 4, keep-with-next
    163          int TestFileName(wchar_t* wsname)
    164          {
   \                     ??TestFileName:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    165            wchar_t wchar;
    166            while((wchar=*wsname++))
   \                     ??TestFileName_1:
   \   00000008   ........           LDRH     R1,[R4], #+2
   \   0000000C   0100B0E1           MOVS     R0,R1
   \   00000010   0400000A           BEQ      ??TestFileName_2
    167            {
    168              if (_IsBadChar(wchar)) return 0;
   \   00000014   ........           BL       ??_IsBadChar
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   F9FFFF0A           BEQ      ??TestFileName_1
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   1080BDE8           POP      {R4,PC}
    169            }
    170            return 1;
   \                     ??TestFileName_2:
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   1080BDE8           POP      {R4,PC}          ;; return
    171          }
    172          

   \                                 In segment CODE, align 4, keep-with-next
    173          void CorFileName(wchar_t* wsname)
    174          {
   \                     ??CorFileName:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    175            wchar_t wchar;
    176            int i=0;
   \   00000008   0050A0E3           MOV      R5,#+0
   \   0000000C   040000EA           B        ??CorFileName_1
    177            while((wchar=*wsname++))
    178            {
    179              if (!_IsBadChar(wchar)) 
   \                     ??CorFileName_2:
   \   00000010   ........           BL       ??_IsBadChar
   \   00000014   000050E3           CMP      R0,#+0
    180                wsname[i++]=wchar;
   \   00000018   85008400           ADDEQ    R0,R4,R5, LSL #+1
   \   0000001C   B060C001           STRHEQ   R6,[R0, #+0]
   \   00000020   01508502           ADDEQ    R5,R5,#+1
    181            }
   \                     ??CorFileName_1:
   \   00000024   ........           LDRH     R0,[R4], #+2
   \   00000028   0060B0E1           MOVS     R6,R0
   \   0000002C   F7FFFF1A           BNE      ??CorFileName_2
    182            wsname[i]=0;
   \   00000030   850084E0           ADD      R0,R4,R5, LSL #+1
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   B010C0E1           STRH     R1,[R0, #+0]
    183          }
   \   0000003C   7080BDE8           POP      {R4-R6,PC}       ;; return
    184          
    185          typedef struct {
    186            wchar_t *name;
    187            W_FSTAT fs;
    188            int is_first;
    189          } W_FIND;
    190          
    191          
    192          
    193          
    194          

   \                                 In segment CODE, align 4, keep-with-next
    195          int EnumFilesInDir(wchar_t* dname, ENUM_FILES_PROC enumproc, unsigned int param, int recursive, int enumDirs)
    196          {
   \                     ??EnumFilesInDir:
   \   00000000   FE4F2DE9           PUSH     {R1-R11,LR}
   \   00000004   60D04DE2           SUB      SP,SP,#+96
   \   00000008   0040A0E1           MOV      R4,R0
    197            unsigned int ccFiles   = 0;
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   00008DE5           STR      R0,[SP, #+0]
    198            unsigned int ccSubDirs = 0;
   \   00000014   04008DE5           STR      R0,[SP, #+4]
    199            LIST *lst=List_Create();
   \   00000018   690100EF           SWI      +361
   \   0000001C   0050B0E1           MOVS     R5,R0
    200            W_FIND local, *t;
    201            if (lst)
   \   00000020   8600000A           BEQ      ??EnumFilesInDir_1
    202            {
    203              local.is_first=1;
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   34108DE5           STR      R1,[SP, #+52]
    204              local.name=dname;
   \   0000002C   08408DE5           STR      R4,[SP, #+8]
    205              List_InsertFirst(lst, &local);
   \   00000030   08108DE2           ADD      R1,SP,#+8
   \   00000034   6B0100EF           SWI      +363
    206              for (int i=0; i<lst->FirstFree; i++)
   \   00000038   B200D5E1           LDRH     R0,[R5, #+2]
   \   0000003C   0070A0E3           MOV      R7,#+0
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   2200001A           BNE      ??EnumFilesInDir_2
    207              {
    208                W_FIND *cur=(W_FIND *)List_Get(lst,i);
    209                if (cur->is_first || ((cur->fs.attr & FA_DIRECTORY) && recursive))
    210                {
    211                  wchar_t *dir=cur->name;
    212                  void *handle=w_diropen(dir);
    213                  if (handle)
    214                  {
    215                    wchar_t *next;
    216                    w_chdir(dir);
    217                    int f;
    218                    while((next=w_dirread(handle)))
    219                    {
    220                      W_FSTAT fs;
    221                      w_fstat(next,&fs);
    222                      if (fs.attr & FA_DIRECTORY)
    223                      {
    224                        if (enumDirs) f=1;
    225                      }
    226                      else f=1;
    227                      if (f)
    228                      {
    229                        t=new W_FIND;
    230                        int len=wstrlen(dir)+wstrlen(next)+1;
    231                        t->is_first=0;
    232                        t->name=new wchar_t[len+1];
    233                        snwprintf(t->name, len,_ls_ls, dir, next);
    234                        memcpy(&t->fs,&fs,sizeof(W_FSTAT));
    235                        List_InsertLast(lst, t);
    236                      }
    237                    }
    238                    w_dirclose(handle);
    239                  }
    240                }
    241              }
    242              int ex=0;
   \                     ??EnumFilesInDir_3:
   \   00000048   B200D5E1           LDRH     R0,[R5, #+2]
   \   0000004C   0040A0E3           MOV      R4,#+0
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   7900000A           BEQ      ??EnumFilesInDir_1
    243              while(lst->FirstFree)
    244              {
    245                t=(W_FIND *)List_RemoveAt(lst,lst->FirstFree-1);
   \                     ??EnumFilesInDir_4:
   \   00000058   B200D5E1           LDRH     R0,[R5, #+2]
   \   0000005C   011040E2           SUB      R1,R0,#+1
   \   00000060   0500A0E1           MOV      R0,R5
   \   00000064   790100EF           SWI      +377
   \   00000068   0060A0E1           MOV      R6,R0
    246                if (!t->is_first)  // первую не обрабатываем
   \   0000006C   2C0096E5           LDR      R0,[R6, #+44]
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   6E00001A           BNE      ??EnumFilesInDir_5
    247                {
    248                  if (!ex)
   \   00000078   000054E3           CMP      R4,#+0
   \   0000007C   6800001A           BNE      ??EnumFilesInDir_6
    249                  {
    250                    if (!(t->fs.attr & FA_DIRECTORY) || enumDirs)
   \   00000080   040096E5           LDR      R0,[R6, #+4]
   \   00000084   400C10E3           TST      R0,#0x4000
   \   00000088   0200000A           BEQ      ??EnumFilesInDir_7
   \   0000008C   90009DE5           LDR      R0,[SP, #+144]
   \   00000090   000050E3           CMP      R0,#+0
   \   00000094   6200000A           BEQ      ??EnumFilesInDir_6
    251                    {
    252                      wchar_t *name=wstrrchr(t->name,L'/');
   \                     ??EnumFilesInDir_7:
   \   00000098   000096E5           LDR      R0,[R6, #+0]
   \   0000009C   2F10A0E3           MOV      R1,#+47
   \   000000A0   AE0100EF           SWI      +430
    253                      if (name)
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   5D00000A           BEQ      ??EnumFilesInDir_6
    254                      {
    255                        t->fs.attr&FA_DIRECTORY?ccSubDirs++:ccFiles++;
   \   000000AC   041096E5           LDR      R1,[R6, #+4]
   \   000000B0   400C11E3           TST      R1,#0x4000
   \   000000B4   4A00000A           BEQ      ??EnumFilesInDir_8
   \   000000B8   04209DE5           LDR      R2,[SP, #+4]
   \   000000BC   012082E2           ADD      R2,R2,#+1
   \   000000C0   04208DE5           STR      R2,[SP, #+4]
   \   000000C4   490000EA           B        ??EnumFilesInDir_9
   \                     ??EnumFilesInDir_10:
   \   000000C8   0900A0E1           MOV      R0,R9
   \   000000CC   2E0300EF           SWI      +814
   \                     ??EnumFilesInDir_11:
   \   000000D0   017087E2           ADD      R7,R7,#+1
   \                     ??EnumFilesInDir_2:
   \   000000D4   B200D5E1           LDRH     R0,[R5, #+2]
   \   000000D8   000057E1           CMP      R7,R0
   \   000000DC   D9FFFFAA           BGE      ??EnumFilesInDir_3
   \   000000E0   0710A0E1           MOV      R1,R7
   \   000000E4   0500A0E1           MOV      R0,R5
   \   000000E8   AD0100EF           SWI      +429
   \   000000EC   2C1090E5           LDR      R1,[R0, #+44]
   \   000000F0   000051E3           CMP      R1,#+0
   \   000000F4   0400001A           BNE      ??EnumFilesInDir_12
   \   000000F8   041090E5           LDR      R1,[R0, #+4]
   \   000000FC   400C11E3           TST      R1,#0x4000
   \   00000100   68109D15           LDRNE    R1,[SP, #+104]
   \   00000104   00005113           CMPNE    R1,#+0
   \   00000108   F0FFFF0A           BEQ      ??EnumFilesInDir_11
   \                     ??EnumFilesInDir_12:
   \   0000010C   008090E5           LDR      R8,[R0, #+0]
   \   00000110   0800A0E1           MOV      R0,R8
   \   00000114   2C0300EF           SWI      +812
   \   00000118   0090B0E1           MOVS     R9,R0
   \   0000011C   EBFFFF0A           BEQ      ??EnumFilesInDir_11
   \   00000120   0800A0E1           MOV      R0,R8
   \   00000124   F70200EF           SWI      +759
   \   00000128   1F0000EA           B        ??EnumFilesInDir_13
   \                     ??EnumFilesInDir_14:
   \   0000012C   00005AE3           CMP      R10,#+0
   \   00000130   1D00000A           BEQ      ??EnumFilesInDir_13
   \                     ??EnumFilesInDir_15:
   \   00000134   3000A0E3           MOV      R0,#+48
   \   00000138   ........           _BLF     `??operator new`,`??operator new??rA`
   \   0000013C   0060A0E1           MOV      R6,R0
   \   00000140   0800A0E1           MOV      R0,R8
   \   00000144   570100EF           SWI      +343
   \   00000148   00B0A0E1           MOV      R11,R0
   \   0000014C   0400A0E1           MOV      R0,R4
   \   00000150   570100EF           SWI      +343
   \   00000154   0B0080E0           ADD      R0,R0,R11
   \   00000158   01B080E2           ADD      R11,R0,#+1
   \   0000015C   0000A0E3           MOV      R0,#+0
   \   00000160   2C0086E5           STR      R0,[R6, #+44]
   \   00000164   01008BE2           ADD      R0,R11,#+1
   \   00000168   8000A0E1           LSL      R0,R0,#+1
   \   0000016C   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000170   ........           LDR      R2,??DataTable4  ;; _ls_ls
   \   00000174   000086E5           STR      R0,[R6, #+0]
   \   00000178   10002DE9           PUSH     {R4}
   \   0000017C   000096E5           LDR      R0,[R6, #+0]
   \   00000180   0830A0E1           MOV      R3,R8
   \   00000184   0B10A0E1           MOV      R1,R11
   \   00000188   150100EF           SWI      +277
   \   0000018C   2820A0E3           MOV      R2,#+40
   \   00000190   3C108DE2           ADD      R1,SP,#+60
   \   00000194   040086E2           ADD      R0,R6,#+4
   \   00000198   130100EF           SWI      +275
   \   0000019C   0610A0E1           MOV      R1,R6
   \   000001A0   0500A0E1           MOV      R0,R5
   \   000001A4   B00100EF           SWI      +432
   \   000001A8   04D08DE2           ADD      SP,SP,#+4
   \                     ??EnumFilesInDir_13:
   \   000001AC   0900A0E1           MOV      R0,R9
   \   000001B0   2D0300EF           SWI      +813
   \   000001B4   0040B0E1           MOVS     R4,R0
   \   000001B8   C2FFFF0A           BEQ      ??EnumFilesInDir_10
   \   000001BC   38108DE2           ADD      R1,SP,#+56
   \   000001C0   F90200EF           SWI      +761
   \   000001C4   38009DE5           LDR      R0,[SP, #+56]
   \   000001C8   400C10E3           TST      R0,#0x4000
   \   000001CC   0200000A           BEQ      ??EnumFilesInDir_16
   \   000001D0   90009DE5           LDR      R0,[SP, #+144]
   \   000001D4   000050E3           CMP      R0,#+0
   \   000001D8   D3FFFF0A           BEQ      ??EnumFilesInDir_14
   \                     ??EnumFilesInDir_16:
   \   000001DC   01A0A0E3           MOV      R10,#+1
   \   000001E0   D3FFFFEA           B        ??EnumFilesInDir_15
   \                     ??EnumFilesInDir_8:
   \   000001E4   00209DE5           LDR      R2,[SP, #+0]
   \   000001E8   012082E2           ADD      R2,R2,#+1
   \   000001EC   00208DE5           STR      R2,[SP, #+0]
    256                        *name=0;
   \                     ??EnumFilesInDir_9:
   \   000001F0   0010A0E3           MOV      R1,#+0
   \   000001F4   B010C0E1           STRH     R1,[R0, #+0]
    257                        if (enumproc)
   \   000001F8   60109DE5           LDR      R1,[SP, #+96]
   \   000001FC   000051E3           CMP      R1,#+0
   \   00000200   0700000A           BEQ      ??EnumFilesInDir_6
    258                          if (enumproc(t->name, name+1, &t->fs, param)==0)
   \   00000204   64309DE5           LDR      R3,[SP, #+100]
   \   00000208   60709DE5           LDR      R7,[SP, #+96]
   \   0000020C   021080E2           ADD      R1,R0,#+2
   \   00000210   000096E5           LDR      R0,[R6, #+0]
   \   00000214   042086E2           ADD      R2,R6,#+4
   \   00000218   37FF2FE1           BLX      R7
   \   0000021C   000050E3           CMP      R0,#+0
    259                            ex=1;
   \   00000220   0140A003           MOVEQ    R4,#+1
    260                      }
    261                    }
    262                  }
    263                  delete (t->name);
   \                     ??EnumFilesInDir_6:
   \   00000224   000096E5           LDR      R0,[R6, #+0]
   \   00000228   ........           _BLF     `??operator delete`,`??operator delete??rA`
    264                  delete (t);
   \   0000022C   0600A0E1           MOV      R0,R6
   \   00000230   ........           _BLF     `??operator delete`,`??operator delete??rA`
    265                }
    266              }
   \                     ??EnumFilesInDir_5:
   \   00000234   B200D5E1           LDRH     R0,[R5, #+2]
   \   00000238   000050E3           CMP      R0,#+0
   \   0000023C   85FFFF1A           BNE      ??EnumFilesInDir_4
    267            }
    268            List_Destroy(lst);
   \                     ??EnumFilesInDir_1:
   \   00000240   0500A0E1           MOV      R0,R5
   \   00000244   6A0100EF           SWI      +362
    269            if (ccSubDirs > 0xffff) ccSubDirs = 0xffff;
   \   00000248   04009DE5           LDR      R0,[SP, #+4]
   \   0000024C   400B50E3           CMP      R0,#+65536
   \   00000250   FF10A023           MOVCS    R1,#+255
   \   00000254   FF1C8123           ORRCS    R1,R1,#0xFF00
   \   00000258   04108D25           STRCS    R1,[SP, #+4]
    270            if (ccFiles > 0xffff)   ccFiles = 0xffff;
   \   0000025C   00009DE5           LDR      R0,[SP, #+0]
   \   00000260   400B50E3           CMP      R0,#+65536
   \   00000264   FF10A023           MOVCS    R1,#+255
   \   00000268   FF1C8123           ORRCS    R1,R1,#0xFF00
   \   0000026C   00108D25           STRCS    R1,[SP, #+0]
    271            return (ccSubDirs << 16 | ccFiles);
   \   00000270   04009DE5           LDR      R0,[SP, #+4]
   \   00000274   00109DE5           LDR      R1,[SP, #+0]
   \   00000278   6CD08DE2           ADD      SP,SP,#+108
   \   0000027C   000881E1           ORR      R0,R1,R0, LSL #+16
   \   00000280   F08FBDE8           POP      {R4-R11,PC}      ;; return
    272          }
    273          
    274          

   \                                 In segment CODE, align 4, keep-with-next
    275          int EnumFiles(wchar_t* dname, ENUM_FILES_PROC enumproc, unsigned int param)
    276          {
   \                     ??EnumFiles:
   \   00000000   00402DE9           PUSH     {LR}
    277            // Рекурсивно пробегаем и по подкаталогам тоже
    278            return EnumFilesInDir( dname, enumproc, param, 1, 1);
   \   00000004   0130A0E3           MOV      R3,#+1
   \   00000008   08002DE9           PUSH     {R3}
   \   0000000C   ........           BL       ??EnumFilesInDir
   \   00000010   0280BDE8           POP      {R1,PC}          ;; return
    279          }
    280          
    281          

   \                                 In segment CODE, align 4, keep-with-next
    282          int GetFilesCnt(wchar_t* path)
    283          {
   \                     ??GetFilesCnt:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    284            int res=1;
   \   00000008   0150A0E3           MOV      R5,#+1
    285            if (isdir(path))
   \   0000000C   ........           _BLF     ??isdir,??isdir??rA
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0B00000A           BEQ      ??GetFilesCnt_1
    286            {
    287              int sub = EnumFiles(path, NULL, 0);
   \   00000018   0100A0E3           MOV      R0,#+1
   \   0000001C   01002DE9           PUSH     {R0}
   \   00000020   0030A0E1           MOV      R3,R0
   \   00000024   0020A0E3           MOV      R2,#+0
   \   00000028   0210A0E1           MOV      R1,R2
   \   0000002C   0400A0E1           MOV      R0,R4
   \   00000030   ........           BL       ??EnumFilesInDir
    288              res += (sub>>16) + (sub & 0xffff);
   \   00000034   0018A0E1           LSL      R1,R0,#+16
   \   00000038   2118A0E1           LSR      R1,R1,#+16
   \   0000003C   400881E0           ADD      R0,R1,R0, ASR #+16
   \   00000040   015080E2           ADD      R5,R0,#+1
   \   00000044   04D08DE2           ADD      SP,SP,#+4
    289            }
    290            return res;
   \                     ??GetFilesCnt_1:
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   3080BDE8           POP      {R4,R5,PC}       ;; return
    291          }
    292          

   \                                 In segment CODE, align 4, keep-with-next
    293          int mktree(wchar_t* path)
    294          {
   \                     ??mktree:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    295            if (isdir(path)) return 1;
   \   00000008   ........           _BLF     ??isdir,??isdir??rA
   \   0000000C   000050E3           CMP      R0,#+0
   \   00000010   2200001A           BNE      ??mktree_1
    296            int len = wstrlen(path);
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   570100EF           SWI      +343
   \   0000001C   0050A0E1           MOV      R5,R0
    297            int c;
    298            wchar_t *buf=new wchar_t[len+1];
   \   00000020   010085E2           ADD      R0,R5,#+1
   \   00000024   8000A0E1           LSL      R0,R0,#+1
   \   00000028   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   0000002C   0060A0E1           MOV      R6,R0
    299            for(int ii=0;ii<len;ii++)
   \   00000030   0070A0E3           MOV      R7,#+0
   \   00000034   010055E3           CMP      R5,#+1
   \   00000038   0E0000AA           BGE      ??mktree_2
   \   0000003C   0F0000EA           B        ??mktree_3
    300            {
    301              c = path[ii];
   \                     ??mktree_4:
   \   00000040   870084E0           ADD      R0,R4,R7, LSL #+1
   \   00000044   B080D0E1           LDRH     R8,[R0, #+0]
    302              if (c=='/')
   \   00000048   2F0058E3           CMP      R8,#+47
   \   0000004C   0600001A           BNE      ??mktree_5
    303              {
    304                buf[ii]=0;
   \   00000050   870086E0           ADD      R0,R6,R7, LSL #+1
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   B010C0E1           STRH     R1,[R0, #+0]
    305                w_mkdir(buf, 0x1FF);
   \   0000005C   FF10A0E3           MOV      R1,#+255
   \   00000060   401F81E3           ORR      R1,R1,#0x100
   \   00000064   0600A0E1           MOV      R0,R6
   \   00000068   FE0200EF           SWI      +766
    306              }
    307              buf[ii]=c;
   \                     ??mktree_5:
   \   0000006C   870086E0           ADD      R0,R6,R7, LSL #+1
   \   00000070   B080C0E1           STRH     R8,[R0, #+0]
    308            }
   \   00000074   017087E2           ADD      R7,R7,#+1
   \                     ??mktree_2:
   \   00000078   050057E1           CMP      R7,R5
   \   0000007C   EFFFFFBA           BLT      ??mktree_4
    309            delete buf;
   \                     ??mktree_3:
   \   00000080   0600A0E1           MOV      R0,R6
   \   00000084   ........           _BLF     `??operator delete`,`??operator delete??rA`
    310            return !(w_mkdir(path, 0x1FF));
   \   00000088   FF10A0E3           MOV      R1,#+255
   \   0000008C   401F81E3           ORR      R1,R1,#0x100
   \   00000090   0400A0E1           MOV      R0,R4
   \   00000094   FE0200EF           SWI      +766
   \   00000098   000050E3           CMP      R0,#+0
   \   0000009C   0100001A           BNE      ??mktree_6
   \                     ??mktree_1:
   \   000000A0   0100A0E3           MOV      R0,#+1
   \   000000A4   F081BDE8           POP      {R4-R8,PC}
   \                     ??mktree_6:
   \   000000A8   0000A0E3           MOV      R0,#+0
   \   000000AC   F081BDE8           POP      {R4-R8,PC}       ;; return
    311          }
    312          

   \                                 In segment CODE, align 4, keep-with-next
    313          int cptree(wchar_t* src, wchar_t* dst, int ip)
    314          {
   \                     ??cptree:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
    315            FN_LIST fnlist;
    316            fn_zero(&fnlist);
   \   00000014   0D00A0E1           MOV      R0,SP
   \   00000018   ........           _BLF     ??fn_zero,??fn_zero??rA
    317            fn_fill(&fnlist, src);
   \   0000001C   0710A0E1           MOV      R1,R7
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   ........           _BLF     ??fn_fill,??fn_fill??rA
    318            fn_rev(&fnlist);
   \   00000028   0D00A0E1           MOV      R0,SP
   \   0000002C   ........           _BLF     ??fn_rev,??fn_rev??rA
    319            
    320            
    321            wchar_t *dstfull=new wchar_t[MAX_PATH];
   \   00000030   800FA0E3           MOV      R0,#+512
   \   00000034   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000038   0060A0E1           MOV      R6,R0
    322            int psrc = wstrlen(src)+1;
   \   0000003C   0700A0E1           MOV      R0,R7
   \   00000040   570100EF           SWI      +343
   \   00000044   017080E2           ADD      R7,R0,#+1
    323            int res = 1;
    324            //int attr=0;
    325            
    326            int tmp = progr_act;
   \   00000048   24019FE5           LDR      R0,??cptree_1    ;; progr_act
   \   0000004C   0180A0E3           MOV      R8,#+1
   \   00000050   009090E5           LDR      R9,[R0, #+0]
    327            progr_act = ind_dirmking;
   \   00000054   0810A0E3           MOV      R1,#+8
   \   00000058   001080E5           STR      R1,[R0, #+0]
    328            incprogr(-1);
   \   0000005C   000068E2           RSB      R0,R8,#+0
   \   00000060   ........           _BLF     ??incprogr,??incprogr??rA
    329            
    330            FN_ITM *itm = fnlist.items;
   \   00000064   08A09DE5           LDR      R10,[SP, #+8]
   \   00000068   030000EA           B        ??cptree_2
    331            while(itm && !progr_stop)
    332            {
    333              if (itm->ftype == TYPE_COMMON_DIR) // TODO: ZIP_DIR...
    334              {
    335                wchar_t* pdst;
    336                if (itm->full[psrc-1])
    337                {
    338                  wchar_t* psrcname = itm->full+psrc;
    339                  snwprintf(dstfull,MAX_PATH-1, _ls_ls, dst, psrcname);
    340                  pdst = dstfull;
    341                }
    342                else
    343                {
    344                  pdst = dst;
   \                     ??cptree_3:
   \   0000006C   0400A0E1           MOV      R0,R4
    345                }
    346                res &= mktree(pdst);
   \                     ??cptree_4:
   \   00000070   ........           BL       ??mktree
   \   00000074   088000E0           AND      R8,R0,R8
    347                //GetFileAttrib(itm->full, (unsigned char*)&attr, &err);
    348                //SetFileAttrib(pdst, attr, &err);
    349              }
    350              itm=(FN_ITM *)itm->next;
   \                     ??cptree_5:
   \   00000078   0CA09AE5           LDR      R10,[R10, #+12]
   \                     ??cptree_2:
   \   0000007C   00005AE3           CMP      R10,#+0
   \   00000080   1600000A           BEQ      ??cptree_6
   \   00000084   ........           LDR      R0,??DataTable5  ;; progr_stop
   \   00000088   000090E5           LDR      R0,[R0, #+0]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   1200001A           BNE      ??cptree_6
   \   00000094   00009AE5           LDR      R0,[R10, #+0]
   \   00000098   010050E3           CMP      R0,#+1
   \   0000009C   F5FFFF1A           BNE      ??cptree_5
   \   000000A0   08009AE5           LDR      R0,[R10, #+8]
   \   000000A4   870080E0           ADD      R0,R0,R7, LSL #+1
   \   000000A8   B20050E1           LDRH     R0,[R0, #-2]
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   EDFFFF0A           BEQ      ??cptree_3
   \   000000B4   08009AE5           LDR      R0,[R10, #+8]
   \   000000B8   ........           LDR      R2,??DataTable4  ;; _ls_ls
   \   000000BC   870080E0           ADD      R0,R0,R7, LSL #+1
   \   000000C0   01002DE9           PUSH     {R0}
   \   000000C4   0430A0E1           MOV      R3,R4
   \   000000C8   FF10A0E3           MOV      R1,#+255
   \   000000CC   0600A0E1           MOV      R0,R6
   \   000000D0   150100EF           SWI      +277
   \   000000D4   0600A0E1           MOV      R0,R6
   \   000000D8   04D08DE2           ADD      SP,SP,#+4
   \   000000DC   E3FFFFEA           B        ??cptree_4
    351            }
    352            progr_act = tmp;
   \                     ??cptree_6:
   \   000000E0   8C009FE5           LDR      R0,??cptree_1    ;; progr_act
   \   000000E4   009080E5           STR      R9,[R0, #+0]
    353            
    354            itm = fnlist.items;
   \   000000E8   08909DE5           LDR      R9,[SP, #+8]
   \   000000EC   140000EA           B        ??cptree_7
    355            while(itm && !progr_stop)
    356            {
    357              if (itm->ftype == TYPE_COMMON_FILE) // TODO: ZIP_FILE...
   \                     ??cptree_8:
   \   000000F0   000099E5           LDR      R0,[R9, #+0]
   \   000000F4   000050E3           CMP      R0,#+0
   \   000000F8   0C00001A           BNE      ??cptree_9
    358              {
    359                wchar_t* psrcname = itm->full+psrc;
    360                snwprintf(dstfull,MAX_PATH-1, _ls_ls, dst, psrcname);
   \   000000FC   080099E5           LDR      R0,[R9, #+8]
   \   00000100   ........           LDR      R2,??DataTable4  ;; _ls_ls
   \   00000104   870080E0           ADD      R0,R0,R7, LSL #+1
   \   00000108   01002DE9           PUSH     {R0}
   \   0000010C   0430A0E1           MOV      R3,R4
   \   00000110   FF10A0E3           MOV      R1,#+255
   \   00000114   0600A0E1           MOV      R0,R6
   \   00000118   150100EF           SWI      +277
    361                res &= fcopy(itm->full, dstfull);
   \   0000011C   080099E5           LDR      R0,[R9, #+8]
   \   00000120   0610A0E1           MOV      R1,R6
   \   00000124   ........           BL       ??fcopy
   \   00000128   088000E0           AND      R8,R0,R8
   \   0000012C   04D08DE2           ADD      SP,SP,#+4
    362              }
    363              itm=(FN_ITM *)itm->next;
   \                     ??cptree_9:
   \   00000130   0C9099E5           LDR      R9,[R9, #+12]
    364              if (ip) incprogr(1);
   \   00000134   000055E3           CMP      R5,#+0
   \   00000138   0100000A           BEQ      ??cptree_7
   \   0000013C   0100A0E3           MOV      R0,#+1
   \   00000140   ........           _BLF     ??incprogr,??incprogr??rA
    365            }
   \                     ??cptree_7:
   \   00000144   000059E3           CMP      R9,#+0
   \   00000148   0300000A           BEQ      ??cptree_10
   \   0000014C   ........           LDR      R0,??DataTable5  ;; progr_stop
   \   00000150   000090E5           LDR      R0,[R0, #+0]
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   E4FFFF0A           BEQ      ??cptree_8
    366            fn_free(&fnlist);
   \                     ??cptree_10:
   \   0000015C   0D00A0E1           MOV      R0,SP
   \   00000160   ........           _BLF     ??fn_free,??fn_free??rA
    367            delete dstfull;
   \   00000164   0600A0E1           MOV      R0,R6
   \   00000168   ........           _BLF     `??operator delete`,`??operator delete??rA`
    368            return res;
   \   0000016C   0800A0E1           MOV      R0,R8
   \   00000170   FE87BDE8           POP      {R1-R10,PC}      ;; return
   \                     ??cptree_1:
   \   00000174   ........           DC32     progr_act
    369          }
    370          
    371          
    372          typedef struct
    373          {
    374          	int number;
    375          	wchar_t cleanName[MAX_PATH];
    376          	wchar_t* cleanExt;
    377          } ParseFileNameStruct;
    378          

   \                                 In segment CODE, align 4, keep-with-next
    379          void parse_name(wchar_t* fname, ParseFileNameStruct* pfns)
    380          {
   \                     ??parse_name:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    381            pfns->number = 0;
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   000085E5           STR      R0,[R5, #+0]
    382            wstrcpy(pfns->cleanName, fname);
   \   00000014   0410A0E1           MOV      R1,R4
   \   00000018   040085E2           ADD      R0,R5,#+4
   \   0000001C   520100EF           SWI      +338
    383            int fname_len = wstrlen(fname);
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   570100EF           SWI      +343
   \   00000028   0060A0E1           MOV      R6,R0
    384            wchar_t* ps = GetFileExt(pfns->cleanName); // Указатель на расширение
   \   0000002C   040085E2           ADD      R0,R5,#+4
   \   00000030   ........           BL       ??GetFileExt
    385            
    386            if (ps != 0)
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   0300000A           BEQ      ??parse_name_1
    387            {
    388              pfns->cleanExt = ps;
   \   0000003C   040285E5           STR      R0,[R5, #+516]
    389              *(--ps) = '\0';	// Разделяем имя и расширение
   \   00000040   0010A0E3           MOV      R1,#+0
   \   00000044   B21060E1           STRH     R1,[R0, #-2]!
   \   00000048   030000EA           B        ??parse_name_2
    390            }
    391            else
    392            {
    393              // Расширения нет вовсе
    394              pfns->cleanExt = (wchar_t *)str_empty;
   \                     ??parse_name_1:
   \   0000004C   94009FE5           LDR      R0,??parse_name_3  ;; str_empty
   \   00000050   040285E5           STR      R0,[R5, #+516]
    395              ps = pfns->cleanName + fname_len; // Ссылаемся на конец имени
   \   00000054   860085E0           ADD      R0,R5,R6, LSL #+1
   \   00000058   040080E2           ADD      R0,R0,#+4
    396            }
    397            if (ps - pfns->cleanName >= 3) // Должно быть 3 символа как минимум - скобки и число
   \                     ??parse_name_2:
   \   0000005C   A010A0E1           LSR      R1,R0,#+1
   \   00000060   042085E2           ADD      R2,R5,#+4
   \   00000064   A21041E0           SUB      R1,R1,R2, LSR #+1
   \   00000068   030051E3           CMP      R1,#+3
   \   0000006C   7080BDB8           POPLT    {R4-R6,PC}
    398            {
    399              if (*--ps == ')')  // Закрывающая скобка есть
   \   00000070   B21070E1           LDRH     R1,[R0, #-2]!
   \   00000074   290051E3           CMP      R1,#+41
   \   00000078   7080BD18           POPNE    {R4-R6,PC}
    400              {
    401                int i = 0;
   \   0000007C   0010A0E3           MOV      R1,#+0
    402                int p10 = 1;
   \   00000080   0120A0E3           MOV      R2,#+1
   \   00000084   0A0000EA           B        ??parse_name_4
    403                while (--ps >= fname && *ps >= '0' && *ps <= '9' && p10 < 100000)
   \                     ??parse_name_5:
   \   00000088   3A0053E3           CMP      R3,#+58
   \   0000008C   7080BD28           POPCS    {R4-R6,PC}
   \   00000090   603BA0E3           MOV      R3,#+98304
   \   00000094   6A3E83E3           ORR      R3,R3,#0x6A0
   \   00000098   030052E1           CMP      R2,R3
   \   0000009C   7080BDA8           POPGE    {R4-R6,PC}
    404                {
    405                  i += (*ps - '0') * p10;
   \   000000A0   B030D0E1           LDRH     R3,[R0, #+0]
   \   000000A4   303043E2           SUB      R3,R3,#+48
   \   000000A8   921321E0           MLA      R1,R2,R3,R1
    406                  p10 *= 10;
   \   000000AC   0A30A0E3           MOV      R3,#+10
   \   000000B0   930202E0           MUL      R2,R3,R2
    407                }
   \                     ??parse_name_4:
   \   000000B4   020040E2           SUB      R0,R0,#+2
   \   000000B8   040050E1           CMP      R0,R4
   \   000000BC   7080BD38           POPCC    {R4-R6,PC}
   \   000000C0   B030D0E1           LDRH     R3,[R0, #+0]
   \   000000C4   300053E3           CMP      R3,#+48
   \   000000C8   EEFFFF2A           BCS      ??parse_name_5
   \   000000CC   280053E3           CMP      R3,#+40
   \   000000D0   7080BD18           POPNE    {R4-R6,PC}
   \   000000D4   000051E3           CMP      R1,#+0
    408                if (ps >= fname && *ps == '(' && i != 0)
    409                {
    410                  pfns->number = i;
   \   000000D8   00108515           STRNE    R1,[R5, #+0]
    411                  *ps = '\0'; // обрубаем чистое имя
   \   000000DC   0010A013           MOVNE    R1,#+0
   \   000000E0   B010C011           STRHNE   R1,[R0, #+0]
    412                }
    413              }
    414            }
    415          }
   \   000000E4   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??parse_name_3:
   \   000000E8   ........           DC32     str_empty
    416          

   \                                 In segment CODE, align 4, keep-with-next
    417          int find_next_name(ParseFileNameStruct* pfns, wchar_t *buf)
    418          {
   \                     ??find_next_name:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
    419            for (pfns->number++; pfns->number < 100; pfns->number++)
   \                     ??find_next_name_1:
   \   0000000C   000094E5           LDR      R0,[R4, #+0]
   \   00000010   010080E2           ADD      R0,R0,#+1
   \   00000014   000084E5           STR      R0,[R4, #+0]
   \   00000018   000094E5           LDR      R0,[R4, #+0]
   \   0000001C   640050E3           CMP      R0,#+100
   \   00000020   0F0000AA           BGE      ??find_next_name_2
    420            {
    421              snwprintf(buf, MAX_PATH-1,_ls_i_ls, pfns->cleanName, pfns->number, pfns->cleanExt);
   \   00000024   040294E5           LDR      R0,[R4, #+516]
   \   00000028   3C209FE5           LDR      R2,??find_next_name_3  ;; _ls_i_ls
   \   0000002C   01002DE9           PUSH     {R0}
   \   00000030   000094E5           LDR      R0,[R4, #+0]
   \   00000034   043084E2           ADD      R3,R4,#+4
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   FF10A0E3           MOV      R1,#+255
   \   00000040   0500A0E1           MOV      R0,R5
   \   00000044   150100EF           SWI      +277
    422              if (!fexists(buf))
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           BL       ??fexists
   \   00000050   000050E3           CMP      R0,#+0
   \   00000054   08D08DE2           ADD      SP,SP,#+8
   \   00000058   EBFFFF1A           BNE      ??find_next_name_1
    423                return 1; 
   \   0000005C   0100A0E3           MOV      R0,#+1
   \   00000060   3080BDE8           POP      {R4,R5,PC}
    424            }
    425            return 0;
   \                     ??find_next_name_2:
   \   00000064   0000A0E3           MOV      R0,#+0
   \   00000068   3080BDE8           POP      {R4,R5,PC}       ;; return
   \                     ??find_next_name_3:
   \   0000006C   ........           DC32     _ls_i_ls
    426          }
    427          

   \                                 In segment CODE, align 4, keep-with-next
    428          int fscp(wchar_t* src, wchar_t* dst, int ip)
    429          {
   \                     ??fscp:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    430            progrsp_start = 1;
   \   00000008   C0009FE5           LDR      R0,??fscp_1      ;; progrsp_start
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   40DE4DE2           SUB      SP,SP,#+1024
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0110A0E3           MOV      R1,#+1
   \   00000020   001080E5           STR      R1,[R0, #+0]
    431            int res;
    432            int isSame = (wstrcmpi(src, dst) == 0);
   \   00000024   0510A0E1           MOV      R1,R5
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   9F0200EF           SWI      +671
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0170A003           MOVEQ    R7,#+1
   \   00000038   0070A013           MOVNE    R7,#+0
    433            if (isdir(src))
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           _BLF     ??isdir,??isdir??rA
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   0500000A           BEQ      ??fscp_2
    434            {
    435              res = cptree(src, dst, ip);
   \   0000004C   0620A0E1           MOV      R2,R6
   \   00000050   0510A0E1           MOV      R1,R5
   \   00000054   0400A0E1           MOV      R0,R4
   \   00000058   ........           BL       ??cptree
   \   0000005C   0040A0E1           MOV      R4,R0
   \   00000060   130000EA           B        ??fscp_3
    436            }
    437            else
    438            {
    439              if (isSame)
   \                     ??fscp_2:
   \   00000064   000057E3           CMP      R7,#+0
   \   00000068   0900000A           BEQ      ??fscp_4
    440              {
    441                wchar_t buf[MAX_PATH];
    442                // Генерим новое имя и копируем...
    443                ParseFileNameStruct fns;
    444                parse_name(src, &fns);
   \   0000006C   0D10A0E1           MOV      R1,SP
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   ........           BL       ??parse_name
    445                // Ищем следующее незанятое имя
    446                if (find_next_name(&fns,buf))
   \   00000078   821F8DE2           ADD      R1,SP,#+520
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           BL       ??find_next_name
   \   00000084   000050E3           CMP      R0,#+0
   \   00000088   0510A001           MOVEQ    R1,R5
    447                {
    448                  res = fcopy(src, buf);
   \   0000008C   821F8D12           ADDNE    R1,SP,#+520
   \   00000090   000000EA           B        ??fscp_5
    449                }
    450                else res = fcopy(src, dst);
    451              }
    452              else res = fcopy(src, dst);
   \                     ??fscp_4:
   \   00000094   0510A0E1           MOV      R1,R5
   \                     ??fscp_5:
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       ??fcopy
   \   000000A0   0040A0E1           MOV      R4,R0
    453              if (ip) incprogr(1);
   \   000000A4   000056E3           CMP      R6,#+0
   \   000000A8   0100000A           BEQ      ??fscp_3
   \   000000AC   0100A0E3           MOV      R0,#+1
   \   000000B0   ........           _BLF     ??incprogr,??incprogr??rA
    454            }
    455            progrsp_start = 0;
   \                     ??fscp_3:
   \   000000B4   14009FE5           LDR      R0,??fscp_1      ;; progrsp_start
   \   000000B8   0010A0E3           MOV      R1,#+0
   \   000000BC   001080E5           STR      R1,[R0, #+0]
    456            return res;
   \   000000C0   0400A0E1           MOV      R0,R4
   \   000000C4   08D08DE2           ADD      SP,SP,#+8
   \   000000C8   40DE8DE2           ADD      SP,SP,#+1024
   \   000000CC   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??fscp_1:
   \   000000D0   ........           DC32     progrsp_start
    457          }
    458          

   \                                 In segment CODE, align 4, keep-with-next
    459          int fsmv(wchar_t* src, wchar_t* dst)
    460          {
   \                     ??fsmv:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    461            int res = 0;
    462            /*
    463            if (src[0] != dst[0])
    464            {
    465              if (wstrcmpi(src, dst) != 0) // Только для неодинаковых файлов
    466                res = fmove(src, dst, &err);
    467              incprogr(GetFilesCnt(dst));
    468            }
    469            else*/
    470              if (fscp(src, dst, 1)) 
   \   00000004   0120A0E3           MOV      R2,#+1
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0050A0E3           MOV      R5,#+0
   \   00000010   ........           BL       ??fscp
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0300000A           BEQ      ??fsmv_1
    471                res = fsrm(src, 0);
   \   0000001C   0010A0E3           MOV      R1,#+0
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       ??fsrm
   \   00000028   0050A0E1           MOV      R5,R0
    472            return res;
   \                     ??fsmv_1:
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   3080BDE8           POP      {R4,R5,PC}       ;; return
    473          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     _ls_ls

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     progr_stop
    474          

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     CorFileName(wchar_t *)            16
     EnumFiles(wchar_t *, ENUM_FILES_PROC, unsigned int)
                                        8
     EnumFilesInDir(wchar_t *, ENUM_FILES_PROC, unsigned int, int, int)
                                      148
     GetFileDir(wchar_t *, wchar_t *, int)
                                       12
     GetFileExt(wchar_t *)              4
     GetFileName(wchar_t *)             8
     GetFilesCnt(wchar_t *)            16
     TestFileName(wchar_t *)            8
     _IsBadChar(wchar_t)                0
     cptree(wchar_t *, wchar_t *, int)
                                       48
     fcopy(wchar_t *, wchar_t *)       28
     fexists(wchar_t *)                44
     find_next_name(ParseFileNameStruct *, wchar_t *)
                                       20
     fscp(wchar_t *, wchar_t *, int)
                                     1052
     fsmv(wchar_t *, wchar_t *)        12
     fsrm(wchar_t *, int)              12
     mktree(wchar_t *)                 24
     parse_name(wchar_t *, ParseFileNameStruct *)
                                       16
     rmtree(wchar_t *, int)            28


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     GetFileExt(wchar_t *)            64
     GetFileName(wchar_t *)           80
     GetFileDir(wchar_t *, wchar_t *, int)
                                     128
     fexists(wchar_t *)               36
     rmtree(wchar_t *, int)          164
     fsrm(wchar_t *, int)             92
     fcopy(wchar_t *, wchar_t *)     284
     badchars                         24
     _IsBadChar(wchar_t)              60
     TestFileName(wchar_t *)          48
     CorFileName(wchar_t *)           64
     EnumFilesInDir(wchar_t *, ENUM_FILES_PROC, unsigned int, int, int)
                                     644
     EnumFiles(wchar_t *, ENUM_FILES_PROC, unsigned int)
                                      20
     GetFilesCnt(wchar_t *)           80
     mktree(wchar_t *)               176
     cptree(wchar_t *, wchar_t *, int)
                                     376
     parse_name(wchar_t *, ParseFileNameStruct *)
                                     236
     find_next_name(ParseFileNameStruct *, wchar_t *)
                                     112
     fscp(wchar_t *, wchar_t *, int)
                                     212
     fsmv(wchar_t *, wchar_t *)       52
     ??DataTable4                      4
     ??DataTable5                      4
      Others                         208

 
 3 144 bytes in segment CODE
    24 bytes in segment DATA_C
 
 2 936 bytes of CODE  memory (+ 208 bytes shared)
    24 bytes of CONST memory

Errors: none
Warnings: none
