##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Jun/2013  22:48:08 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\slib.cpp  #
#    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\slib.cpp  #
#                       -D NDEBUG -D USEZLIB -D OLDFUNCTIONS -lCN            #
#                       Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\ -la Z:\home\perk11\www\perk11.info\svn\SE\mcse\ #
#                       Release\List\ -o Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\Release\Obj\ -s9 --no_unroll                 #
#                       --no_code_motion --cpu_mode arm --endian little      #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --enable_multibytes --fpu None --eec++               #
#                       --dlib_config Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8 #
#                       n.h --preinclude Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\..\deleaker\mem2.h -I                        #
#                       Z:\home\perk11\IAR2\arm\INC\ --inline_threshold=2    #
#    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\slib.lst                                         #
#    Object file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\O #
#                       bj\slib.r79                                          #
#                                                                            #
#                                                                            #
##############################################################################

Z:\home\perk11\www\perk11.info\svn\SE\mcse\slib.cpp
      1          #include "inc\mc.h"
      2          #include "inc\mui.h"
      3          #include "inc\krnl.h"
      4          #include "inc\gui.h"
      5          

   \                                 In segment DATA_C, align 4, align-sorted
      6          const char _ss[] = "%s: %s";
   \                     _ss:
   \   00000000   25733A202573       DC8 "%s: %s"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In segment DATA_C, align 4, align-sorted
      7          const wchar_t _lsls[] = L"%ls: %ls";
   \                     _lsls:
   \   00000000   25006C007300       DC8 25H, 0, 6CH, 0, 73H, 0, 3AH, 0
   \              3A00        
   \   00000008   200025006C00       DC8 20H, 0, 25H, 0, 6CH, 0, 73H, 0
   \              7300        
   \   00000010   0000               DC8 0, 0
   \   00000012   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
      8          const wchar_t _ls_ls[] = L"%ls/%ls";
   \                     _ls_ls:
   \   00000000   25006C007300       DC8 25H, 0, 6CH, 0, 73H, 0, 2FH, 0
   \              2F00        
   \   00000008   25006C007300       DC8 25H, 0, 6CH, 0, 73H, 0, 0, 0
   \              0000        

   \                                 In segment DATA_C, align 4, align-sorted
      9          const wchar_t _ls_stars[] = L"%ls/*";
   \                     _ls_stars:
   \   00000000   25006C007300       DC8 25H, 0, 6CH, 0, 73H, 0, 2FH, 0
   \              2F00        
   \   00000008   2A000000           DC8 2AH, 0, 0, 0

   \                                 In segment DATA_C, align 2, align-sorted
     10          const wchar_t str_empty[] = L"";
   \                     str_empty:
   \   00000000   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
     11          const wchar_t _d[] = L"%d";
   \                     _d:
   \   00000000   250064000000       DC8 25H, 0, 64H, 0, 0, 0
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
     12          const wchar_t _ls_i_ls[] = L"%ls(%i).%ls";
   \                     _ls_i_ls:
   \   00000000   25006C007300       DC8 25H, 0, 6CH, 0, 73H, 0, 28H, 0
   \              2800        
   \   00000008   250069002900       DC8 25H, 0, 69H, 0, 29H, 0, 2EH, 0
   \              2E00        
   \   00000010   25006C007300       DC8 25H, 0, 6CH, 0, 73H, 0, 0, 0
   \              0000        
     13          

   \                                 In segment CODE, align 4, keep-with-next
     14          char* strtolower(char* src, char* dst, int sz)
     15          {
   \                     ??strtolower:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0260A0E1           MOV      R6,R2
     16            int sl = strlen(src)+1;
   \   00000010   5A0100EF           SWI      +346
   \   00000014   010080E2           ADD      R0,R0,#+1
     17            int len = sz==-1?sl:sz;
   \   00000018   010076E3           CMN      R6,#+1
   \   0000001C   0060A001           MOVEQ    R6,R0
     18            if (len>sl) len=sl;
   \   00000020   060050E1           CMP      R0,R6
   \   00000024   0060A0B1           MOVLT    R6,R0
     19            
     20            for(int ii=0; ii<len-1; ii++)
   \   00000028   0000A0E3           MOV      R0,#+0
   \   0000002C   011046E2           SUB      R1,R6,#+1
   \   00000030   010051E3           CMP      R1,#+1
   \   00000034   070000AA           BGE      ??strtolower_1
   \   00000038   090000EA           B        ??strtolower_2
     21            {
     22              int ch = src[ii];
   \                     ??strtolower_3:
   \   0000003C   0510D0E7           LDRB     R1,[R0, +R5]
     23              if (ch>='A' && ch<='Z') ch=ch-'A'+'a';
   \   00000040   410051E3           CMP      R1,#+65
   \   00000044   010000BA           BLT      ??strtolower_4
   \   00000048   5B0051E3           CMP      R1,#+91
   \   0000004C   201081B2           ADDLT    R1,R1,#+32
     24              dst[ii]=ch;
   \                     ??strtolower_4:
   \   00000050   0410C0E7           STRB     R1,[R0, +R4]
     25            }
   \   00000054   010080E2           ADD      R0,R0,#+1
   \                     ??strtolower_1:
   \   00000058   011046E2           SUB      R1,R6,#+1
   \   0000005C   010050E1           CMP      R0,R1
   \   00000060   F5FFFFBA           BLT      ??strtolower_3
     26            dst[len-1]=0;
   \                     ??strtolower_2:
   \   00000064   040086E0           ADD      R0,R6,R4
   \   00000068   0010A0E3           MOV      R1,#+0
   \   0000006C   011040E5           STRB     R1,[R0, #-1]
     27            return dst;
   \   00000070   0400A0E1           MOV      R0,R4
   \   00000074   7080BDE8           POP      {R4-R6,PC}       ;; return
     28          }
     29          
     30          // Замена символов

   \                                 In segment CODE, align 4, keep-with-next
     31          char* strreplace(char* s, char cprev, char cnew)
     32          {
     33          	for (int i = 0; s[i]; s++)
   \                     ??strreplace:
   \   00000000   0030D0E5           LDRB     R3,[R0, #+0]
   \   00000004   000053E3           CMP      R3,#+0
   \   00000008   1EFF2F01           BXEQ     LR
     34          		if (s[i] == cprev) s[i] = cnew;
   \                     ??strreplace_1:
   \   0000000C   0030D0E5           LDRB     R3,[R0, #+0]
   \   00000010   010053E1           CMP      R3,R1
   \   00000014   0020C005           STRBEQ   R2,[R0, #+0]
   \   00000018   0130F0E5           LDRB     R3,[R0, #+1]!
   \   0000001C   000053E3           CMP      R3,#+0
   \   00000020   F9FFFF1A           BNE      ??strreplace_1
     35          	return s;
   \   00000024   1EFF2FE1           BX       LR               ;; return
     36          }
     37          
     38          

   \                                 In segment CODE, align 4, keep-with-next
     39          wchar_t* wstrreplace(wchar_t* s,  wchar_t cprev, wchar_t cnew)
     40          {
     41          	for (int i = 0; s[i]; s++)
   \                     ??wstrreplace:
   \   00000000   B030D0E1           LDRH     R3,[R0, #+0]
   \   00000004   000053E3           CMP      R3,#+0
   \   00000008   1EFF2F01           BXEQ     LR
     42          		if (s[i] == cprev) s[i] = cnew;
   \                     ??wstrreplace_1:
   \   0000000C   B030D0E1           LDRH     R3,[R0, #+0]
   \   00000010   010053E1           CMP      R3,R1
   \   00000014   B020C001           STRHEQ   R2,[R0, #+0]
   \   00000018   B230F0E1           LDRH     R3,[R0, #+2]!
   \   0000001C   000053E3           CMP      R3,#+0
   \   00000020   F9FFFF1A           BNE      ??wstrreplace_1
     43          	return s;
   \   00000024   1EFF2FE1           BX       LR               ;; return
     44          }

   \                                 In segment CODE, align 4, keep-with-next
     45          int isNumericWstr(wchar_t *s)
     46          {
     47          	// Внимание! пустую строку тоже считаем числовой
     48          	for (int i = 0; s[i]; i++)
   \                     ??isNumericWstr:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   000000EA           B        ??isNumericWstr_1
   \                     ??isNumericWstr_2:
   \   00000008   011081E2           ADD      R1,R1,#+1
   \                     ??isNumericWstr_1:
   \   0000000C   812080E0           ADD      R2,R0,R1, LSL #+1
   \   00000010   B020D2E1           LDRH     R2,[R2, #+0]
   \   00000014   000052E3           CMP      R2,#+0
   \   00000018   0900000A           BEQ      ??isNumericWstr_3
     49          		if (s[i] < '0' || s[i] > '9') return 0;
   \   0000001C   812080E0           ADD      R2,R0,R1, LSL #+1
   \   00000020   B020D2E1           LDRH     R2,[R2, #+0]
   \   00000024   300052E3           CMP      R2,#+48
   \   00000028   0300003A           BCC      ??isNumericWstr_4
   \   0000002C   812080E0           ADD      R2,R0,R1, LSL #+1
   \   00000030   B020D2E1           LDRH     R2,[R2, #+0]
   \   00000034   3A0052E3           CMP      R2,#+58
   \   00000038   F2FFFF3A           BCC      ??isNumericWstr_2
   \                     ??isNumericWstr_4:
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   1EFF2FE1           BX       LR
     50          
     51          	return 1;
   \                     ??isNumericWstr_3:
   \   00000044   0100A0E3           MOV      R0,#+1
   \   00000048   1EFF2FE1           BX       LR               ;; return
     52          }
     53          

   \                                 In segment CODE, align 4, keep-with-next
     54          wchar_t wcharlow(wchar_t wc)
     55          {
     56          	if (wc>=0x0041 && wc<=0x005a) return wc+(0x0061-0x0041); //A-Z
   \                     ??wcharlow:
   \   00000000   410050E3           CMP      R0,#+65
   \   00000004   0300003A           BCC      ??wcharlow_1
   \   00000008   5B0050E3           CMP      R0,#+91
   \   0000000C   0100002A           BCS      ??wcharlow_1
   \                     ??wcharlow_2:
   \   00000010   200080E2           ADD      R0,R0,#+32
   \   00000014   0D0000EA           B        ??wcharlow_3
     57          	if (wc>=0x0410 && wc<=0x042f) return wc+(0x0430-0x0410); //А-Я
   \                     ??wcharlow_1:
   \   00000018   410E50E3           CMP      R0,#+1040
   \   0000001C   0800003A           BCC      ??wcharlow_4
   \   00000020   430E50E3           CMP      R0,#+1072
   \   00000024   F9FFFF3A           BCC      ??wcharlow_2
     58          	if (wc>=0x0400 && wc<=0x040f) return wc+(0x0450-0x0400);
     59          
     60          	if (wc>=0x00c0 && wc<=0x00de && wc!=0x00d7) return wc+(0x00e0-0x00c0);
     61          
     62          	if (wc>=0x0100 && wc<=0x0136 && ~(wc & 1)) return wc+1;
     63          	if (wc>=0x0139 && wc<=0x0147 &&  (wc & 1)) return wc+1;
     64          	if (wc>=0x014a && wc<=0x0176 && ~(wc & 1)) return wc+1;
     65          	if (wc>=0x0179 && wc<=0x017d &&  (wc & 1)) return wc+1;
     66          	if (wc>=0x01e4 && wc<=0x01ea && ~(wc & 1)) return wc+1;
     67          
     68          	if (wc>=0x01fa && wc<=0x01fe && ~(wc & 1)) return wc+1;
     69          
     70          	if (wc>=0x0490 && wc<=0x04e8 && ~(wc & 1)) return wc+1;
   \   00000028   490E50E3           CMP      R0,#+1168
   \   0000002C   1EFF2F31           BXCC     LR
   \   00000030   E910A0E3           MOV      R1,#+233
   \   00000034   401E81E3           ORR      R1,R1,#0x400
   \   00000038   010050E1           CMP      R0,R1
   \   0000003C   1EFF2F21           BXCS     LR
   \                     ??wcharlow_5:
   \   00000040   120000EA           B        ??wcharlow_6
   \                     ??wcharlow_4:
   \   00000044   400E50E3           CMP      R0,#+1024
   \   00000048   0300003A           BCC      ??wcharlow_7
   \   0000004C   500080E2           ADD      R0,R0,#+80
   \                     ??wcharlow_3:
   \   00000050   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000054   2008A0E1           MOV      R0,R0, LSR #+16
   \   00000058   1EFF2FE1           BX       LR
   \                     ??wcharlow_7:
   \   0000005C   C00050E3           CMP      R0,#+192
   \   00000060   0400003A           BCC      ??wcharlow_8
   \   00000064   DF0050E3           CMP      R0,#+223
   \   00000068   0200002A           BCS      ??wcharlow_8
   \   0000006C   D70050E3           CMP      R0,#+215
   \   00000070   E6FFFF1A           BNE      ??wcharlow_2
     71          
     72          	if (wc==0x01a0 || wc==0x01af || wc==0x017d || 
     73          		wc==0x01ee || wc==0x0218 || wc==0x021a || wc==0x0228) return wc+1;
     74          
     75          	if (wc==0x0178) return 0x00ff;
     76          	if (wc==0x018f) return 0x0259;
     77          	if (wc==0x01b7) return 0x0292;
     78          	return wc;
   \   00000074   1EFF2FE1           BX       LR               ;; return
   \                     ??wcharlow_8:
   \   00000078   400F50E3           CMP      R0,#+256
   \   0000007C   0700003A           BCC      ??wcharlow_9
   \   00000080   3710A0E3           MOV      R1,#+55
   \   00000084   401F81E3           ORR      R1,R1,#0x100
   \   00000088   010050E1           CMP      R0,R1
   \   0000008C   0300002A           BCS      ??wcharlow_9
   \                     ??wcharlow_6:
   \   00000090   010010E3           TST      R0,#0x1
   \   00000094   1EFF2F11           BXNE     LR
   \                     ??wcharlow_10:
   \   00000098   010080E2           ADD      R0,R0,#+1
   \   0000009C   EBFFFFEA           B        ??wcharlow_3
   \                     ??wcharlow_9:
   \   000000A0   3910A0E3           MOV      R1,#+57
   \   000000A4   401F81E3           ORR      R1,R1,#0x100
   \   000000A8   010050E1           CMP      R0,R1
   \   000000AC   0400003A           BCC      ??wcharlow_11
   \   000000B0   520F50E3           CMP      R0,#+328
   \   000000B4   0200002A           BCS      ??wcharlow_11
   \   000000B8   010010E3           TST      R0,#0x1
   \   000000BC   F5FFFF1A           BNE      ??wcharlow_10
   \   000000C0   1EFF2FE1           BX       LR
   \                     ??wcharlow_11:
   \   000000C4   111081E2           ADD      R1,R1,#+17
   \   000000C8   010050E1           CMP      R0,R1
   \   000000CC   0200003A           BCC      ??wcharlow_12
   \   000000D0   2D1081E2           ADD      R1,R1,#+45
   \   000000D4   010050E1           CMP      R0,R1
   \   000000D8   ECFFFF3A           BCC      ??wcharlow_6
   \                     ??wcharlow_12:
   \   000000DC   7910A0E3           MOV      R1,#+121
   \   000000E0   401F81E3           ORR      R1,R1,#0x100
   \   000000E4   010050E1           CMP      R0,R1
   \   000000E8   0500003A           BCC      ??wcharlow_13
   \   000000EC   051081E2           ADD      R1,R1,#+5
   \   000000F0   010050E1           CMP      R0,R1
   \   000000F4   0200002A           BCS      ??wcharlow_13
   \   000000F8   010010E3           TST      R0,#0x1
   \   000000FC   E5FFFF1A           BNE      ??wcharlow_10
   \   00000100   110000EA           B        ??wcharlow_14
   \                     ??wcharlow_13:
   \   00000104   790F50E3           CMP      R0,#+484
   \   00000108   0300003A           BCC      ??wcharlow_15
   \   0000010C   EB10A0E3           MOV      R1,#+235
   \   00000110   401F81E3           ORR      R1,R1,#0x100
   \   00000114   010050E1           CMP      R0,R1
   \   00000118   DCFFFF3A           BCC      ??wcharlow_6
   \                     ??wcharlow_15:
   \   0000011C   FA10A0E3           MOV      R1,#+250
   \   00000120   401F81E3           ORR      R1,R1,#0x100
   \   00000124   010050E1           CMP      R0,R1
   \   00000128   0300003A           BCC      ??wcharlow_16
   \   0000012C   051081E3           ORR      R1,R1,#0x5
   \   00000130   010050E1           CMP      R0,R1
   \   00000134   0A00002A           BCS      ??wcharlow_17
   \   00000138   D4FFFFEA           B        ??wcharlow_6
   \                     ??wcharlow_16:
   \   0000013C   680F50E3           CMP      R0,#+416
   \   00000140   4B104112           SUBNE    R1,R1,#+75
   \   00000144   01005011           CMPNE    R0,R1
   \   00000148   D2FFFF0A           BEQ      ??wcharlow_10
   \                     ??wcharlow_14:
   \   0000014C   7D10A0E3           MOV      R1,#+125
   \   00000150   401F81E3           ORR      R1,R1,#0x100
   \   00000154   010050E1           CMP      R0,R1
   \   00000158   71108112           ADDNE    R1,R1,#+113
   \   0000015C   01005011           CMPNE    R0,R1
   \   00000160   CCFFFF0A           BEQ      ??wcharlow_10
   \                     ??wcharlow_17:
   \   00000164   860F50E3           CMP      R0,#+536
   \   00000168   CAFFFF0A           BEQ      ??wcharlow_10
   \   0000016C   1A10A0E3           MOV      R1,#+26
   \   00000170   801F81E3           ORR      R1,R1,#0x200
   \   00000174   010050E1           CMP      R0,R1
   \   00000178   8A0F5013           CMPNE    R0,#+552
   \   0000017C   C5FFFF0A           BEQ      ??wcharlow_10
   \   00000180   5E0F50E3           CMP      R0,#+376
   \   00000184   FF00A003           MOVEQ    R0,#+255
   \   00000188   1EFF2F01           BXEQ     LR
   \   0000018C   8B1041E2           SUB      R1,R1,#+139
   \   00000190   010050E1           CMP      R0,R1
   \   00000194   CA008102           ADDEQ    R0,R1,#+202
   \   00000198   1EFF2F01           BXEQ     LR
   \   0000019C   281081E2           ADD      R1,R1,#+40
   \   000001A0   010050E1           CMP      R0,R1
   \   000001A4   1EFF2F11           BXNE     LR
   \   000001A8   DB0081E2           ADD      R0,R1,#+219
   \   000001AC   1EFF2FE1           BX       LR
     79          }
     80          
     81          

   \                                 In segment CODE, align 4, keep-with-next
     82          const wchar_t *strpbrkw(const wchar_t *s1, const wchar_t *w1)
     83          {
   \                     ??strpbrkw:
   \   00000000   000000EA           B        ??strpbrkw_1
     84            int c;
     85            while((c=*s1))
     86            {
     87              const wchar_t *w2=w1;
     88              int d;
     89              while((d=*w2++))
     90              {
     91                if(d==c) return s1;      
     92              }   
     93              s1++;    
   \                     ??strpbrkw_2:
   \   00000004   020080E2           ADD      R0,R0,#+2
   \                     ??strpbrkw_1:
   \   00000008   B020D0E1           LDRH     R2,[R0, #+0]
   \   0000000C   000052E3           CMP      R2,#+0
   \   00000010   0600000A           BEQ      ??strpbrkw_3
   \   00000014   0130A0E1           MOV      R3,R1
   \                     ??strpbrkw_4:
   \   00000018   ........           LDRH     R12,[R3], #+2
   \   0000001C   00005CE3           CMP      R12,#+0
   \   00000020   F7FFFF0A           BEQ      ??strpbrkw_2
   \   00000024   02005CE1           CMP      R12,R2
   \   00000028   FAFFFF1A           BNE      ??strpbrkw_4
   \   0000002C   1EFF2FE1           BX       LR
     94            }
     95            return NULL;  
   \                     ??strpbrkw_3:
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1EFF2FE1           BX       LR               ;; return
     96          }
     97          

   \                                 In segment CODE, align 4, keep-with-next
     98          int match(wchar_t *pattern,wchar_t *string)
     99          {
   \                     ??match:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   000000EA           B        ??match_1
    100            for (;; ++string)
   \                     ??match_2:
   \   00000010   025085E2           ADD      R5,R5,#+2
    101            {
    102              wchar_t stringc=wcharlow(*string);
   \                     ??match_1:
   \   00000014   B000D5E1           LDRH     R0,[R5, #+0]
   \   00000018   ........           BL       ??wcharlow
   \   0000001C   0060A0E1           MOV      R6,R0
    103              wchar_t patternc=wcharlow(*pattern++);
   \   00000020   ........           LDRH     R0,[R4], #+2
   \   00000024   ........           BL       ??wcharlow
    104              switch (patternc)
   \   00000028   0010B0E1           MOVS     R1,R0
   \   0000002C   0400000A           BEQ      ??match_3
   \   00000030   2A1050E2           SUBS     R1,R0,#+42
   \   00000034   0700000A           BEQ      ??match_4
   \   00000038   151051E2           SUBS     R1,R1,#+21
   \   0000003C   0200000A           BEQ      ??match_5
   \   00000040   3A0000EA           B        ??match_6
    105              {
    106                case 0:
    107                  return(stringc==0);
   \                     ??match_3:
   \   00000044   000056E3           CMP      R6,#+0
   \   00000048   2B0000EA           B        ??match_7
    108                case '?':
    109                  if (stringc == 0)
   \                     ??match_5:
   \   0000004C   000056E3           CMP      R6,#+0
   \   00000050   EEFFFF1A           BNE      ??match_2
    110                    return(0);
   \                     ??match_8:
   \   00000054   150000EA           B        ??match_9
    111                  break;
    112                case '*':
    113                  if (*pattern==0)
   \                     ??match_4:
   \   00000058   B000D4E1           LDRH     R0,[R4, #+0]
   \   0000005C   000050E3           CMP      R0,#+0
   \   00000060   0100001A           BNE      ??match_10
    114                    return(1);
   \                     ??match_11:
   \   00000064   0100A0E3           MOV      R0,#+1
   \   00000068   7080BDE8           POP      {R4-R6,PC}
    115                  if (*pattern=='.')
   \                     ??match_10:
   \   0000006C   2E0050E3           CMP      R0,#+46
   \   00000070   2400001A           BNE      ??match_12
    116                  {
    117                    if (pattern[1]=='*' && pattern[2]==0)
   \   00000074   B200D4E1           LDRH     R0,[R4, #+2]
   \   00000078   2A0050E3           CMP      R0,#+42
   \   0000007C   B400D401           LDRHEQ   R0,[R4, #+4]
   \   00000080   00005003           CMPEQ    R0,#+0
   \   00000084   F6FFFF0A           BEQ      ??match_11
    118                      return(1);
    119                    wchar_t *dot=wstrchr(string,'.');
   \   00000088   2E10A0E3           MOV      R1,#+46
   \   0000008C   0500A0E1           MOV      R0,R5
   \   00000090   A00200EF           SWI      +672
    120                    if (pattern[1]==0)
   \   00000094   B210D4E1           LDRH     R1,[R4, #+2]
   \   00000098   000051E3           CMP      R1,#+0
   \   0000009C   0500001A           BNE      ??match_13
    121                      return (dot==NULL || dot[1]==0);
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   B200D011           LDRHNE   R0,[R0, #+2]
   \   000000A8   00005013           CMPNE    R0,#+0
   \   000000AC   ECFFFF0A           BEQ      ??match_11
   \                     ??match_9:
   \   000000B0   0000A0E3           MOV      R0,#+0
   \   000000B4   7080BDE8           POP      {R4-R6,PC}
    122                    if (dot!=NULL)
   \                     ??match_13:
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   1100000A           BEQ      ??match_12
    123                    {
    124                      string=dot;
    125                      if (strpbrkw(pattern,L"*?")==NULL && wstrchr(string+1,'.')==NULL)
   \   000000C0   80109FE5           LDR      R1,??match_14    ;; `?<Constant L"\\x2a\\x3f">`
   \   000000C4   0050A0E1           MOV      R5,R0
   \   000000C8   0400A0E1           MOV      R0,R4
   \   000000CC   ........           BL       ??strpbrkw
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   0B00001A           BNE      ??match_12
   \   000000D8   2E10A0E3           MOV      R1,#+46
   \   000000DC   020085E2           ADD      R0,R5,#+2
   \   000000E0   A00200EF           SWI      +672
   \   000000E4   000050E3           CMP      R0,#+0
   \   000000E8   0600001A           BNE      ??match_12
    126                        return(wstrcmpi(pattern+1,string+1)==0);
   \   000000EC   021085E2           ADD      R1,R5,#+2
   \   000000F0   020084E2           ADD      R0,R4,#+2
   \   000000F4   9F0200EF           SWI      +671
   \   000000F8   000050E3           CMP      R0,#+0
   \                     ??match_7:
   \   000000FC   EBFFFF1A           BNE      ??match_9
   \   00000100   0100A0E3           MOV      R0,#+1
   \   00000104   7080BDE8           POP      {R4-R6,PC}
    127                    }
    128                  }
    129          
    130                  while (*string)
   \                     ??match_12:
   \   00000108   B000D5E1           LDRH     R0,[R5, #+0]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   7080BD08           POPEQ    {R4-R6,PC}
    131                    if (match(pattern,string++))
   \   00000114   0510A0E1           MOV      R1,R5
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   B7FFFFEB           BL       ??match
   \   00000120   025085E2           ADD      R5,R5,#+2
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   CDFFFF1A           BNE      ??match_11
   \   0000012C   F5FFFFEA           B        ??match_12
    132                      return(1);
    133                  return(0);
    134                default:
    135                  if (patternc != stringc)
   \                     ??match_6:
   \   00000130   060050E1           CMP      R0,R6
   \   00000134   B5FFFF0A           BEQ      ??match_2
    136                    if (patternc=='.' && stringc==0)
   \   00000138   2E0050E3           CMP      R0,#+46
   \   0000013C   00005603           CMPEQ    R6,#+0
   \   00000140   DAFFFF1A           BNE      ??match_9
   \   00000144   B2FFFFEA           B        ??match_1
   \                     ??match_14:
   \   00000148   ........           DC32     `?<Constant L"\\x2a\\x3f">`
    137                      return(match(pattern,string));
    138                    else
    139                      return(0);
    140                  break;
    141              }
    142            }
    143          }
    144          

   \                                 In segment CODE, align 4, keep-with-next
    145          wchar_t *sz2s(unsigned int size, wchar_t *buf)
    146          {
   \                     ??sz2s:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   40D04DE2           SUB      SP,SP,#+64
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
    147            float s = size;
   \   00000010   ........           _BLF     __ulongToFloat,??__ulongToFloat??rA
   \   00000014   0060A0E1           MOV      R6,R0
    148            wchar_t *pref;
    149            char cbuf[64];
    150            pref=muitxt(ind_byte);
   \   00000018   0200A0E3           MOV      R0,#+2
   \   0000001C   ........           _BLF     ??muitxt,??muitxt??rA
   \   00000020   0070A0E1           MOV      R7,R0
    151            if (s >= 1024)
   \   00000024   0600A0E1           MOV      R0,R6
   \   00000028   4014A0E3           MOV      R1,#+1073741824
   \   0000002C   481681E3           ORR      R1,R1,#0x4800000
   \   00000030   ........           _BLF     __fGreaterEqual,??__fGreaterEqual??rA
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   1D00000A           BEQ      ??sz2s_1
    152            {
    153              s /= 1024;
   \   0000003C   0600A0E1           MOV      R0,R6
   \   00000040   4014A0E3           MOV      R1,#+1073741824
   \   00000044   481681E3           ORR      R1,R1,#0x4800000
   \   00000048   ........           _BLF     __fDiv,??__fDiv??rA
   \   0000004C   0060A0E1           MOV      R6,R0
    154              pref=muitxt(ind_kbyte);
   \   00000050   0300A0E3           MOV      R0,#+3
   \   00000054   ........           _BLF     ??muitxt,??muitxt??rA
   \   00000058   0070A0E1           MOV      R7,R0
    155              if (s >= 1024)
   \   0000005C   0600A0E1           MOV      R0,R6
   \   00000060   4014A0E3           MOV      R1,#+1073741824
   \   00000064   481681E3           ORR      R1,R1,#0x4800000
   \   00000068   ........           _BLF     __fGreaterEqual,??__fGreaterEqual??rA
   \   0000006C   000050E3           CMP      R0,#+0
   \   00000070   0700000A           BEQ      ??sz2s_2
    156              {
    157                s /= 1024;
   \   00000074   0600A0E1           MOV      R0,R6
   \   00000078   4014A0E3           MOV      R1,#+1073741824
   \   0000007C   481681E3           ORR      R1,R1,#0x4800000
   \   00000080   ........           _BLF     __fDiv,??__fDiv??rA
   \   00000084   0060A0E1           MOV      R6,R0
    158                pref=muitxt(ind_mbyte);
   \   00000088   0400A0E3           MOV      R0,#+4
   \   0000008C   ........           _BLF     ??muitxt,??muitxt??rA
   \   00000090   0070A0E1           MOV      R7,R0
    159              }
    160              sprintf(cbuf, "%.2f", s);
   \                     ??sz2s_2:
   \   00000094   0600A0E1           MOV      R0,R6
   \   00000098   ........           _BLF     __floatToDouble,??__floatToDouble??rA
   \   0000009C   0020A0E1           MOV      R2,R0
   \   000000A0   0130A0E1           MOV      R3,R1
   \   000000A4   40109FE5           LDR      R1,??sz2s_3+0x4  ;; `?<Constant "%.2f">`
   \   000000A8   0D00A0E1           MOV      R0,SP
   \   000000AC   140100EF           SWI      +276
   \   000000B0   030000EA           B        ??sz2s_4
    161            }
    162            else
    163              sprintf(cbuf, "%d", size);
   \                     ??sz2s_1:
   \   000000B4   0420A0E1           MOV      R2,R4
   \   000000B8   0A1F8FE2           ADR      R1,??sz2s_3      ;; "%d"
   \   000000BC   0D00A0E1           MOV      R0,SP
   \   000000C0   140100EF           SWI      +276
    164            snwprintf(buf, 63, L"%s %ls", cbuf, pref);
   \                     ??sz2s_4:
   \   000000C4   24209FE5           LDR      R2,??sz2s_3+0x8  ;; `?<Constant "%.2f">` + 8
   \   000000C8   80002DE9           PUSH     {R7}
   \   000000CC   04308DE2           ADD      R3,SP,#+4
   \   000000D0   3F10A0E3           MOV      R1,#+63
   \   000000D4   0500A0E1           MOV      R0,R5
   \   000000D8   150100EF           SWI      +277
    165            return buf;
   \   000000DC   0500A0E1           MOV      R0,R5
   \   000000E0   44D08DE2           ADD      SP,SP,#+68
   \   000000E4   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??sz2s_3:
   \   000000E8   25640000           DC8      "%d",+0
   \   000000EC   ........           DC32     `?<Constant "%.2f">`
   \   000000F0   ........           DC32     `?<Constant "%.2f">` + 8
    166          }
    167          
    168          

   \                                 In segment CODE, align 4, keep-with-next
    169          wchar_t *unixt2s(unsigned int time, wchar_t *buf)
    170          {
   \                     ??unixt2s:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0140A0E1           MOV      R4,R1
    171            DATETIME dt;
    172            unixtime2datetime(time,&dt);
   \   0000000C   0D10A0E1           MOV      R1,SP
   \   00000010   030300EF           SWI      +771
    173            DATE *d=&dt.date;
    174            TIME *t=&dt.time;
    175            snwprintf(buf,63,L"%.2d.%.2d.%.2d %.2d:%.2d",d->day,d->mon,d->year,t->hour,t->min);
   \   00000014   0500DDE5           LDRB     R0,[SP, #+5]
   \   00000018   34209FE5           LDR      R2,??unixt2s_1   ;; `?<Constant L"\\x25\\x2e\\x32\\x64\\x2e\\x25\\x2e\\x32\\`
   \   0000001C   3F10A0E3           MOV      R1,#+63
   \   00000020   01002DE9           PUSH     {R0}
   \   00000024   0800DDE5           LDRB     R0,[SP, #+8]
   \   00000028   01002DE9           PUSH     {R0}
   \   0000002C   B800DDE1           LDRH     R0,[SP, #+8]
   \   00000030   01002DE9           PUSH     {R0}
   \   00000034   0E00DDE5           LDRB     R0,[SP, #+14]
   \   00000038   01002DE9           PUSH     {R0}
   \   0000003C   1330DDE5           LDRB     R3,[SP, #+19]
   \   00000040   0400A0E1           MOV      R0,R4
   \   00000044   150100EF           SWI      +277
    176            return buf;
   \   00000048   0400A0E1           MOV      R0,R4
   \   0000004C   18D08DE2           ADD      SP,SP,#+24
   \   00000050   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??unixt2s_1:
   \   00000054   ........           DC32     `?<Constant L"\\x25\\x2e\\x32\\x64\\x2e\\x25\\x2e\\x32\\`
    177          }
    178          
    179          #define MAX_TXT_W		(ITM_X2-ITM_B-TXT_X-2)

   \                                 In segment CODE, align 4, keep-with-next
    180          int getLVC(wchar_t *wsbody, int font)
    181          {
   \                     ??getLVC:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    182            int old_font=SetFont(font);
   \   00000008   0100A0E1           MOV      R0,R1
    183            int width=0;
    184            int i=0;
   \   0000000C   0080A0E3           MOV      R8,#+0
   \   00000010   F10100EF           SWI      +497
   \   00000014   0050A0E1           MOV      R5,R0
    185            int f=0;
   \   00000018   0060A0E3           MOV      R6,#+0
    186            TEXTID str=TextID_Create(wsbody,ENC_UCS2,TEXTID_ANY_LEN);
   \   0000001C   FF20A0E3           MOV      R2,#+255
   \   00000020   FF2C82E3           ORR      R2,R2,#0xFF00
   \   00000024   0610A0E1           MOV      R1,R6
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   5D0100EF           SWI      +349
   \   00000030   0070A0E1           MOV      R7,R0
   \   00000034   000000EA           B        ??getLVC_1
    187            while(*wsbody++)
    188            {
    189              width=Disp_GetStrIdWidth(str,i);
    190              if (width>=MAX_TXT_W) {f=1; break;}
    191              i++;
   \                     ??getLVC_2:
   \   00000038   018088E2           ADD      R8,R8,#+1
   \                     ??getLVC_1:
   \   0000003C   ........           LDRH     R0,[R4], #+2
   \   00000040   000050E3           CMP      R0,#+0
   \   00000044   0F00000A           BEQ      ??getLVC_3
   \   00000048   0810A0E1           MOV      R1,R8
   \   0000004C   0700A0E1           MOV      R0,R7
   \   00000050   000300EF           SWI      +768
   \   00000054   4C109FE5           LDR      R1,??getLVC_4    ;; scr_w
   \   00000058   001091E5           LDR      R1,[R1, #+0]
   \   0000005C   022041E2           SUB      R2,R1,#+2
   \   00000060   811081E0           ADD      R1,R1,R1, LSL #+1
   \   00000064   C11342E0           SUB      R1,R2,R1, ASR #+7
   \   00000068   3C209FE5           LDR      R2,??getLVC_4+0x4  ;; ico_h
   \   0000006C   011041E2           SUB      R1,R1,#+1
   \   00000070   002092E5           LDR      R2,[R2, #+0]
   \   00000074   021041E0           SUB      R1,R1,R2
   \   00000078   051041E2           SUB      R1,R1,#+5
   \   0000007C   010050E1           CMP      R0,R1
   \   00000080   ECFFFFBA           BLT      ??getLVC_2
   \   00000084   0160A0E3           MOV      R6,#+1
    192            }
    193            TextID_Destroy(str);
   \                     ??getLVC_3:
   \   00000088   0700A0E1           MOV      R0,R7
   \   0000008C   610100EF           SWI      +353
    194            SetFont(old_font);
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   F10100EF           SWI      +497
    195            return (f?i:0);
   \   00000098   000056E3           CMP      R6,#+0
   \   0000009C   0080A003           MOVEQ    R8,#+0
   \   000000A0   0800A0E1           MOV      R0,R8
   \   000000A4   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??getLVC_4:
   \   000000A8   ........           DC32     scr_w
   \   000000AC   ........           DC32     ico_h
    196          }
    197          

   \                                 In segment CODE, align 4, keep-with-next
    198          void cutname(wchar_t *fname, wchar_t *sname, int len)
    199          {
   \                     ??cutname:
   \   00000000   10002DE9           PUSH     {R4}
    200            sname[len]=0;
   \   00000004   823081E0           ADD      R3,R1,R2, LSL #+1
   \   00000008   00C0A0E3           MOV      R12,#+0
   \   0000000C   B0C0C3E1           STRH     R12,[R3, #+0]
    201            for(int ii=0;ii<len;ii++)
   \   00000010   0030A0E3           MOV      R3,#+0
   \   00000014   010052E3           CMP      R2,#+1
   \   00000018   040000AA           BGE      ??cutname_1
    202            {
    203              sname[ii]=(ii>=len-2)?'.':fname[ii];
    204            }
    205            //  sname->wsbody[len+1]=0;
    206          }
   \                     ??cutname_2:
   \   0000001C   1000BDE8           POP      {R4}
   \   00000020   1EFF2FE1           BX       LR               ;; return
   \                     ??cutname_3:
   \   00000024   834081E0           ADD      R4,R1,R3, LSL #+1
   \   00000028   B0C0C4E1           STRH     R12,[R4, #+0]
   \   0000002C   013083E2           ADD      R3,R3,#+1
   \                     ??cutname_1:
   \   00000030   020053E1           CMP      R3,R2
   \   00000034   F8FFFFAA           BGE      ??cutname_2
   \   00000038   024042E2           SUB      R4,R2,#+2
   \   0000003C   040053E1           CMP      R3,R4
   \   00000040   83C080B0           ADDLT    R12,R0,R3, LSL #+1
   \   00000044   B0C0DCB1           LDRHLT   R12,[R12, #+0]
   \   00000048   2EC0A0A3           MOVGE    R12,#+46
   \   0000004C   F4FFFFEA           B        ??cutname_3
    207          
    208          
    209          // Аналог strcmp, но без чувствительности к регистру

   \                                 In segment CODE, align 4, keep-with-next
    210          int stricmp(char* str1, char* str2)
    211          {
    212          	return strnicmp(str1, str2, 1000); // тысячи хватит на сравнение, надеюсь
   \                     ??stricmp:
   \   00000000   FA2FA0E3           MOV      R2,#+1000
   \   00000004   ........           B        ??strnicmp       ;; tailcall
    213          }
    214          
    215          

   \                                 In segment CODE, align 4, keep-with-next
    216          int strnicmp(char* str1, char* str2, int count)
    217          {
   \                     ??strnicmp:
   \   00000000   10002DE9           PUSH     {R4}
    218          	for(int i=0; i<count; i++)
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   000000EA           B        ??strnicmp_1
   \                     ??strnicmp_2:
   \   0000000C   013083E2           ADD      R3,R3,#+1
   \                     ??strnicmp_1:
   \   00000010   020053E1           CMP      R3,R2
   \   00000014   130000AA           BGE      ??strnicmp_3
    219          	{
    220          		unsigned char c1 = str1[i];
   \   00000018   00C0D3E7           LDRB     R12,[R3, +R0]
    221          		unsigned char c2 = str2[i];
   \   0000001C   0140D3E7           LDRB     R4,[R3, +R1]
    222          
    223          		if (c1 >= 'A' && c1 <= 'Z') c1 = c1 - 'A' + 'a';
   \   00000020   41005CE3           CMP      R12,#+65
   \   00000024   0200003A           BCC      ??strnicmp_4
   \   00000028   5B005CE3           CMP      R12,#+91
   \   0000002C   20C08C32           ADDCC    R12,R12,#+32
   \   00000030   FFC00C32           ANDCC    R12,R12,#0xFF
    224          		if (c2 >= 'A' && c2 <= 'Z') c2 = c2 - 'A' + 'a';
   \                     ??strnicmp_4:
   \   00000034   410054E3           CMP      R4,#+65
   \   00000038   0200003A           BCC      ??strnicmp_5
   \   0000003C   5B0054E3           CMP      R4,#+91
   \   00000040   20408432           ADDCC    R4,R4,#+32
   \   00000044   FF400432           ANDCC    R4,R4,#0xFF
    225          		if (c1 < c2) return -1;
   \                     ??strnicmp_5:
   \   00000048   04005CE1           CMP      R12,R4
   \   0000004C   0000E033           MVNCC    R0,#+0
   \   00000050   0500003A           BCC      ??strnicmp_6
    226          		if (c1 > c2) return +1;
   \   00000054   0C0054E1           CMP      R4,R12
   \   00000058   0100A033           MOVCC    R0,#+1
   \   0000005C   0200003A           BCC      ??strnicmp_6
    227          		if (c1 == 0) return 0;
   \   00000060   00005CE3           CMP      R12,#+0
   \   00000064   E8FFFF1A           BNE      ??strnicmp_2
   \                     ??strnicmp_3:
   \   00000068   0000A0E3           MOV      R0,#+0
   \                     ??strnicmp_6:
   \   0000006C   1000BDE8           POP      {R4}
   \   00000070   1EFF2FE1           BX       LR               ;; return
    228          	}
    229          	return 0;
    230          }
    231          

   \                                 In segment CODE, align 4, keep-with-next
    232          int EnumIni(int local, const wchar_t *ininame, INIPROC proc)
    233          {
   \                     ??EnumIni:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   80DF4DE2           SUB      SP,SP,#+512
   \   00000008   0160A0E1           MOV      R6,R1
   \   0000000C   0240A0E1           MOV      R4,R2
    234            int res=0;
   \   00000010   0070A0E3           MOV      R7,#+0
    235            char *buf;
    236            char *cfg;
    237            int ch;
    238            int p=0;
    239            char name[MAX_INIBUF];
    240            char value[MAX_INIBUF];
    241            const wchar_t* fn=NULL;
    242            unsigned int size_cfg;
    243            fn=ininame;
    244            if (local)
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   0100000A           BEQ      ??EnumIni_1
    245            {
    246              w_chdir(mcpath);
   \   0000001C   6C019FE5           LDR      R0,??EnumIni_2   ;; mcpath
   \   00000020   F70200EF           SWI      +759
    247            }
    248            int f;
    249            int is_utf8=0;
   \                     ??EnumIni_1:
   \   00000024   0050A0E3           MOV      R5,#+0
    250            if (fn && (f = w_fopen(fn, WA_Read, 0x1FF, NULL)) >=0)
   \   00000028   000056E3           CMP      R6,#+0
   \   0000002C   5400000A           BEQ      ??EnumIni_3
   \   00000030   0030A0E3           MOV      R3,#+0
   \   00000034   FF20A0E3           MOV      R2,#+255
   \   00000038   402F82E3           ORR      R2,R2,#0x100
   \   0000003C   0110A0E3           MOV      R1,#+1
   \   00000040   0600A0E1           MOV      R0,R6
   \   00000044   F80200EF           SWI      +760
   \   00000048   0060B0E1           MOVS     R6,R0
   \   0000004C   4C00004A           BMI      ??EnumIni_3
    251            {
    252              size_cfg = w_lseek(f,0,WSEEK_END);
   \   00000050   0120A0E3           MOV      R2,#+1
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   FC0200EF           SWI      +764
   \   0000005C   0090A0E1           MOV      R9,R0
    253              w_lseek(f, 0, WSEEK_SET);
   \   00000060   0220A0E3           MOV      R2,#+2
   \   00000064   0510A0E1           MOV      R1,R5
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   FC0200EF           SWI      +764
    254              cfg = buf = new char[size_cfg + 1];
   \   00000070   010089E2           ADD      R0,R9,#+1
   \   00000074   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000078   0070A0E1           MOV      R7,R0
   \   0000007C   0780B0E1           MOVS     R8,R7
    255              if (cfg)
   \   00000080   3A00000A           BEQ      ??EnumIni_4
    256              {
    257                size_cfg = w_fread(f, buf, size_cfg);
   \   00000084   0920A0E1           MOV      R2,R9
   \   00000088   0710A0E1           MOV      R1,R7
   \   0000008C   0600A0E1           MOV      R0,R6
   \   00000090   FB0200EF           SWI      +763
   \   00000094   0090A0E1           MOV      R9,R0
    258                buf[size_cfg] = 0;
   \   00000098   0000A0E3           MOV      R0,#+0
   \   0000009C   0700C9E7           STRB     R0,[R9, +R7]
    259                if (size_cfg>3)
   \   000000A0   040059E3           CMP      R9,#+4
   \   000000A4   0700003A           BCC      ??EnumIni_5
    260                {
    261                  if (buf[0]==0xEF && buf[1]==0xBB && buf[2]==0xBF) 
   \   000000A8   0000D7E5           LDRB     R0,[R7, #+0]
   \   000000AC   EF0050E3           CMP      R0,#+239
   \   000000B0   0100D705           LDRBEQ   R0,[R7, #+1]
   \   000000B4   BB005003           CMPEQ    R0,#+187
   \   000000B8   0200D705           LDRBEQ   R0,[R7, #+2]
   \   000000BC   BF005003           CMPEQ    R0,#+191
    262                  {
    263                    is_utf8=1;
   \   000000C0   0150A003           MOVEQ    R5,#+1
    264                    buf+=3;
   \   000000C4   03708702           ADDEQ    R7,R7,#+3
    265                  }
    266                }
    267                do
    268                {
    269                  // Камент
    270                  if (*buf == ';')
   \                     ??EnumIni_5:
   \   000000C8   0000D7E5           LDRB     R0,[R7, #+0]
   \   000000CC   3B0050E3           CMP      R0,#+59
   \   000000D0   0500001A           BNE      ??EnumIni_6
    271                  {
    272                    while( ((ch = *buf++) >= 32));
   \                     ??EnumIni_7:
   \   000000D4   ........           LDRB     R9,[R7], #+1
   \   000000D8   200059E3           CMP      R9,#+32
   \   000000DC   FCFFFFAA           BGE      ??EnumIni_7
    273                    if (!ch) break;
   \   000000E0   000059E3           CMP      R9,#+0
   \   000000E4   1F00001A           BNE      ??EnumIni_8
   \   000000E8   200000EA           B        ??EnumIni_4
    274                    else continue;
    275                  }
    276                  // Название
    277                  p=0;
   \                     ??EnumIni_6:
   \   000000EC   0000A0E3           MOV      R0,#+0
   \   000000F0   0D10A0E1           MOV      R1,SP
   \   000000F4   020000EA           B        ??EnumIni_9
    278                  while( (ch = *buf++) != '=')
    279                  {
    280                    if (ch < 32) break;
    281                    if (p < MAX_INIBUF-1) name[p++] = ch;
   \                     ??EnumIni_10:
   \   000000F8   FF0050E3           CMP      R0,#+255
   \   000000FC   0190C0B7           STRBLT   R9,[R0, +R1]
   \   00000100   010080B2           ADDLT    R0,R0,#+1
   \                     ??EnumIni_9:
   \   00000104   ........           LDRB     R9,[R7], #+1
   \   00000108   3D0059E3           CMP      R9,#+61
   \   0000010C   0100000A           BEQ      ??EnumIni_11
   \   00000110   200059E3           CMP      R9,#+32
   \   00000114   F7FFFFAA           BGE      ??EnumIni_10
    282                  }
    283                  if (ch < 32) continue;
   \                     ??EnumIni_11:
   \   00000118   200059E3           CMP      R9,#+32
   \   0000011C   110000BA           BLT      ??EnumIni_8
    284                  name[p]=0;
   \   00000120   0020A0E3           MOV      R2,#+0
   \   00000124   0120C0E7           STRB     R2,[R0, +R1]
    285                  
    286                  // Значение
    287                  p=0;
   \   00000128   0000A0E3           MOV      R0,#+0
   \   0000012C   401F8DE2           ADD      R1,SP,#+256
   \   00000130   020000EA           B        ??EnumIni_12
    288                  while( (ch = *buf++) >= 32 )
    289                  {
    290                    if (p < MAX_INIBUF-1) value[p++] = ch;
   \                     ??EnumIni_13:
   \   00000134   FF0050E3           CMP      R0,#+255
   \   00000138   0190C0B7           STRBLT   R9,[R0, +R1]
   \   0000013C   010080B2           ADDLT    R0,R0,#+1
    291                  }
   \                     ??EnumIni_12:
   \   00000140   ........           LDRB     R9,[R7], #+1
   \   00000144   200059E3           CMP      R9,#+32
   \   00000148   F9FFFFAA           BGE      ??EnumIni_13
    292                  value[p]=0;
   \   0000014C   0120C0E7           STRB     R2,[R0, +R1]
    293                  if (proc)
   \   00000150   000054E3           CMP      R4,#+0
   \   00000154   0300000A           BEQ      ??EnumIni_8
    294                    proc(name, value, is_utf8);
   \   00000158   0520A0E1           MOV      R2,R5
   \   0000015C   0D00A0E1           MOV      R0,SP
   \   00000160   0430A0E1           MOV      R3,R4
   \   00000164   33FF2FE1           BLX      R3
    295                }
    296                while (ch);
   \                     ??EnumIni_8:
   \   00000168   000059E3           CMP      R9,#+0
   \   0000016C   D5FFFF1A           BNE      ??EnumIni_5
    297              }
    298              delete (cfg);
   \                     ??EnumIni_4:
   \   00000170   0800A0E1           MOV      R0,R8
   \   00000174   ........           _BLF     `??operator delete`,`??operator delete??rA`
    299              w_fclose(f);
   \   00000178   0600A0E1           MOV      R0,R6
   \   0000017C   FD0200EF           SWI      +765
    300              res = 1;
   \   00000180   0170A0E3           MOV      R7,#+1
    301            }
    302            return res;
   \                     ??EnumIni_3:
   \   00000184   0700A0E1           MOV      R0,R7
   \   00000188   80DF8DE2           ADD      SP,SP,#+512
   \   0000018C   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??EnumIni_2:
   \   00000190   ........           DC32     mcpath
    303          }
    304          

   \                                 In segment CODE, align 4, keep-with-next
    305          wchar_t *attr2s(int attr, wchar_t *buf)
    306          {
    307            *buf++=attr & 0x124?L'r':L'-';
   \                     ??attr2s:
   \   00000000   022081E2           ADD      R2,R1,#+2
   \   00000004   490F10E3           TST      R0,#0x124
   \   00000008   7230A013           MOVNE    R3,#+114
   \   0000000C   2D30A003           MOVEQ    R3,#+45
   \   00000010   B030C1E1           STRH     R3,[R1, #+0]
    308            *buf++=attr & 0x92?L'w':L'-';
   \   00000014   021082E2           ADD      R1,R2,#+2
   \   00000018   920010E3           TST      R0,#0x92
   \   0000001C   7730A013           MOVNE    R3,#+119
   \   00000020   2D30A003           MOVEQ    R3,#+45
   \   00000024   B030C2E1           STRH     R3,[R2, #+0]
    309            *buf++=attr & 0x49?L'x':L'-';
   \   00000028   022081E2           ADD      R2,R1,#+2
   \   0000002C   490010E3           TST      R0,#0x49
   \   00000030   7830A013           MOVNE    R3,#+120
   \   00000034   2D30A003           MOVEQ    R3,#+45
   \   00000038   B030C1E1           STRH     R3,[R1, #+0]
    310            *buf++=attr & FA_DIRECTORY?L'd':L'-';
   \   0000003C   021082E2           ADD      R1,R2,#+2
   \   00000040   400C10E3           TST      R0,#0x4000
   \   00000044   6400A013           MOVNE    R0,#+100
   \   00000048   2D00A003           MOVEQ    R0,#+45
   \   0000004C   B000C2E1           STRH     R0,[R2, #+0]
    311            *buf = 0;
   \   00000050   0000A0E3           MOV      R0,#+0
   \   00000054   B000C1E1           STRH     R0,[R1, #+0]
    312            return buf;
   \   00000058   0100A0E1           MOV      R0,R1
   \   0000005C   1EFF2FE1           BX       LR               ;; return
    313          }

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant L"\\x2a\\x3f">`:
   \   00000000   2A003F000000       DC8 2AH, 0, 3FH, 0, 0, 0
   \   00000006   0000               DC8 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%.2f">`:
   \   00000000   252E326600         DC8 "%.2f"
   \   00000005   000000             DC8 0, 0, 0
   \   00000008   250073002000       DC8 25H, 0, 73H, 0, 20H, 0, 25H, 0
   \              2500        
   \   00000010   6C0073000000       DC8 6CH, 0, 73H, 0, 0, 0
   \   00000016   0000               DC8 0, 0

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   256400             DC8 "%d"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant L"\\x25\\x2e\\x32\\x64\\x2e\\x25\\x2e\\x32\\`:
   \   00000000   25002E003200       DC8 25H, 0, 2EH, 0, 32H, 0, 64H, 0
   \              6400        
   \   00000008   2E0025002E00       DC8 2EH, 0, 25H, 0, 2EH, 0, 32H, 0
   \              3200        
   \   00000010   64002E002500       DC8 64H, 0, 2EH, 0, 25H, 0, 2EH, 0
   \              2E00        
   \   00000018   320064002000       DC8 32H, 0, 64H, 0, 20H, 0, 25H, 0
   \              2500        
   \   00000020   2E0032006400       DC8 2EH, 0, 32H, 0, 64H, 0, 3AH, 0
   \              3A00        
   \   00000028   25002E003200       DC8 25H, 0, 2EH, 0, 32H, 0, 64H, 0
   \              6400        
   \   00000030   0000               DC8 0, 0
   \   00000032   0000               DC8 0, 0

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     EnumIni(int, wchar_t const *, INIPROC)
                                      540
     attr2s(int, wchar_t *)             0
     cutname(wchar_t *, wchar_t *, int)
                                        4
     getLVC(wchar_t *, int)            24
     isNumericWstr(wchar_t *)           0
     match(wchar_t *, wchar_t *)       16
     stricmp(char *, char *)            4
     strnicmp(char *, char *, int)     12
     strpbrkw(wchar_t const *, wchar_t const *)
                                        0
     strreplace(char *, char, char)     0
     strtolower(char *, char *, int)
                                       16
     sz2s(unsigned int, wchar_t *)     88
     unixt2s(unsigned int, wchar_t *)
                                       32
     wcharlow(wchar_t)                  0
     wstrreplace(wchar_t *, wchar_t, wchar_t)
                                        0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _ss                               8
     _lsls                            20
     _ls_ls                           16
     _ls_stars                        12
     str_empty                         2
     _d                                8
     _ls_i_ls                         24
     strtolower(char *, char *, int)
                                     120
     strreplace(char *, char, char)   40
     wstrreplace(wchar_t *, wchar_t, wchar_t)
                                      40
     isNumericWstr(wchar_t *)         76
     wcharlow(wchar_t)               432
     strpbrkw(wchar_t const *, wchar_t const *)
                                      56
     match(wchar_t *, wchar_t *)     332
     sz2s(unsigned int, wchar_t *)   244
     unixt2s(unsigned int, wchar_t *)
                                      88
     getLVC(wchar_t *, int)          176
     cutname(wchar_t *, wchar_t *, int)
                                      80
     stricmp(char *, char *)           8
     strnicmp(char *, char *, int)   116
     EnumIni(int, wchar_t const *, INIPROC)
                                     404
     attr2s(int, wchar_t *)           96
     ?<Constant L"\x2a\x3f">           8
     ?<Constant "%.2f">               24
     ?<Constant "%d">                  3
     ?<Constant L"\x25\x2e\x32\x64\x2e\x25\x2e\x32\
                                      52
      Others                         144

 
 2 452 bytes in segment CODE
   177 bytes in segment DATA_C
 
 2 308 bytes of CODE  memory (+ 144 bytes shared)
   177 bytes of CONST memory

Errors: none
Warnings: none
