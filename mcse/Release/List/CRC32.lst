##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Jun/2013  22:45:53 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\ZLib\CRC3 #
#                       2.C                                                  #
#    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\ZLib\CRC3 #
#                       2.C -D LOG -D USEZLIB -lCN                           #
#                       Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\ -la Z:\home\perk11\www\perk11.info\svn\SE\mcse\ #
#                       Release\List\ -o Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\Release\Obj\ -s9 --no_unroll                 #
#                       --no_code_motion --cpu_mode arm --endian little      #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config Z:\home\perk11\IAR2\arm\LIB #
#                       \dl5tpainl8n.h -I Z:\home\perk11\IAR2\arm\INC\       #
#                       --inline_threshold=2                                 #
#    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\CRC32.lst                                        #
#    Object file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\O #
#                       bj\CRC32.r79                                         #
#                                                                            #
#                                                                            #
##############################################################################

Z:\home\perk11\www\perk11.info\svn\SE\mcse\ZLib\CRC32.C
      1          /* crc32.c -- compute the CRC-32 of a data stream
      2           * Copyright (C) 1995-2005 Mark Adler
      3           * For conditions of distribution and use, see copyright notice in zlib.h
      4           *
      5           * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
      6           * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
      7           * tables for updating the shift register in one step with three exclusive-ors
      8           * instead of four steps with four exclusive-ors.  This results in about a
      9           * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
     10           */
     11          
     12          /* @(#) $Id$ */
     13          
     14          /*
     15            Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
     16            protection on the static variables used to control the first-use generation
     17            of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
     18            first call get_crc_table() to initialize the tables before allowing more than
     19            one thread to use crc32().
     20           */
     21          
     22          #ifdef MAKECRCH
     23          //#  include <stdio.h>
     24          #  ifndef DYNAMIC_CRC_TABLE
     25          #    define DYNAMIC_CRC_TABLE
     26          #  endif /* !DYNAMIC_CRC_TABLE */
     27          #endif /* MAKECRCH */
     28          
     29          #include "..\..\include\types.h"
     30          #include "zutil.h"      /* for STDC and FAR definitions */
     31          
     32          #define local static
     33          
     34          /* Find a four-byte integer type for crc32_little() and crc32_big(). */
     35          #ifndef NOBYFOUR
     36          #  ifdef STDC           /* need ANSI C limits.h to determine sizes */
     37          //#    include <limits.h>
     38          #    define BYFOUR
     39          #    if (UINT_MAX == 0xffffffffUL)
     40                 typedef unsigned int u4;
     41          #    else
     42          #      if (ULONG_MAX == 0xffffffffUL)
     43                   typedef unsigned long u4;
     44          #      else
     45          #        if (USHRT_MAX == 0xffffffffUL)
     46                     typedef unsigned short u4;
     47          #        else
     48          #          undef BYFOUR     /* can't find a four-byte integer type! */
     49          #        endif
     50          #      endif
     51          #    endif
     52          #  endif /* STDC */
     53          #endif /* !NOBYFOUR */
     54          
     55          /* Definitions for doing the crc four data bytes at a time. */
     56          #ifdef BYFOUR
     57          #  define REV(w) (((w)>>24)+(((w)>>8)&0xff00)+ \
     58                          (((w)&0xff00)<<8)+(((w)&0xff)<<24))
     59             local unsigned long crc32_little OF((unsigned long,
     60                                  const unsigned char FAR *, unsigned));
     61             local unsigned long crc32_big OF((unsigned long,
     62                                  const unsigned char FAR *, unsigned));
     63          #  define TBLS 8
     64          #else
     65          #  define TBLS 1
     66          #endif /* BYFOUR */
     67          
     68          /* Local functions for crc concatenation */
     69          local unsigned long gf2_matrix_times OF((unsigned long *mat,
     70                                                   unsigned long vec));
     71          local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
     72          
     73          #ifdef DYNAMIC_CRC_TABLE
     74          
     75          local volatile int crc_table_empty = 1;
     76          local unsigned long FAR crc_table[TBLS][256];
     77          local void make_crc_table OF((void));
     78          #ifdef MAKECRCH
     79             local void write_table OF((FILE *, const unsigned long FAR *));
     80          #endif /* MAKECRCH */
     81          /*
     82            Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
     83            x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
     84          
     85            Polynomials over GF(2) are represented in binary, one bit per coefficient,
     86            with the lowest powers in the most significant bit.  Then adding polynomials
     87            is just exclusive-or, and multiplying a polynomial by x is a right shift by
     88            one.  If we call the above polynomial p, and represent a byte as the
     89            polynomial q, also with the lowest power in the most significant bit (so the
     90            byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
     91            where a mod b means the remainder after dividing a by b.
     92          
     93            This calculation is done using the shift-register method of multiplying and
     94            taking the remainder.  The register is initialized to zero, and for each
     95            incoming bit, x^32 is added mod p to the register if the bit is a one (where
     96            x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
     97            x (which is shifting right by one and adding x^32 mod p if the bit shifted
     98            out is a one).  We start with the highest power (least significant bit) of
     99            q and repeat for all eight bits of q.
    100          
    101            The first table is simply the CRC of all possible eight bit values.  This is
    102            all the information needed to generate CRCs on data a byte at a time for all
    103            combinations of CRC register values and incoming bytes.  The remaining tables
    104            allow for word-at-a-time CRC calculation for both big-endian and little-
    105            endian machines, where a word is four bytes.
    106          */
    107          local void make_crc_table()
    108          {
    109              unsigned long c;
    110              int n, k;
    111              unsigned long poly;                 /* polynomial exclusive-or pattern */
    112              /* terms of polynomial defining this crc (except x^32): */
    113              static volatile int first = 1;      /* flag to limit concurrent making */
    114              static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
    115          
    116              /* See if another task is already doing this (not thread-safe, but better
    117                 than nothing -- significantly reduces duration of vulnerability in
    118                 case the advice about DYNAMIC_CRC_TABLE is ignored) */
    119              if (first) {
    120                  first = 0;
    121          
    122                  /* make exclusive-or pattern from polynomial (0xedb88320UL) */
    123                  poly = 0UL;
    124                  for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)
    125                      poly |= 1UL << (31 - p[n]);
    126          
    127                  /* generate a crc for every 8-bit value */
    128                  for (n = 0; n < 256; n++) {
    129                      c = (unsigned long)n;
    130                      for (k = 0; k < 8; k++)
    131                          c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    132                      crc_table[0][n] = c;
    133                  }
    134          
    135          #ifdef BYFOUR
    136                  /* generate crc for each value followed by one, two, and three zeros,
    137                     and then the byte reversal of those as well as the first table */
    138                  for (n = 0; n < 256; n++) {
    139                      c = crc_table[0][n];
    140                      crc_table[4][n] = REV(c);
    141                      for (k = 1; k < 4; k++) {
    142                          c = crc_table[0][c & 0xff] ^ (c >> 8);
    143                          crc_table[k][n] = c;
    144                          crc_table[k + 4][n] = REV(c);
    145                      }
    146                  }
    147          #endif /* BYFOUR */
    148          
    149                  crc_table_empty = 0;
    150              }
    151              else {      /* not first */
    152                  /* wait for the other guy to finish (not efficient, but rare) */
    153                  while (crc_table_empty)
    154                      ;
    155              }
    156          
    157          #ifdef MAKECRCH
    158              /* write out CRC tables to crc32.h */
    159              {
    160                  FILE *out;
    161          
    162                  out = fopen("crc32.h", "w");
    163                  if (out == NULL) return;
    164                  fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
    165                  fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
    166                  fprintf(out, "local const unsigned long FAR ");
    167                  fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
    168                  write_table(out, crc_table[0]);
    169          #  ifdef BYFOUR
    170                  fprintf(out, "#ifdef BYFOUR\n");
    171                  for (k = 1; k < 8; k++) {
    172                      fprintf(out, "  },\n  {\n");
    173                      write_table(out, crc_table[k]);
    174                  }
    175                  fprintf(out, "#endif\n");
    176          #  endif /* BYFOUR */
    177                  fprintf(out, "  }\n};\n");
    178                  fclose(out);
    179              }
    180          #endif /* MAKECRCH */
    181          }
    182          
    183          #ifdef MAKECRCH
    184          local void write_table(out, table)
    185              FILE *out;
    186              const unsigned long FAR *table;
    187          {
    188              int n;
    189          
    190              for (n = 0; n < 256; n++)
    191                  fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ", table[n],
    192                          n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
    193          }
    194          #endif /* MAKECRCH */
    195          
    196          #else /* !DYNAMIC_CRC_TABLE */
    197          /* ========================================================================
    198           * Tables of CRC-32s of all single-byte values, made by make_crc_table().
    199           */
    200          #include "crc32.h"

   \                                 In segment DATA_C, align 4, align-sorted
   \   static unsigned long const __data crc_table[1][256]
   \                     crc_table:
   \   00000000   000000009630       DC32 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615
   \              07772C610EEE
   \              BA51099919C4
   \              6D078FF46A70
   \   00000018   35A563E9A395       DC32 3915621685, 2657392035, 249268274, 2044508324, 3772115230
   \              649E3288DB0E
   \              A4B8DC791EE9
   \              D5E0        
   \   0000002C   88D9D2972B4C       DC32 2547177864, 162941995, 2125561021, 3887607047, 2428444049
   \              B609BD7CB17E
   \              072DB8E7911D
   \              BF90        
   \   00000040   6410B71DF220       DC32 498536548, 1789927666, 4089016648, 2227061214, 450548861
   \              B06A4871B9F3
   \              DE41BE847DD4
   \              DA1A        
   \   00000054   EBE4DD6D51B5       DC32 1843258603, 4107580753, 2211677639, 325883990, 1684777152
   \              D4F4C785D383
   \              56986C13C0A8
   \              6B64        
   \   00000068   7AF962FDECC9       DC32 4251122042, 2321926636, 335633487, 1661365465, 4195302755
   \              658A4F5C0114
   \              D96C0663633D
   \              0FFA        
   \   0000007C   F50D088DC820       DC32 2366115317, 997073096, 1281953886, 3579855332, 2724688242
   \              6E3B5E10694C
   \              E44160D57271
   \              67A2        
   \   00000090   D1E4033C47D4       DC32 1006888145, 1258607687, 3524101629, 2768942443, 901097722
   \              044BFD850DD2
   \              6BB50AA5FAA8
   \              B535        
   \   000000A4   6C98B242D6C9       DC32 1119000684, 3686517206, 2898065728, 853044451, 1172266101
   \              BBDB40F9BCAC
   \              E36CD832755C
   \              DF45        
   \   000000B8   CF0DD6DC593D       DC32 3705015759, 2882616665, 651767980, 1373503546, 3369554304
   \              D1ABAC30D926
   \              3A00DE518051
   \              D7C8        
   \   000000CC   1661D0BFB5F4       DC32 3218104598, 565507253, 1454621731, 3485111705, 3099436303
   \              B42123C4B356
   \              9995BACF0FA5
   \              BDB8        
   \   000000E0   9EB802280888       DC32 671266974, 1594198024, 3322730930, 2970347812, 795835527
   \              055FB2D90CC6
   \              24E90BB1877C
   \              6F2F        
   \   000000F4   114C6858AB1D       DC32 1483230225, 3244367275, 3060149565, 1994146192, 31158534
   \              61C13D2D66B6
   \              9041DC760671
   \              DB01        
   \   00000108   BC20D2982A10       DC32 2563907772, 4023717930, 1907459465, 112637215, 2680153253
   \              D5EF8985B171
   \              1FB5B606A5E4
   \              BF9F        
   \   0000011C   33D4B8E8A2C9       DC32 3904427059, 2013776290, 251722036, 2517215374, 3775830040
   \              077834F9000F
   \              8EA809961898
   \              0EE1        
   \   00000130   BB0D6A7F2D3D       DC32 2137656763, 141376813, 2439277719, 3865271297, 1802195444
   \              6D08976C6491
   \              015C63E6F451
   \              6B6B        
   \   00000144   62616C1CD830       DC32 476864866, 2238001368, 4066508878, 1812370925, 453092731
   \              65854E0062F2
   \              ED95066C7BA5
   \              011B        
   \   00000158   C1F4088257C4       DC32 2181625025, 4111451223, 1706088902, 314042704, 2344532202
   \              0FF5C6D9B065
   \              50E9B712EAB8
   \              BE8B        
   \   0000016C   7C88B9FCDF1D       DC32 4240017532, 1658658271, 366619977, 2362670323, 4224994405
   \              DD62492DDA15
   \              F37CD38C654C
   \              D4FB        
   \   00000180   5861B24DCE51       DC32 1303535960, 984961486, 2747007092, 3569037538, 1256170817
   \              B53A7400BCA3
   \              E230BBD441A5
   \              DF4A        
   \   00000194   D795D83D6DC4       DC32 1037604311, 2765210733, 3554079995, 1131014506, 879679996
   \              D1A4FBF4D6D3
   \              6AE96943FCD9
   \              6E34        
   \   000001A8   468867ADD0B8       DC32 2909243462, 3663771856, 1141124467, 855842277, 2852801631
   \              60DA732D0444
   \              E51D03335F4C
   \              0AAA        
   \   000001BC   C97C0DDD3C71       DC32 3708648649, 1342533948, 654459306, 3188396048, 3373015174
   \              0550AA410227
   \              10100BBE8620
   \              0CC9        
   \   000001D0   25B56857B385       DC32 1466479909, 544179635, 3110523913, 3462522015, 1591671054
   \              6F2009D466B9
   \              9FE461CE0EF9
   \              DE5E        
   \   000001E4   98C9D9292298       DC32 702138776, 2966460450, 3352799412, 1504918807, 783551873
   \              D0B0B4A8D7C7
   \              173DB359810D
   \              B42E        
   \   000001F8   3B5CBDB7AD6C       DC32 3082640443, 3233442989, 3988292384, 2596254646, 62317068
   \              BAC02083B8ED
   \              B6B3BF9A0CE2
   \              B603        
   \   0000020C   9AD2B1743947       DC32 1957810842, 3939845945, 2647816111, 81470997, 1943803523
   \              D5EAAF77D29D
   \              1526DB048316
   \              DC73        
   \   00000220   120B63E3843B       DC32 3814918930, 2489596804, 225274430, 2053790376, 3826175755
   \              64943E6A6D0D
   \              A85A6A7A0BCF
   \              0EE4        
   \   00000234   9DFF099327AE       DC32 2466906013, 167816743, 2097651377, 4027552580, 2265490386
   \              000AB19E077D
   \              44930FF0D2A3
   \              0887        
   \   00000248   68F2011EFEC2       DC32 503444072, 1762050814, 4150417245, 2154129355, 426522225
   \              06695D5762F7
   \              CB6765807136
   \              6C19        
   \   0000025C   E7066B6E761B       DC32 1852507879, 4275313526, 2312317920, 282753626, 1742555852
   \              D4FEE02BD389
   \              5A7ADA10CC4A
   \              DD67        
   \   00000270   6FDFB9F9F9EF       DC32 4189708143, 2394877945, 397917763, 1622183637, 3604390888
   \              BE8E43BEB717
   \              D58EB060E8A3
   \              D6D6        
   \   00000284   7E93D1A1C4C2       DC32 2714866558, 953729732, 1340076626, 3518719985, 2797360999
   \              D83852F2DF4F
   \              F167BBD16757
   \              BCA6        
   \   00000298   DD06B53F4B36       DC32 1068828381, 1219638859, 3624741850, 2936675148, 906185462
   \              B248DA2B0DD8
   \              4C1B0AAFF64A
   \              0336        
   \   000002AC   607A0441C3EF       DC32 1090812512, 3747672003, 2825379669, 829329135, 1181335161
   \              60DF55DF67A8
   \              EF8E6E3179BE
   \              6946        
   \   000002C0   8CB361CB1A83       DC32 3412177804, 3160834842, 628085408, 1382605366, 3423369109
   \              66BCA0D26F25
   \              36E268529577
   \              0CCC        
   \   000002D4   03470BBBB916       DC32 3138078467, 570562233, 1426400815, 3317316542, 2998733608
   \              02222F260555
   \              BE3BBAC5280B
   \              BDB2        
   \   000002E8   925AB42B046A       DC32 733239954, 1555261956, 3268935591, 3050360625, 752459403
   \              B35CA7FFD7C2
   \              31CFD0B58B9E
   \              D92C        
   \   000002FC   1DAEDE5BB0C2       DC32 1541320221, 2607071920, 3965973030, 1969922972, 40735498
   \              649B26F263EC
   \              9CA36A750A93
   \              6D02        
   \   00000310   A906099C3F36       DC32 2617837225, 3943577151, 1913087877, 83908371, 2512341634
   \              0EEB85670772
   \              13570005824A
   \              BF95        
   \   00000324   147AB8E2AE2B       DC32 3803740692, 2075208622, 213261112, 2463272603, 3855990285
   \              B17B381BB60C
   \              9B8ED2920DBE
   \              D5E5        
   \   00000338   B7EFDC7C21DF       DC32 2094854071, 198958881, 2262029012, 4057260610, 1759359992
   \              DB0BD4D2D386
   \              42E2D4F1F8B3
   \              DD68        
   \   0000034C   6E83DA1FCD16       DC32 534414190, 2176718541, 4139329115, 1873836001, 414664567
   \              BE815B26B9F6
   \              E177B06F7747
   \              B718        
   \   00000360   E65A0888706A       DC32 2282248934, 4279200368, 1711684554, 285281116, 2405801727
   \              0FFFCA3B0666
   \              5C0B0111FF9E
   \              658F        
   \   00000374   69AE62F8D3FF       DC32 4167216745, 1634467795, 376229701, 2685067896, 3608007406
   \              6B6145CF6C16
   \              78E20AA0EED2
   \              0DD7        
   \   00000388   5483044EC2B3       DC32 1308918612, 956543938, 2808555105, 3495958263, 1231636301
   \              0339612667A7
   \              F71660D04D47
   \              6949        
   \   0000039C   DB776E3E4A6A       DC32 1047427035, 2932959818, 3654703836, 1088359270, 936918000
   \              D1AEDC5AD6D9
   \              660BDF40F03B
   \              D837        
   \   000003B0   53AEBCA9C59E       DC32 2847714899, 3736837829, 1202900863, 817233897, 3183342108
   \              BBDE7FCFB247
   \              E9FFB5301CF2
   \              BDBD        
   \   000003C4   8AC2BACA3093       DC32 3401237130, 1404277552, 615818150, 3134207493, 3453421203
   \              B353A6A3B424
   \              0536D0BA9306
   \              D7CD        
   \   000003D8   2957DE54BF67       DC32 1423857449, 601450431, 3009837614, 3294710456, 1567103746
   \              D9232E7A66B3
   \              B84A61C4021B
   \              685D        
   \   000003EC   942B6F2A37BE       DC32 711928724, 3020668471, 3272380065, 1510334235, 755167117
   \              0BB4A18E0CC3
   \              1BDF055A8DEF
   \              022D        
    201          #endif /* DYNAMIC_CRC_TABLE */
    202          
    203          /* =========================================================================
    204           * This function can be used by asm versions of crc32()
    205           */

   \                                 In segment CODE, align 4, keep-with-next
    206          const unsigned long FAR * ZEXPORT get_crc_table()
    207          {
    208          #ifdef DYNAMIC_CRC_TABLE
    209              if (crc_table_empty)
    210                  make_crc_table();
    211          #endif /* DYNAMIC_CRC_TABLE */
    212              return (const unsigned long FAR *)crc_table;
   \                     get_crc_table:
   \   00000000   ........           LDR      R0,??DataTable2  ;; crc_table
   \   00000004   1EFF2FE1           BX       LR               ;; return
    213          }
    214          
    215          /* ========================================================================= */
    216          #define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
    217          #define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
    218          
    219          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    220          unsigned long ZEXPORT crc32(
    221              unsigned long crc,
    222              const unsigned char FAR *buf,
    223              unsigned len)
    224          {
    225              if (buf == Z_NULL) return 0UL;
   \                     crc32:
   \   00000000   000051E3           CMP      R1,#+0
   \   00000004   0000A003           MOVEQ    R0,#+0
   \   00000008   1EFF2F01           BXEQ     LR
    226          
    227          #ifdef DYNAMIC_CRC_TABLE
    228              if (crc_table_empty)
    229                  make_crc_table();
    230          #endif /* DYNAMIC_CRC_TABLE */
    231          
    232          #ifdef BYFOUR
    233              if (sizeof(void *) == sizeof(ptrdiff_t)) {
    234                  u4 endian;
    235          
    236                  endian = 1;
    237                  if (*((unsigned char *)(&endian)))
    238                      return crc32_little(crc, buf, len);
    239                  else
    240                      return crc32_big(crc, buf, len);
    241              }
    242          #endif /* BYFOUR */
    243              crc = crc ^ 0xffffffffUL;
   \   0000000C   0030E0E3           MVN      R3,#+0
   \   00000010   000023E0           EOR      R0,R3,R0
   \   00000014   080052E3           CMP      R2,#+8
   \   00000018   2B00003A           BCC      ??crc32_0
    244              while (len >= 8) {
    245                  DO8;
   \                     ??crc32_1:
   \   0000001C   ........           LDRB     R12,[R1], #+1
   \   00000020   ........           LDR      R3,??DataTable2  ;; crc_table
    246                  len -= 8;
   \   00000024   082042E2           SUB      R2,R2,#+8
   \   00000028   00C02CE0           EOR      R12,R12,R0
   \   0000002C   FFC00CE2           AND      R12,R12,#0xFF
   \   00000030   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
    247              }
   \   00000034   080052E3           CMP      R2,#+8
   \   00000038   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   0000003C   ........           LDRB     R12,[R1], #+1
   \   00000040   00C02CE0           EOR      R12,R12,R0
   \   00000044   FFC00CE2           AND      R12,R12,#0xFF
   \   00000048   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
   \   0000004C   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   00000050   ........           LDRB     R12,[R1], #+1
   \   00000054   00C02CE0           EOR      R12,R12,R0
   \   00000058   FFC00CE2           AND      R12,R12,#0xFF
   \   0000005C   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
   \   00000060   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   00000064   ........           LDRB     R12,[R1], #+1
   \   00000068   00C02CE0           EOR      R12,R12,R0
   \   0000006C   FFC00CE2           AND      R12,R12,#0xFF
   \   00000070   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
   \   00000074   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   00000078   ........           LDRB     R12,[R1], #+1
   \   0000007C   00C02CE0           EOR      R12,R12,R0
   \   00000080   FFC00CE2           AND      R12,R12,#0xFF
   \   00000084   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
   \   00000088   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   0000008C   ........           LDRB     R12,[R1], #+1
   \   00000090   00C02CE0           EOR      R12,R12,R0
   \   00000094   FFC00CE2           AND      R12,R12,#0xFF
   \   00000098   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
   \   0000009C   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   000000A0   ........           LDRB     R12,[R1], #+1
   \   000000A4   00C02CE0           EOR      R12,R12,R0
   \   000000A8   FFC00CE2           AND      R12,R12,#0xFF
   \   000000AC   0CC193E7           LDR      R12,[R3, +R12, LSL #+2]
   \   000000B0   20042CE0           EOR      R0,R12,R0, LSR #+8
   \   000000B4   ........           LDRB     R12,[R1], #+1
   \   000000B8   00C02CE0           EOR      R12,R12,R0
   \   000000BC   FFC00CE2           AND      R12,R12,#0xFF
   \   000000C0   0C3193E7           LDR      R3,[R3, +R12, LSL #+2]
   \   000000C4   200423E0           EOR      R0,R3,R0, LSR #+8
   \   000000C8   D3FFFF2A           BCS      ??crc32_1
    248              if (len) do {
   \                     ??crc32_0:
   \   000000CC   ........           LDR      R12,??DataTable2  ;; crc_table
   \   000000D0   000052E3           CMP      R2,#+0
   \   000000D4   0600000A           BEQ      ??crc32_2
    249                  DO1;
   \                     ??crc32_3:
   \   000000D8   ........           LDRB     R3,[R1], #+1
    250              } while (--len);
   \   000000DC   012052E2           SUBS     R2,R2,#+1
   \   000000E0   003023E0           EOR      R3,R3,R0
   \   000000E4   FF3003E2           AND      R3,R3,#0xFF
   \   000000E8   03319CE7           LDR      R3,[R12, +R3, LSL #+2]
   \   000000EC   200423E0           EOR      R0,R3,R0, LSR #+8
   \   000000F0   F8FFFF1A           BNE      ??crc32_3
    251              return crc ^ 0xffffffffUL;
   \                     ??crc32_2:
   \   000000F4   0010E0E3           MVN      R1,#+0
   \   000000F8   000021E0           EOR      R0,R1,R0
   \   000000FC   1EFF2FE1           BX       LR               ;; return
    252          }
    253          
    254          #ifdef BYFOUR
    255          
    256          /* ========================================================================= */
    257          #define DOLIT4 c ^= *buf4++; \
    258                  c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
    259                      crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
    260          #define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
    261          
    262          /* ========================================================================= */
    263          local unsigned long crc32_little(crc, buf, len)
    264              unsigned long crc;
    265              const unsigned char FAR *buf;
    266              unsigned len;
    267          {
    268              register u4 c;
    269              register const u4 FAR *buf4;
    270          
    271              c = (u4)crc;
    272              c = ~c;
    273              while (len && ((ptrdiff_t)buf & 3)) {
    274                  c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    275                  len--;
    276              }
    277          
    278              buf4 = (const u4 FAR *)(const void FAR *)buf;
    279              while (len >= 32) {
    280                  DOLIT32;
    281                  len -= 32;
    282              }
    283              while (len >= 4) {
    284                  DOLIT4;
    285                  len -= 4;
    286              }
    287              buf = (const unsigned char FAR *)buf4;
    288          
    289              if (len) do {
    290                  c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    291              } while (--len);
    292              c = ~c;
    293              return (unsigned long)c;
    294          }
    295          
    296          /* ========================================================================= */
    297          #define DOBIG4 c ^= *++buf4; \
    298                  c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
    299                      crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
    300          #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
    301          
    302          /* ========================================================================= */
    303          local unsigned long crc32_big(crc, buf, len)
    304              unsigned long crc;
    305              const unsigned char FAR *buf;
    306              unsigned len;
    307          {
    308              register u4 c;
    309              register const u4 FAR *buf4;
    310          
    311              c = REV((u4)crc);
    312              c = ~c;
    313              while (len && ((ptrdiff_t)buf & 3)) {
    314                  c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    315                  len--;
    316              }
    317          
    318              buf4 = (const u4 FAR *)(const void FAR *)buf;
    319              buf4--;
    320              while (len >= 32) {
    321                  DOBIG32;
    322                  len -= 32;
    323              }
    324              while (len >= 4) {
    325                  DOBIG4;
    326                  len -= 4;
    327              }
    328              buf4++;
    329              buf = (const unsigned char FAR *)buf4;
    330          
    331              if (len) do {
    332                  c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    333              } while (--len);
    334              c = ~c;
    335              return (unsigned long)(REV(c));
    336          }
    337          
    338          #endif /* BYFOUR */
    339          
    340          #define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
    341          
    342          /* ========================================================================= */
    343          local unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
    344          {
    345              unsigned long sum;
    346          
    347              sum = 0;
    348              while (vec) {
    349                  if (vec & 1)
    350                      sum ^= *mat;
    351                  vec >>= 1;
    352                  mat++;
    353              }
    354              return sum;
    355          }
    356          
    357          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    358          local void gf2_matrix_square(unsigned long *square, unsigned long *mat)
    359          {
   \                     gf2_matrix_square:
   \   00000000   30002DE9           PUSH     {R4,R5}
    360              int n;
    361          
    362              for (n = 0; n < GF2_DIM; n++)
   \   00000004   0020A0E3           MOV      R2,#+0
    363                  square[n] = gf2_matrix_times(mat, mat[n]);
   \                     ??gf2_matrix_square_0:
   \   00000008   023191E7           LDR      R3,[R1, +R2, LSL #+2]
   \   0000000C   01C0A0E1           MOV      R12,R1
   \   00000010   0040A0E3           MOV      R4,#+0
   \   00000014   000053E3           CMP      R3,#+0
   \   00000018   0600000A           BEQ      ??gf2_matrix_square_1
   \                     ??gf2_matrix_square_2:
   \   0000001C   010013E3           TST      R3,#0x1
   \   00000020   00509C15           LDRNE    R5,[R12, #+0]
   \   00000024   A330A0E1           LSR      R3,R3,#+1
   \   00000028   04402510           EORNE    R4,R5,R4
   \   0000002C   04C08CE2           ADD      R12,R12,#+4
   \   00000030   000053E3           CMP      R3,#+0
   \   00000034   F8FFFF1A           BNE      ??gf2_matrix_square_2
   \                     ??gf2_matrix_square_1:
   \   00000038   024180E7           STR      R4,[R0, +R2, LSL #+2]
   \   0000003C   012082E2           ADD      R2,R2,#+1
   \   00000040   200052E3           CMP      R2,#+32
   \   00000044   EFFFFFBA           BLT      ??gf2_matrix_square_0
    364          }
   \   00000048   3000BDE8           POP      {R4,R5}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
    365          
    366          /* ========================================================================= */

   \                                 In segment CODE, align 4, keep-with-next
    367          uLong ZEXPORT crc32_combine(
    368              uLong crc1,
    369              uLong crc2,
    370              z_off_t len2)
    371          {
   \                     crc32_combine:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   40DF4DE2           SUB      SP,SP,#+256
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0060A0E1           MOV      R6,R0
   \   00000010   0250B0E1           MOVS     R5,R2
    372              int n;
    373              unsigned long row;
    374              unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
    375              unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
    376          
    377              /* degenerate case */
    378              if (len2 == 0)
   \   00000014   3500000A           BEQ      ??crc32_combine_0
    379                  return crc1;
    380          
    381              /* put operator for one zero bit in odd */
    382              odd[0] = 0xedb88320L;           /* CRC-32 polynomial */
   \   00000018   D8109FE5           LDR      R1,??crc32_combine_1  ;; 0xffffffffedb88320
    383              row = 1;
   \   0000001C   0100A0E3           MOV      R0,#+1
   \   00000020   80108DE5           STR      R1,[SP, #+128]
    384              for (n = 1; n < GF2_DIM; n++) {
   \   00000024   0110A0E3           MOV      R1,#+1
   \   00000028   80208DE2           ADD      R2,SP,#+128
    385                  odd[n] = row;
   \                     ??crc32_combine_2:
   \   0000002C   010182E7           STR      R0,[R2, +R1, LSL #+2]
    386                  row <<= 1;
   \   00000030   8000A0E1           LSL      R0,R0,#+1
    387              }
   \   00000034   011081E2           ADD      R1,R1,#+1
   \   00000038   200051E3           CMP      R1,#+32
   \   0000003C   FAFFFFBA           BLT      ??crc32_combine_2
    388          
    389              /* put operator for two zero bits in even */
    390              gf2_matrix_square(even, odd);
   \   00000040   80108DE2           ADD      R1,SP,#+128
   \   00000044   0D00A0E1           MOV      R0,SP
   \   00000048   ........           BL       gf2_matrix_square
    391          
    392              /* put operator for four zero bits in odd */
    393              gf2_matrix_square(odd, even);
   \   0000004C   0D10A0E1           MOV      R1,SP
   \   00000050   80008DE2           ADD      R0,SP,#+128
   \   00000054   ........           BL       gf2_matrix_square
    394          
    395              /* apply len2 zeros to crc1 (first square will put the operator for one
    396                 zero byte, eight zero bits, in even) */
    397              do {
    398                  /* apply zeros operator for this bit of len2 */
    399                  gf2_matrix_square(even, odd);
   \                     ??crc32_combine_3:
   \   00000058   80108DE2           ADD      R1,SP,#+128
   \   0000005C   0D00A0E1           MOV      R0,SP
   \   00000060   ........           BL       gf2_matrix_square
    400                  if (len2 & 1)
   \   00000064   010015E3           TST      R5,#0x1
   \   00000068   0B00000A           BEQ      ??crc32_combine_4
    401                      crc1 = gf2_matrix_times(even, crc1);
   \   0000006C   0600A0E1           MOV      R0,R6
   \   00000070   0D10A0E1           MOV      R1,SP
   \   00000074   0060A0E3           MOV      R6,#+0
   \   00000078   000050E3           CMP      R0,#+0
   \   0000007C   0600000A           BEQ      ??crc32_combine_4
   \                     ??crc32_combine_5:
   \   00000080   010010E3           TST      R0,#0x1
   \   00000084   00209115           LDRNE    R2,[R1, #+0]
   \   00000088   A000A0E1           LSR      R0,R0,#+1
   \   0000008C   06602210           EORNE    R6,R2,R6
   \   00000090   041081E2           ADD      R1,R1,#+4
   \   00000094   000050E3           CMP      R0,#+0
   \   00000098   F8FFFF1A           BNE      ??crc32_combine_5
    402                  len2 >>= 1;
   \                     ??crc32_combine_4:
   \   0000009C   C550B0E1           ASRS     R5,R5,#+1
    403          
    404                  /* if no more bits set, then done */
    405                  if (len2 == 0)
   \   000000A0   1100000A           BEQ      ??crc32_combine_6
    406                      break;
    407          
    408                  /* another iteration of the loop with odd and even swapped */
    409                  gf2_matrix_square(odd, even);
   \   000000A4   0D10A0E1           MOV      R1,SP
   \   000000A8   80008DE2           ADD      R0,SP,#+128
   \   000000AC   ........           BL       gf2_matrix_square
    410                  if (len2 & 1)
   \   000000B0   010015E3           TST      R5,#0x1
   \   000000B4   0A00000A           BEQ      ??crc32_combine_7
    411                      crc1 = gf2_matrix_times(odd, crc1);
   \   000000B8   0600B0E1           MOVS     R0,R6
   \   000000BC   80108DE2           ADD      R1,SP,#+128
   \   000000C0   0060A0E3           MOV      R6,#+0
   \   000000C4   0600000A           BEQ      ??crc32_combine_7
   \                     ??crc32_combine_8:
   \   000000C8   010010E3           TST      R0,#0x1
   \   000000CC   00209115           LDRNE    R2,[R1, #+0]
   \   000000D0   A000A0E1           LSR      R0,R0,#+1
   \   000000D4   06602210           EORNE    R6,R2,R6
   \   000000D8   041081E2           ADD      R1,R1,#+4
   \   000000DC   000050E3           CMP      R0,#+0
   \   000000E0   F8FFFF1A           BNE      ??crc32_combine_8
    412                  len2 >>= 1;
   \                     ??crc32_combine_7:
   \   000000E4   C550B0E1           ASRS     R5,R5,#+1
    413          
    414                  /* if no more bits set, then done */
    415              } while (len2 != 0);
   \   000000E8   DAFFFF1A           BNE      ??crc32_combine_3
    416          
    417              /* return combined crc */
    418              crc1 ^= crc2;
    419              return crc1;
   \                     ??crc32_combine_6:
   \   000000EC   060024E0           EOR      R0,R4,R6
   \                     ??crc32_combine_0:
   \   000000F0   40DF8DE2           ADD      SP,SP,#+256      ;; stack cleaning
   \   000000F4   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??crc32_combine_1:
   \   000000F8   2083B8ED           DC32     0xffffffffedb88320
    420          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     crc_table

   Maximum stack usage in bytes:

     Function          CSTACK
     --------          ------
     crc32                 0
     crc32_combine       272
     get_crc_table         0
     gf2_matrix_square     8


   Segment part sizes:

     Function/Label    Bytes
     --------------    -----
     crc_table         1024
     get_crc_table        8
     crc32              256
     gf2_matrix_square   80
     crc32_combine      252
     ??DataTable2         4
      Others             16

 
   616 bytes in segment CODE
 1 024 bytes in segment DATA_C
 
   600 bytes of CODE  memory (+ 16 bytes shared)
 1 024 bytes of CONST memory

Errors: none
Warnings: none
