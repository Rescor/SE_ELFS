##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    10/Jun/2013  22:48:12 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\sort.cpp  #
#    Command line    =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\sort.cpp  #
#                       -D NDEBUG -D USEZLIB -D OLDFUNCTIONS -lCN            #
#                       Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\ -la Z:\home\perk11\www\perk11.info\svn\SE\mcse\ #
#                       Release\List\ -o Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\Release\Obj\ -s9 --no_unroll                 #
#                       --no_code_motion --cpu_mode arm --endian little      #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --enable_multibytes --fpu None --eec++               #
#                       --dlib_config Z:\home\perk11\IAR2\arm\LIB\dl5tpainl8 #
#                       n.h --preinclude Z:\home\perk11\www\perk11.info\svn\ #
#                       SE\mcse\..\deleaker\mem2.h -I                        #
#                       Z:\home\perk11\IAR2\arm\INC\ --inline_threshold=2    #
#    List file       =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\L #
#                       ist\sort.lst                                         #
#    Object file     =  Z:\home\perk11\www\perk11.info\svn\SE\mcse\Release\O #
#                       bj\sort.r79                                          #
#                                                                            #
#                                                                            #
##############################################################################

Z:\home\perk11\www\perk11.info\svn\SE\mcse\sort.cpp
      1          #include "inc\mc.h"
      2          #include "inc\mui.h"
      3          #include "inc\sort.h"
      4          
      5          
      6          typedef struct {
      7          	wchar_t *name;
      8          	wchar_t *ext;
      9          	FILEINF *dataPointer;
     10          } FileSortInfo;
     11          

   \                                 In segment CODE, align 4, keep-with-next
     12          wchar_t* fn_prepare(wchar_t* src, wchar_t* dst)
     13          {
   \                     ??fn_prepare:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     14            int c;
     15            wchar_t *d=dst;
   \   0000000C   0560A0E1           MOV      R6,R5
   \   00000010   010000EA           B        ??fn_prepare_1
     16            while((c=*src++))
     17            {
     18              *d++=wcharlow(c);    
   \                     ??fn_prepare_2:
   \   00000014   ........           _BLF     ??wcharlow,??wcharlow??rA
   \   00000018   ........           STRH     R0,[R6], #+2
     19            }
   \                     ??fn_prepare_1:
   \   0000001C   ........           LDRH     R0,[R4], #+2
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   FAFFFF1A           BNE      ??fn_prepare_2
     20            *d=0;
   \   00000028   B000C6E1           STRH     R0,[R6, #+0]
     21            return (dst);
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   7080BDE8           POP      {R4-R6,PC}       ;; return
     22          }
     23          
     24          // Сравнение имен файлов, если различие только в последних символах и они являются цифрами,
     25          // то цифры обрабатываются как числа

   \                                 In segment CODE, align 4, keep-with-next
     26          int filenamecmp(FileSortInfo* fs1, FileSortInfo* fs2)
     27          {
   \                     ??filenamecmp:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
     28            wchar_t *str1 = fs1->name;
   \   00000004   004090E5           LDR      R4,[R0, #+0]
     29            wchar_t *str2 = fs2->name;
   \   00000008   005091E5           LDR      R5,[R1, #+0]
     30            wchar_t c1 = 0;
     31            wchar_t c2 = 0;
   \   0000000C   010000EA           B        ??filenamecmp_1
     32            
     33            while (1)
     34            {
     35              c1 = *str1;
     36              c2 = *str2;
     37              
     38              if (c1 != c2) break;
     39              if (c1 == 0 && c2 == 0) return 0;
     40              str1++; str2++;
   \                     ??filenamecmp_2:
   \   00000010   024084E2           ADD      R4,R4,#+2
   \   00000014   025085E2           ADD      R5,R5,#+2
   \                     ??filenamecmp_1:
   \   00000018   B060D4E1           LDRH     R6,[R4, #+0]
   \   0000001C   B070D5E1           LDRH     R7,[R5, #+0]
   \   00000020   070056E1           CMP      R6,R7
   \   00000024   1500000A           BEQ      ??filenamecmp_3
     41            }
     42            
     43            // Если попали сюда, то строки не равны
     44            if (wstrcmpi(fs1->ext, fs2->ext) == 0 && isNumericWstr(str1) && isNumericWstr(str2))
   \   00000028   040090E5           LDR      R0,[R0, #+4]
   \   0000002C   041091E5           LDR      R1,[R1, #+4]
   \   00000030   9F0200EF           SWI      +671
   \   00000034   000050E3           CMP      R0,#+0
   \   00000038   1500001A           BNE      ??filenamecmp_4
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           _BLF     ??isNumericWstr,??isNumericWstr??rA
   \   00000044   000050E3           CMP      R0,#+0
   \   00000048   1100000A           BEQ      ??filenamecmp_4
   \   0000004C   0500A0E1           MOV      R0,R5
   \   00000050   ........           _BLF     ??isNumericWstr,??isNumericWstr??rA
   \   00000054   000050E3           CMP      R0,#+0
   \   00000058   0D00000A           BEQ      ??filenamecmp_4
     45            {
     46              // Если расширения одинаковые и неравные подстроки - цифры...
     47              
     48              // если длина меньше, то заведомо и число меньше
     49              // если одинаковая, то идем дальше, т.к. достаточно сравнить только найденные отличающиеся цифры
     50              int ls1 = wstrlen(str1);
   \   0000005C   0400A0E1           MOV      R0,R4
   \   00000060   570100EF           SWI      +343
   \   00000064   0040A0E1           MOV      R4,R0
     51              int ls2 = wstrlen(str2);
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   570100EF           SWI      +343
     52              if (ls1 != ls2) return (ls1 - ls2);
   \   00000070   000054E1           CMP      R4,R0
   \   00000074   0600000A           BEQ      ??filenamecmp_4
   \   00000078   000044E0           SUB      R0,R4,R0
   \   0000007C   F080BDE8           POP      {R4-R7,PC}
     53            }
   \                     ??filenamecmp_3:
   \   00000080   000056E3           CMP      R6,#+0
   \   00000084   00005703           CMPEQ    R7,#+0
   \   00000088   E0FFFF1A           BNE      ??filenamecmp_2
   \   0000008C   0000A0E3           MOV      R0,#+0
   \   00000090   F080BDE8           POP      {R4-R7,PC}
     54            return (c1 - c2);
   \                     ??filenamecmp_4:
   \   00000094   070046E0           SUB      R0,R6,R7
   \   00000098   F080BDE8           POP      {R4-R7,PC}       ;; return
     55          }
     56          

   \                                 In segment CODE, align 4, keep-with-next
     57          int isNameGreater(void* a, void* b)
     58          {
   \                     ??isNameGreater:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
     59            FileSortInfo* fa = (FileSortInfo*)a;
     60            FileSortInfo* fb = (FileSortInfo*)b;
     61            int res = filenamecmp(fa, fb);
   \   0000000C   ........           BL       ??filenamecmp
     62            if (res == 0)
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   0200001A           BNE      ??isNameGreater_1
     63              res = wstrcmpi(fa->ext, fb->ext); // если имена равны то сравниваем расширения
   \   00000018   041095E5           LDR      R1,[R5, #+4]
   \   0000001C   040094E5           LDR      R0,[R4, #+4]
   \   00000020   9F0200EF           SWI      +671
     64            return res > 0;
   \                     ??isNameGreater_1:
   \   00000024   010050E3           CMP      R0,#+1
   \   00000028   0100A0A3           MOVGE    R0,#+1
   \   0000002C   3080BDA8           POPGE    {R4,R5,PC}
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   3080BDE8           POP      {R4,R5,PC}       ;; return
     65          }
     66          

   \                                 In segment CODE, align 4, keep-with-next
     67          int isExtGreater(void* a, void* b)
     68          {
   \                     ??isExtGreater:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     69            FileSortInfo* fa = (FileSortInfo*)a;
     70            FileSortInfo* fb = (FileSortInfo*)b;
     71            int res = wstrcmpi(fa->ext, fb->ext);
   \   00000008   040094E5           LDR      R0,[R4, #+4]
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   041095E5           LDR      R1,[R5, #+4]
   \   00000014   9F0200EF           SWI      +671
     72            if (res == 0)
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0200001A           BNE      ??isExtGreater_1
     73              res = filenamecmp(fa, fb); // если расширения равны то сравниваем имена
   \   00000020   0510A0E1           MOV      R1,R5
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       ??filenamecmp
     74            return  res > 0;
   \                     ??isExtGreater_1:
   \   0000002C   010050E3           CMP      R0,#+1
   \   00000030   0100A0A3           MOVGE    R0,#+1
   \   00000034   3080BDA8           POPGE    {R4,R5,PC}
   \   00000038   0000A0E3           MOV      R0,#+0
   \   0000003C   3080BDE8           POP      {R4,R5,PC}       ;; return
     75          }
     76          

   \                                 In segment CODE, align 4, keep-with-next
     77          int isSizeGreater(void* a, void* b)
     78          {
   \                     ??isSizeGreater:
   \   00000000   00402DE9           PUSH     {LR}
     79            FILEINF* fa = (FILEINF*)a;
     80            FILEINF* fb = (FILEINF*)b;
     81            int res = fa->size - fb->size;
   \   00000004   0C2090E5           LDR      R2,[R0, #+12]
   \   00000008   0C3091E5           LDR      R3,[R1, #+12]
   \   0000000C   032052E0           SUBS     R2,R2,R3
     82            if (res == 0)
   \   00000010   0600001A           BNE      ??isSizeGreater_1
     83              return wstrcmpi(fa->ws_name, fb->ws_name) > 0;
   \   00000014   200090E5           LDR      R0,[R0, #+32]
   \   00000018   201091E5           LDR      R1,[R1, #+32]
   \   0000001C   9F0200EF           SWI      +671
   \   00000020   010050E3           CMP      R0,#+1
   \   00000024   040000BA           BLT      ??isSizeGreater_2
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   0080BDE8           POP      {PC}
     84            else
     85              return res > 0;
   \                     ??isSizeGreater_1:
   \   00000030   010052E3           CMP      R2,#+1
   \   00000034   0100A0A3           MOVGE    R0,#+1
   \   00000038   0080BDA8           POPGE    {PC}
   \                     ??isSizeGreater_2:
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   0080BDE8           POP      {PC}             ;; return
     86          }
     87          

   \                                 In segment CODE, align 4, keep-with-next
     88          int isDateGreater(void* a, void* b)
     89          {
   \                     ??isDateGreater:
   \   00000000   00402DE9           PUSH     {LR}
     90            FILEINF* fa = (FILEINF*)a;
     91            FILEINF* fb = (FILEINF*)b;
     92            int res = fa->time - fb->time;
   \   00000004   142090E5           LDR      R2,[R0, #+20]
   \   00000008   143091E5           LDR      R3,[R1, #+20]
   \   0000000C   032052E0           SUBS     R2,R2,R3
     93            if (res == 0)
   \   00000010   0600001A           BNE      ??isDateGreater_1
     94              return wstrcmpi(fa->ws_name, fb->ws_name) > 0;
   \   00000014   200090E5           LDR      R0,[R0, #+32]
   \   00000018   201091E5           LDR      R1,[R1, #+32]
   \   0000001C   9F0200EF           SWI      +671
   \   00000020   010050E3           CMP      R0,#+1
   \   00000024   040000BA           BLT      ??isDateGreater_2
   \   00000028   0100A0E3           MOV      R0,#+1
   \   0000002C   0080BDE8           POP      {PC}
     95            else
     96              return res > 0;
   \                     ??isDateGreater_1:
   \   00000030   010052E3           CMP      R2,#+1
   \   00000034   0100A0A3           MOVGE    R0,#+1
   \   00000038   0080BDA8           POPGE    {PC}
   \                     ??isDateGreater_2:
   \   0000003C   0000A0E3           MOV      R0,#+0
   \   00000040   0080BDE8           POP      {PC}             ;; return
     97          }
     98          

   \                                 In segment CODE, align 4, keep-with-next
     99          FILEINF* SortList(FILEINF* list, int sort)
    100          {
   \                     ??SortList:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    101            FILEINF* base = list;
   \   00000004   0040A0E1           MOV      R4,R0
    102            int i;
    103            int err = 0;
    104            
    105            int sortType = sort & STV_MASK;
   \   00000008   0F5001E2           AND      R5,R1,#0xF
    106            int isDirectSort = sort & ST_REVERS;
   \   0000000C   406F01E2           AND      R6,R1,#0x100
    107            
    108            // Считаем кол-во элементов
    109            int count = 0;
   \   00000010   0070A0E3           MOV      R7,#+0
    110            FILEINF* cur = base;
   \   00000014   0480B0E1           MOVS     R8,R4
   \   00000018   F08FBD08           POPEQ    {R4-R11,PC}
    111            while (cur)
    112            {
    113              count++;
    114              cur = (FILEINF *)cur->next;
   \                     ??SortList_1:
   \   0000001C   448098E5           LDR      R8,[R8, #+68]
   \   00000020   017087E2           ADD      R7,R7,#+1
    115            }
   \   00000024   000058E3           CMP      R8,#+0
   \   00000028   FBFFFF1A           BNE      ??SortList_1
    116            
    117            // Не сортируем если нет смысла
    118            if (count < 2) return list;
   \   0000002C   020057E3           CMP      R7,#+2
   \   00000030   F08FBDB8           POPLT    {R4-R11,PC}
    119            
    120            if (sortType == ST_NAME || sortType == ST_EXT) // Косвенная сортировка по строкам
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   01005513           CMPNE    R5,#+1
   \   0000003C   6F00001A           BNE      ??SortList_2
    121            {
    122              char buf[MAX_PATH];
    123              FileSortInfo** sortInfo = new FileSortInfo*[count];
   \   00000040   0701A0E1           LSL      R0,R7,#+2
   \   00000044   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000048   0090B0E1           MOVS     R9,R0
    124              
    125              if (buf && sortInfo)
   \   0000004C   A200000A           BEQ      ??SortList_3
    126              {
    127                // Готовим массив
    128                i = 0;
   \   00000050   00A0A0E3           MOV      R10,#+0
    129                cur = base;
   \   00000054   0480A0E1           MOV      R8,R4
    130                while (cur)
    131                {
    132                  sortInfo[i] = new FileSortInfo;
   \                     ??SortList_4:
   \   00000058   0AB189E0           ADD      R11,R9,R10, LSL #+2
   \   0000005C   0C00A0E3           MOV      R0,#+12
   \   00000060   ........           _BLF     `??operator new`,`??operator new??rA`
   \   00000064   00008BE5           STR      R0,[R11, #+0]
    133                  
    134                  if (!sortInfo[i])
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   3F00000A           BEQ      ??SortList_5
    135                  {
    136                    err = 1; break;
    137                  }
    138                  sortInfo[i]->dataPointer = cur;
   \   00000070   088080E5           STR      R8,[R0, #+8]
    139                  sortInfo[i]->name = new wchar_t[MAX_PATH];
   \   00000074   800FA0E3           MOV      R0,#+512
   \   00000078   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   0000007C   00109BE5           LDR      R1,[R11, #+0]
   \   00000080   000081E5           STR      R0,[R1, #+0]
    140                  if (!sortInfo[i]->name)
   \   00000084   00009BE5           LDR      R0,[R11, #+0]
   \   00000088   000090E5           LDR      R0,[R0, #+0]
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   3600000A           BEQ      ??SortList_5
    141                  {
    142                    err = 1; break;
    143                  }
    144                  fn_prepare(cur->ws_name, sortInfo[i]->name);
   \   00000094   00009BE5           LDR      R0,[R11, #+0]
   \   00000098   001090E5           LDR      R1,[R0, #+0]
   \   0000009C   200098E5           LDR      R0,[R8, #+32]
   \   000000A0   ........           BL       ??fn_prepare
    145                  //WriteLog(sortInfo[i]->name);
    146                  // Разбиваем на имя файла и расширение
    147                  sortInfo[i]->ext = GetFileExt(sortInfo[i]->name);
   \   000000A4   00009BE5           LDR      R0,[R11, #+0]
   \   000000A8   000090E5           LDR      R0,[R0, #+0]
   \   000000AC   ........           _BLF     ??GetFileExt,??GetFileExt??rA
   \   000000B0   00109BE5           LDR      R1,[R11, #+0]
   \   000000B4   040081E5           STR      R0,[R1, #+4]
    148                  if (!sortInfo[i]->ext)
   \   000000B8   00009BE5           LDR      R0,[R11, #+0]
   \   000000BC   040090E5           LDR      R0,[R0, #+4]
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   0A0199E7           LDR      R0,[R9, +R10, LSL #+2]
    149                    sortInfo[i]->ext = (wchar_t *)str_empty;
   \   000000C8   20129F05           LDREQ    R1,??SortList_6  ;; str_empty
    150                  else
    151                    *(sortInfo[i]->ext-1) = 0; // вместо точки ставим конец строки
   \   000000CC   04009015           LDRNE    R0,[R0, #+4]
   \   000000D0   0010A013           MOVNE    R1,#+0
   \   000000D4   04108005           STREQ    R1,[R0, #+4]
   \   000000D8   B2104011           STRHNE   R1,[R0, #-2]
    152                  
    153                  cur = (FILEINF *)cur->next;
   \   000000DC   448098E5           LDR      R8,[R8, #+68]
    154                  i++;
   \   000000E0   01A08AE2           ADD      R10,R10,#+1
    155                }
   \   000000E4   000058E3           CMP      R8,#+0
   \   000000E8   DAFFFF1A           BNE      ??SortList_4
    156                if (!err)
    157                {
    158                  // Сортируем
    159                  if (sortType == ST_NAME)
   \   000000EC   000055E3           CMP      R5,#+0
    160                    quickSort((void**)sortInfo, count, isNameGreater);
   \   000000F0   FC219F05           LDREQ    R2,??SortList_6+0x4  ;; ??isNameGreater
   \   000000F4   0200000A           BEQ      ??SortList_7
    161                  else if (sortType == ST_EXT)
   \   000000F8   010055E3           CMP      R5,#+1
   \   000000FC   0300001A           BNE      ??SortList_8
    162                    quickSort((void**)sortInfo, count, isExtGreater);
   \   00000100   F0219FE5           LDR      R2,??SortList_6+0x8  ;; ??isExtGreater
   \                     ??SortList_7:
   \   00000104   0710A0E1           MOV      R1,R7
   \   00000108   0900A0E1           MOV      R0,R9
   \   0000010C   ........           _BLF     ??quickSort,??quickSort??rA
    163                  
    164                  // Переинициируем список и освободим память
    165                  if (isDirectSort)
   \                     ??SortList_8:
   \   00000110   000056E3           CMP      R6,#+0
   \   00000114   2800000A           BEQ      ??SortList_9
    166                  {
    167                    base = sortInfo[0]->dataPointer;
   \   00000118   000099E5           LDR      R0,[R9, #+0]
    168                    for (i = 0; i < count - 1; i++)
   \   0000011C   00A0A0E3           MOV      R10,#+0
   \   00000120   084090E5           LDR      R4,[R0, #+8]
   \   00000124   010047E2           SUB      R0,R7,#+1
   \   00000128   010050E3           CMP      R0,#+1
   \   0000012C   070000AA           BGE      ??SortList_10
   \   00000130   090000EA           B        ??SortList_11
    169                      sortInfo[i]->dataPointer->next = sortInfo[i + 1]->dataPointer;
   \                     ??SortList_12:
   \   00000134   0A0189E0           ADD      R0,R9,R10, LSL #+2
   \   00000138   001090E5           LDR      R1,[R0, #+0]
   \   0000013C   040090E5           LDR      R0,[R0, #+4]
   \   00000140   081091E5           LDR      R1,[R1, #+8]
   \   00000144   080090E5           LDR      R0,[R0, #+8]
   \   00000148   01A08AE2           ADD      R10,R10,#+1
   \   0000014C   440081E5           STR      R0,[R1, #+68]
   \                     ??SortList_10:
   \   00000150   010047E2           SUB      R0,R7,#+1
   \   00000154   00005AE1           CMP      R10,R0
   \   00000158   F5FFFFBA           BLT      ??SortList_12
    170                    sortInfo[count - 1]->dataPointer->next = 0;
   \                     ??SortList_11:
   \   0000015C   070189E0           ADD      R0,R9,R7, LSL #+2
   \   00000160   040010E5           LDR      R0,[R0, #-4]
   \                     ??SortList_13:
   \   00000164   0010A0E3           MOV      R1,#+0
   \   00000168   080090E5           LDR      R0,[R0, #+8]
   \   0000016C   441080E5           STR      R1,[R0, #+68]
    171                  }
    172                  else
    173                  {
    174                    base = sortInfo[count - 1]->dataPointer;
    175                    for (i = count - 1; i > 0; i--)
    176                      sortInfo[i]->dataPointer->next = sortInfo[i - 1]->dataPointer;
    177                    sortInfo[0]->dataPointer->next = 0;
    178                  }
    179                }
    180              }
    181              else
    182              {
    183                MsgBoxError(muitxt(ind_err_nomemory));
    184              }
    185              if (sortInfo)
    186              {
    187                for (i = count - 1; i >= 0; i--)
   \                     ??SortList_5:
   \   00000170   015057E2           SUBS     R5,R7,#+1
   \   00000174   0C00004A           BMI      ??SortList_14
    188                {
    189                  if (sortInfo[i])
   \                     ??SortList_15:
   \   00000178   050199E7           LDR      R0,[R9, +R5, LSL #+2]
   \   0000017C   000050E3           CMP      R0,#+0
   \   00000180   0700000A           BEQ      ??SortList_16
    190                  {
    191                    if (sortInfo[i]->name)
   \   00000184   000090E5           LDR      R0,[R0, #+0]
   \   00000188   000050E3           CMP      R0,#+0
   \   0000018C   0200000A           BEQ      ??SortList_17
    192                      delete(sortInfo[i]->name);
   \   00000190   050199E7           LDR      R0,[R9, +R5, LSL #+2]
   \   00000194   000090E5           LDR      R0,[R0, #+0]
   \   00000198   ........           _BLF     `??operator delete`,`??operator delete??rA`
    193                    delete(sortInfo[i]);
   \                     ??SortList_17:
   \   0000019C   050199E7           LDR      R0,[R9, +R5, LSL #+2]
   \   000001A0   ........           _BLF     `??operator delete`,`??operator delete??rA`
    194                  }
    195                }
   \                     ??SortList_16:
   \   000001A4   015055E2           SUBS     R5,R5,#+1
   \   000001A8   F2FFFF5A           BPL      ??SortList_15
    196                delete(sortInfo);
   \                     ??SortList_14:
   \   000001AC   0900A0E1           MOV      R0,R9
   \   000001B0   ........           _BLF     `??operator delete`,`??operator delete??rA`
   \   000001B4   0400A0E1           MOV      R0,R4
   \   000001B8   F08FBDE8           POP      {R4-R11,PC}
    197              }
   \                     ??SortList_9:
   \   000001BC   070189E0           ADD      R0,R9,R7, LSL #+2
   \   000001C0   040010E5           LDR      R0,[R0, #-4]
   \   000001C4   01A047E2           SUB      R10,R7,#+1
   \   000001C8   084090E5           LDR      R4,[R0, #+8]
   \   000001CC   01005AE3           CMP      R10,#+1
   \   000001D0   080000BA           BLT      ??SortList_18
   \                     ??SortList_19:
   \   000001D4   0A0189E0           ADD      R0,R9,R10, LSL #+2
   \   000001D8   001090E5           LDR      R1,[R0, #+0]
   \   000001DC   040010E5           LDR      R0,[R0, #-4]
   \   000001E0   081091E5           LDR      R1,[R1, #+8]
   \   000001E4   080090E5           LDR      R0,[R0, #+8]
   \   000001E8   01A04AE2           SUB      R10,R10,#+1
   \   000001EC   440081E5           STR      R0,[R1, #+68]
   \   000001F0   01005AE3           CMP      R10,#+1
   \   000001F4   F6FFFFAA           BGE      ??SortList_19
   \                     ??SortList_18:
   \   000001F8   000099E5           LDR      R0,[R9, #+0]
   \   000001FC   D8FFFFEA           B        ??SortList_13
    198            }
    199            else // Прямая сортировка по числам
    200            {
    201              // Готовим массив
    202              FILEINF** sortInfo = new FILEINF*[count];
   \                     ??SortList_2:
   \   00000200   0701A0E1           LSL      R0,R7,#+2
   \   00000204   ........           _BLF     `??operator new[]`,`??operator new[]??rA`
   \   00000208   0090B0E1           MOVS     R9,R0
    203              if (sortInfo)
   \   0000020C   3200000A           BEQ      ??SortList_3
    204              {
    205                i = 0;
   \   00000210   0000A0E3           MOV      R0,#+0
    206                cur = base;
   \   00000214   0480A0E1           MOV      R8,R4
    207                while (cur)
    208                {
    209                  sortInfo[i] = cur;
   \                     ??SortList_20:
   \   00000218   008189E7           STR      R8,[R9, +R0, LSL #+2]
    210                  cur = (FILEINF *)cur->next;
   \   0000021C   448098E5           LDR      R8,[R8, #+68]
    211                  i++;
   \   00000220   010080E2           ADD      R0,R0,#+1
    212                }
   \   00000224   000058E3           CMP      R8,#+0
   \   00000228   FAFFFF1A           BNE      ??SortList_20
    213                // Сортируем
    214                if (sortType == ST_DATE)
   \   0000022C   030055E3           CMP      R5,#+3
    215                  quickSort((void**)sortInfo, count, isDateGreater);
   \   00000230   C4209F05           LDREQ    R2,??SortList_6+0xC  ;; ??isDateGreater
   \   00000234   0200000A           BEQ      ??SortList_21
    216                else if (sortType == ST_SIZE)
   \   00000238   020055E3           CMP      R5,#+2
   \   0000023C   0300001A           BNE      ??SortList_22
    217                  quickSort((void**)sortInfo, count, isSizeGreater);
   \   00000240   B8209FE5           LDR      R2,??SortList_6+0x10  ;; ??isSizeGreater
   \                     ??SortList_21:
   \   00000244   0710A0E1           MOV      R1,R7
   \   00000248   0900A0E1           MOV      R0,R9
   \   0000024C   ........           _BLF     ??quickSort,??quickSort??rA
    218                
    219                // Переинициируем список и освободим память
    220                if (isDirectSort)
   \                     ??SortList_22:
   \   00000250   000056E3           CMP      R6,#+0
   \   00000254   1000000A           BEQ      ??SortList_23
    221                {
    222                  base = sortInfo[0];
   \   00000258   004099E5           LDR      R4,[R9, #+0]
    223                  for (i = 0; i < count - 1; i++)
   \   0000025C   0050A0E3           MOV      R5,#+0
   \   00000260   010047E2           SUB      R0,R7,#+1
   \   00000264   010050E3           CMP      R0,#+1
   \   00000268   050000AA           BGE      ??SortList_24
   \   0000026C   070000EA           B        ??SortList_25
    224                    sortInfo[i]->next = sortInfo[i + 1];
   \                     ??SortList_26:
   \   00000270   050189E0           ADD      R0,R9,R5, LSL #+2
   \   00000274   001090E5           LDR      R1,[R0, #+0]
   \   00000278   040090E5           LDR      R0,[R0, #+4]
   \   0000027C   015085E2           ADD      R5,R5,#+1
   \   00000280   440081E5           STR      R0,[R1, #+68]
   \                     ??SortList_24:
   \   00000284   010047E2           SUB      R0,R7,#+1
   \   00000288   000055E1           CMP      R5,R0
   \   0000028C   F7FFFFBA           BLT      ??SortList_26
    225                  sortInfo[count - 1]->next = 0;
   \                     ??SortList_25:
   \   00000290   070189E0           ADD      R0,R9,R7, LSL #+2
   \   00000294   040010E5           LDR      R0,[R0, #-4]
   \   00000298   0C0000EA           B        ??SortList_27
    226                }
    227                else
    228                {
    229                  base = sortInfo[count - 1];
   \                     ??SortList_23:
   \   0000029C   070189E0           ADD      R0,R9,R7, LSL #+2
   \   000002A0   044010E5           LDR      R4,[R0, #-4]
    230                  for (i = count - 1; i > 0; i--)
   \   000002A4   015047E2           SUB      R5,R7,#+1
   \   000002A8   010055E3           CMP      R5,#+1
   \   000002AC   060000BA           BLT      ??SortList_28
    231                    sortInfo[i]->next = sortInfo[i - 1];
   \                     ??SortList_29:
   \   000002B0   050189E0           ADD      R0,R9,R5, LSL #+2
   \   000002B4   001090E5           LDR      R1,[R0, #+0]
   \   000002B8   040010E5           LDR      R0,[R0, #-4]
   \   000002BC   015045E2           SUB      R5,R5,#+1
   \   000002C0   440081E5           STR      R0,[R1, #+68]
   \   000002C4   010055E3           CMP      R5,#+1
   \   000002C8   F8FFFFAA           BGE      ??SortList_29
    232                  sortInfo[0]->next = 0;
   \                     ??SortList_28:
   \   000002CC   000099E5           LDR      R0,[R9, #+0]
   \                     ??SortList_27:
   \   000002D0   0010A0E3           MOV      R1,#+0
   \   000002D4   441080E5           STR      R1,[R0, #+68]
    233                }
    234                delete(sortInfo);
   \   000002D8   B3FFFFEA           B        ??SortList_14
    235              }
    236              else
    237              {
    238                MsgBoxError(muitxt(ind_err_nomemory));
   \                     ??SortList_3:
   \   000002DC   5700A0E3           MOV      R0,#+87
   \   000002E0   ........           _BLF     ??muitxt,??muitxt??rA
   \   000002E4   ........           _BLF     ??MsgBoxError,??MsgBoxError??rA
    239              }
    240            }
    241            return base;
   \   000002E8   0400A0E1           MOV      R0,R4
   \   000002EC   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??SortList_6:
   \   000002F0   ........           DC32     str_empty
   \   000002F4   ........           DC32     ??isNameGreater
   \   000002F8   ........           DC32     ??isExtGreater
   \   000002FC   ........           DC32     ??isDateGreater
   \   00000300   ........           DC32     ??isSizeGreater
    242          }
    243          
    244          
    245          

   \                                 In segment CODE, align 4, keep-with-next
    246          void SortFiles(int tab)
    247          {
   \                     ??SortFiles:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    248            if (tabs[tab]->ccFiles>1)
   \   00000008   EC009FE5           LDR      R0,??SortFiles_1  ;; tabs
   \   0000000C   040190E7           LDR      R0,[R0, +R4, LSL #+2]
   \   00000010   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000014   020050E3           CMP      R0,#+2
   \   00000018   F080BDB8           POPLT    {R4-R7,PC}
    249            {
    250              FILEINF *files=0;
    251              FILEINF *dirs=0;
    252              
    253              FILEINF *cur = (FILEINF *)(FileListBase[tab]->next);
   \   0000001C   DC109FE5           LDR      R1,??SortFiles_1+0x4  ;; FileListBase
   \   00000020   0050A0E3           MOV      R5,#+0
   \   00000024   041181E0           ADD      R1,R1,R4, LSL #+2
   \   00000028   001091E5           LDR      R1,[R1, #+0]
   \   0000002C   0000A0E3           MOV      R0,#+0
   \   00000030   442091E5           LDR      R2,[R1, #+68]
   \   00000034   010052E1           CMP      R2,R1
   \   00000038   0C00000A           BEQ      ??SortFiles_2
    254              FILEINF *next;
    255              while(cur != FileListBase[tab])
    256              {
    257                next = (FILEINF *)cur->next;
    258                if (cur->attr & FA_DIRECTORY)
   \                     ??SortFiles_3:
   \   0000003C   B810D2E1           LDRH     R1,[R2, #+8]
   \   00000040   443092E5           LDR      R3,[R2, #+68]
   \   00000044   400C11E3           TST      R1,#0x4000
    259                {
    260                  cur->next = dirs;
   \   00000048   0010A011           MOVNE    R1,R0
    261                  dirs = cur;
    262                }
    263                else
    264                {
    265                  cur->next = files;
   \   0000004C   0510A001           MOVEQ    R1,R5
    266                  files = cur;
   \   00000050   441082E5           STR      R1,[R2, #+68]
    267                }
    268                cur = next;
    269              }
   \   00000054   A4109FE5           LDR      R1,??SortFiles_1+0x4  ;; FileListBase
   \   00000058   0200A011           MOVNE    R0,R2
   \   0000005C   041191E7           LDR      R1,[R1, +R4, LSL #+2]
   \   00000060   0250A001           MOVEQ    R5,R2
   \   00000064   0320A0E1           MOV      R2,R3
   \   00000068   010052E1           CMP      R2,R1
   \   0000006C   F2FFFF1A           BNE      ??SortFiles_3
    270              FileListBase[tab]->next = FileListBase[tab];
   \                     ??SortFiles_2:
   \   00000070   88109FE5           LDR      R1,??SortFiles_1+0x4  ;; FileListBase
   \   00000074   041181E0           ADD      R1,R1,R4, LSL #+2
   \   00000078   001091E5           LDR      R1,[R1, #+0]
   \   0000007C   441081E5           STR      R1,[R1, #+68]
    271          
    272              int srt = tabs[tab]->sort;
   \   00000080   74109FE5           LDR      R1,??SortFiles_1  ;; tabs
   \   00000084   041191E7           LDR      R1,[R1, +R4, LSL #+2]
   \   00000088   F270D1E1           LDRSH    R7,[R1, #+2]
    273              
    274              if (srt & STV_MASK == ST_SIZE)
    275                dirs = SortList(dirs,  srt & STD_MASK); // При сортировке по размеру папки сортируем по имени
    276              else
    277                dirs = SortList(dirs,  srt);
   \   0000008C   0710A0E1           MOV      R1,R7
   \   00000090   ........           BL       ??SortList
   \   00000094   0060A0E1           MOV      R6,R0
    278              
    279              files = SortList(files, srt);
   \   00000098   0710A0E1           MOV      R1,R7
   \   0000009C   0500A0E1           MOV      R0,R5
   \   000000A0   ........           BL       ??SortList
   \   000000A4   000050E3           CMP      R0,#+0
   \   000000A8   0800000A           BEQ      ??SortFiles_4
    280              
    281              while(files)
    282              {
    283                next = (FILEINF *)files->next;
    284                files->next = FileListBase[tab]->next;
   \                     ??SortFiles_5:
   \   000000AC   4C109FE5           LDR      R1,??SortFiles_1+0x4  ;; FileListBase
   \   000000B0   443090E5           LDR      R3,[R0, #+68]
   \   000000B4   041181E0           ADD      R1,R1,R4, LSL #+2
   \   000000B8   001091E5           LDR      R1,[R1, #+0]
   \   000000BC   442091E5           LDR      R2,[R1, #+68]
   \   000000C0   442080E5           STR      R2,[R0, #+68]
    285                FileListBase[tab]->next = files;
   \   000000C4   440081E5           STR      R0,[R1, #+68]
    286                files = next;
   \   000000C8   0300B0E1           MOVS     R0,R3
    287              }
   \   000000CC   F6FFFF1A           BNE      ??SortFiles_5
    288              while(dirs)
   \                     ??SortFiles_4:
   \   000000D0   000056E3           CMP      R6,#+0
   \   000000D4   F080BD08           POPEQ    {R4-R7,PC}
    289              {
    290                next = (FILEINF *)dirs->next;
    291                dirs->next = FileListBase[tab]->next;
   \   000000D8   20109FE5           LDR      R1,??SortFiles_1+0x4  ;; FileListBase
   \   000000DC   443096E5           LDR      R3,[R6, #+68]
   \   000000E0   041181E0           ADD      R1,R1,R4, LSL #+2
   \   000000E4   001091E5           LDR      R1,[R1, #+0]
   \   000000E8   440091E5           LDR      R0,[R1, #+68]
   \   000000EC   440086E5           STR      R0,[R6, #+68]
    292                FileListBase[tab]->next = dirs;
   \   000000F0   446081E5           STR      R6,[R1, #+68]
    293                dirs = next;
   \   000000F4   0360A0E1           MOV      R6,R3
   \   000000F8   F4FFFFEA           B        ??SortFiles_4
   \                     ??SortFiles_1:
   \   000000FC   ........           DC32     tabs
   \   00000100   ........           DC32     FileListBase
    294              }
    295            }
    296          }

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     SortFiles(int)                    20
     SortList(FILEINF *, int)          36
     filenamecmp(FileSortInfo *, FileSortInfo *)
                                       20
     fn_prepare(wchar_t *, wchar_t *)
                                       16
     isDateGreater(void *, void *)      4
     isExtGreater(void *, void *)      12
     isNameGreater(void *, void *)     12
     isSizeGreater(void *, void *)      4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     fn_prepare(wchar_t *, wchar_t *)
                                      52
     filenamecmp(FileSortInfo *, FileSortInfo *)
                                     156
     isNameGreater(void *, void *)    56
     isExtGreater(void *, void *)     64
     isSizeGreater(void *, void *)    68
     isDateGreater(void *, void *)    68
     SortList(FILEINF *, int)        772
     SortFiles(int)                  260
      Others                         140

 
 1 636 bytes in segment CODE
 
 1 496 bytes of CODE memory (+ 140 bytes shared)

Errors: none
Warnings: none
